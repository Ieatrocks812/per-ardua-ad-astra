<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle ‚Ä¢ A: Pitch Up ‚Ä¢ D: Pitch Down ‚Ä¢ Q/E: Zoom ‚Ä¢ Arrows: Roll ‚Ä¢ F: Flip ‚Ä¢ G: Gear ‚Ä¢ C: Debug ‚Ä¢ R: Reset
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants
      const SCALE = 20; // pixels per meter
      const WORLD_WIDTH = 4000; // meters
      const WORLD_HEIGHT = 3000; // meters
      const MAP_BOTTOM_ALTITUDE = 600; // bottom of map is 600 m above ground (ground at 0 m)
      
      // Physics world
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        tileableMap: null,
        spitfire: null,
        spitfireInverted: null,
        spitfireGear: null,
        spitfireInvertedGear: null,
        loaded: { map: false, tileableMap: false, spitfire: false, spitfireInverted: false, spitfireGear: false, spitfireInvertedGear: false }
      };
      
      async function loadAssets() {
        console.log('üéÆ Starting asset loading...');
        console.log('üìç Current location:', window.location.href);
        console.log('üìÇ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          tileableMap: [
            '../assets/sprites/environment/tileable map.png',
            './assets/sprites/environment/tileable map.png',
            '/assets/sprites/environment/tileable map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            './assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            '/assets/sprites/aircraft/player/Spitfire facing right with gear.png'
          ],
          spitfireInverted: [
            '../assets/sprites/aircraft/player/spitfire upside down.png',
            './assets/sprites/aircraft/player/spitfire upside down.png',
            '/assets/sprites/aircraft/player/spitfire upside down.png'
          ],
          spitfireGear: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ],
          spitfireInvertedGear: [
            '../assets/sprites/aircraft/player/spitfire upside down with gear.png',
            './assets/sprites/aircraft/player/spitfire upside down with gear.png',
            '/assets/sprites/aircraft/player/spitfire upside down with gear.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`üì∑ Trying ${name} from: ${currentPath}`);
              console.log(`üîó Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`‚úÖ ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`‚ùå ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load all assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('tileableMap', assetPaths.tileableMap),
            loadImage('spitfire', assetPaths.spitfire),
            loadImage('spitfireInverted', assetPaths.spitfireInverted),
            loadImage('spitfireGear', assetPaths.spitfireGear),
            loadImage('spitfireInvertedGear', assetPaths.spitfireInvertedGear)
          ]);
          console.log('üéâ All assets loaded successfully!');
          console.log('üìä Final asset load status:', assets.loaded);
          
          // Specifically check gear sprites
          console.log('üõ¨ Gear sprite status:', {
            spitfireGear: { loaded: assets.loaded.spitfireGear, hasImage: !!assets.spitfireGear },
            spitfireInvertedGear: { loaded: assets.loaded.spitfireInvertedGear, hasImage: !!assets.spitfireInvertedGear }
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è Some assets failed to load:', error.message);
          console.log('üéÆ Game will continue with fallback graphics');
          console.log('üìä Asset load status after error:', assets.loaded);
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // Debug: Log initial game state
      setTimeout(() => {
        console.log('üöÄ Initial game state at startup:', {
          inverted: game.inverted,
          gearDown: game.gearDown,
          expectedSprite: 'Should be normal Spitfire facing right (no gear)'
        });
      }, 1000);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.2, maxZoom: 9.0 }, // 3x greater max zoom
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        crashed: false,
        inverted: false,
        gearDown: false
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        game.keys.add(key);
        console.log('üéØ Key pressed:', key); // Debug key presses
        
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c','f','g'].includes(key)) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (key === 'c') {
          game.showCollision = !game.showCollision;
          console.log('üîç Collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
        
        // Toggle inverted flight mode
        if (key === 'f') {
          const oldInverted = game.inverted;
          game.inverted = !game.inverted;
          console.log('üîÑ Flight mode changed:', oldInverted ? 'INVERTED' : 'NORMAL', '‚Üí', game.inverted ? 'INVERTED' : 'NORMAL');
          console.log('üîÑ F key - Game state after flip:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        
        // Toggle landing gear
        if (key === 'g') {
          const oldGear = game.gearDown;
          game.gearDown = !game.gearDown;
          console.log('üõ¨ Gear changed:', oldGear ? 'DOWN' : 'UP', '‚Üí', game.gearDown ? 'DOWN' : 'UP');
          console.log('üõ¨ G key - Game state after gear toggle:', { inverted: game.inverted, gearDown: game.gearDown });
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn above ground within main map (y increases downward)
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, -600), // 600 m above ground level (y=0)
        angle: 0,
        linearDamping: 0.1,
        angularDamping: 2.5 // High damping for instant pitch stop when controls released
      });
      
      aircraft.createFixture({
        shape: pl.Box(8, 2.5), // 16m x 5m aircraft
        density: 20, // kg/m¬≤
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create infinite ground collision at y=0 (physical ground)
        const groundLevel = 0; // ground at 0 m altitude
        const halfThickness = 0.5; // keep collider thin around y=0
        const infiniteWidth = 100000; // Very wide ground - 100km in each direction
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel) // center at y=0
        });
        
        groundBody.createFixture({
          shape: pl.Box(infiniteWidth / 2, halfThickness),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel,
          width: infiniteWidth,
          height: halfThickness * 2,
          isMainGround: true
        });
        
        console.log(`üü¢ Created infinite ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // Add collision detection for landing/crashing system
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft hit ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const verticalSpeed = Math.abs(vel.y); // Vertical component only
          const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          console.log(`üõ¨ Ground contact - Vertical: ${verticalSpeed.toFixed(1)} m/s, Total: ${totalSpeed.toFixed(1)} m/s, Gear: ${game.gearDown ? 'DOWN' : 'UP'}`);
          
          // Define crash threshold for vertical speed
          const crashThreshold = 8.0; // m/s vertical speed threshold
          const hardLandingThreshold = 4.0; // m/s for speed reduction without gear
          
          if (verticalSpeed > crashThreshold) {
            // High vertical speed = crash regardless of gear
            game.crashed = true;
            console.log('üí• CRASHED! Vertical speed too high:', verticalSpeed.toFixed(1), 'm/s');
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else if (!game.gearDown && verticalSpeed > hardLandingThreshold) {
            // Hard landing without gear = lose speed but don't crash
            console.log('‚ö†Ô∏è Hard landing without gear! Losing speed...');
            const speedReduction = 0.3; // Reduce speed by 70%
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * speedReduction,
              vel.y * speedReduction
            ));
            // Add some bounce/instability
            aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 2);
          } else if (game.gearDown) {
            // Safe landing with gear down
            console.log('‚úÖ Safe landing with gear down!');
            // Gentle speed reduction for realistic landing
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.8,
              Math.min(vel.y, 0) // Stop downward motion
            ));
          } else {
            // Low speed ground contact without gear (gentle bump)
            console.log('üü° Gentle ground contact');
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.9,
              Math.min(vel.y, 0)
            ));
          }
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, -600), 0); // Reset to safe altitude above ground
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Flight controls - High torque to overcome high angular damping for instant response
        const torque = 60000; // Much higher torque to overcome increased damping
        if (pitchUp) aircraft.applyTorque(-torque, true);
        if (pitchDown) aircraft.applyTorque(torque, true);
        if (rollLeft) aircraft.applyTorque(-torque * 0.7, true);
        if (rollRight) aircraft.applyTorque(torque * 0.7, true);
        
        // Thrust - Increased engine power
        const maxThrust = 60000; // Doubled from 30000 for more power
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // Simple aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        if (speed > 1) {
          const airDensity = 1.225;
          const wingArea = 20;
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified)
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          const liftCoeff = Math.sin(aoa * 2) * 1.5;
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag - Further reduced for higher top speeds
          const dragCoeff = 0.02 + Math.abs(liftCoeff) * 0.025; // Quarter of original for much higher speeds
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background - main map in center, tileable on sides
        const groundLevel = 0; // physical ground reference
        const mapHeight = WORLD_HEIGHT;
        
        if (assets.loaded.map && assets.map && assets.loaded.tileableMap && assets.tileableMap) {
          // Calculate main map dimensions and position
          const mainMapWidth = WORLD_WIDTH; // 4000m wide
          const mainMapPixelWidth = mainMapWidth * SCALE * game.camera.zoom;
          const mainMapPixelHeight = mapHeight * SCALE * game.camera.zoom;
          // Draw main map in center such that its bottom sits at MAP_BOTTOM_ALTITUDE
          // So the draw origin (top-left) is at y = (MAP_BOTTOM_ALTITUDE - mapHeight)
          const mainMapPos = worldToScreen(-mainMapWidth/2, MAP_BOTTOM_ALTITUDE - mapHeight);
          ctx.drawImage(assets.map, mainMapPos.x, mainMapPos.y, mainMapPixelWidth, mainMapPixelHeight);
          
          // Calculate tileable map dimensions
          const tileableMapNaturalRatio = assets.tileableMap.naturalWidth / assets.tileableMap.naturalHeight;
          const tileableMapPixelHeight = mainMapPixelHeight; // Same height as main map
          const tileableMapPixelWidth = tileableMapPixelHeight * tileableMapNaturalRatio;
          const tileableMapWorldWidth = tileableMapPixelWidth / (SCALE * game.camera.zoom);
          
          // Draw tileable maps on the left side
          const leftStartX = -mainMapWidth/2;
          const visibleLeftStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - leftStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + leftStartX;
          for (let x = visibleLeftStart; x > game.camera.x - canvasWidth/(SCALE*game.camera.zoom); x -= tileableMapWorldWidth) {
            const tilePos = worldToScreen(x - tileableMapWorldWidth, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
          // Draw tileable maps on the right side
          const rightStartX = mainMapWidth/2;
          const visibleRightStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - rightStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + rightStartX;
          for (let x = visibleRightStart; x < game.camera.x + canvasWidth/(SCALE*game.camera.zoom); x += tileableMapWorldWidth) {
            const tilePos = worldToScreen(x, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map || !assets.loaded.tileableMap) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading maps...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        // Debug: Log aircraft state periodically
        if (Math.random() < 0.02) { // 2% chance per frame for debugging
          console.log('‚úàÔ∏è Aircraft state:', {
            angle: (angle * 180 / Math.PI).toFixed(1) + '¬∞',
            inverted: game.inverted,
            gearDown: game.gearDown,
            position: { x: pos.x.toFixed(1), y: pos.y.toFixed(1) },
            expectedSprite: game.inverted && game.gearDown ? 'inverted+gear' : 
                          game.inverted && !game.gearDown ? 'inverted' :
                          !game.inverted && game.gearDown ? 'normal+gear' : 'normal'
          });
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        // Choose sprite based on inverted mode and gear state
        let currentSprite, spriteLoaded, spriteDescription;
        
        if (game.inverted && game.gearDown) {
          currentSprite = assets.spitfireInvertedGear;
          spriteLoaded = assets.loaded.spitfireInvertedGear;
          spriteDescription = "inverted with gear";
        } else if (game.inverted && !game.gearDown) {
          currentSprite = assets.spitfireInverted;
          spriteLoaded = assets.loaded.spitfireInverted;
          spriteDescription = "inverted no gear";
        } else if (!game.inverted && game.gearDown) {
          currentSprite = assets.spitfireGear;
          spriteLoaded = assets.loaded.spitfireGear;
          spriteDescription = "normal with gear";
        } else {
          currentSprite = assets.spitfire;
          spriteLoaded = assets.loaded.spitfire;
          spriteDescription = "normal no gear";
        }
        
        // Debug: Log sprite selection when gear changes
        if (game.keys.has('g') && Math.random() < 0.1) { // 10% chance when G is held
          console.log('üé® Sprite selection:', {
            description: spriteDescription,
            spriteLoaded: spriteLoaded,
            hasSprite: !!currentSprite,
            allLoadStates: assets.loaded
          });
        }
        
        if (spriteLoaded && currentSprite) {
          const scale = 0.4 * game.camera.zoom;
          const w = currentSprite.naturalWidth * scale;
          const h = currentSprite.naturalHeight * scale;
          ctx.drawImage(currentSprite, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          let fillColor = '#4169E1'; // Default blue
          if (game.inverted && game.gearDown) fillColor = '#800080'; // Purple for inverted with gear
          else if (game.inverted) fillColor = '#E14169'; // Red for inverted
          else if (game.gearDown) fillColor = '#228B22'; // Green for gear down
          
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = game.inverted ? '#801080' : '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
          
          // Draw gear indicator
          if (game.gearDown) {
            ctx.fillStyle = '#FFD700'; // Gold for gear
            ctx.fillRect(-size*0.3, size*0.3, size*0.6, size*0.2);
          }
        }
        
        ctx.restore();
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed);
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        // Altitude: distance above ground. Our world uses y increasing downward, so altitude is -y when above ground
        document.getElementById('altitude').textContent = Math.max(0, Math.round(-pos.y));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'üí• CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start
      console.log('Starting flight simulator...');
      gameLoop(performance.now());
      
    })();
  </script>
</body>
</html>