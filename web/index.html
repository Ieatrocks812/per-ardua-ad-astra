<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle ‚Ä¢ A: Pitch Up ‚Ä¢ D: Pitch Down ‚Ä¢ Q/E: Zoom ‚Ä¢ Arrows: Roll ‚Ä¢ F: Flip ‚Ä¢ G: Gear ‚Ä¢ Space: Fire ‚Ä¢ C: Debug ‚Ä¢ R: Reset
  </div>

  <!-- Start Screen -->
  <div id="startScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #2F4F4F 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    font-family: 'Arial', sans-serif;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  ">
    <h1 style="font-size: 4rem; margin-bottom: 1rem; text-align: center;">
      Per Ardua ad Astra
    </h1>
    <p style="font-size: 1.5rem; margin-bottom: 3rem; text-align: center; opacity: 0.9;">
      "Through Adversity to the Stars"
    </p>
    <button id="startButton" style="
      font-size: 1.5rem;
      padding: 1rem 3rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      text-shadow: none;
      font-weight: bold;
    " onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='scale(1.1)'" 
       onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='scale(1)'">
      START FLIGHT
    </button>
    <div style="margin-top: 2rem; text-align: center; opacity: 0.7; font-size: 0.9rem;">
      <p>üéÆ Use W/S for throttle, A/D for pitch, arrows for roll</p>
      <p>üî´ Press SPACE to fire wing guns with tracers and casings</p>
      <p>‚úàÔ∏è Realistic flight physics with altitude effects above 5000m</p>
    </div>
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';
      
      // Game state
      let gameStarted = false;
      
      // Start screen functionality
      document.getElementById('startButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('üöÄ Starting game...');
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        initializeGame();
      });
      
      // Initialize game function
      function initializeGame() {

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants - Physics world scaling for higher speeds (more reasonable scaling)
      const PHYSICS_SCALE = 0.5; // Physics objects are 2x smaller for higher speeds
      const VISUAL_SCALE = 2.0; // Visual rendering compensates with 2x scaling  
      const SCALE = 20 * VISUAL_SCALE; // Base pixels per meter (40 after scaling)
      const WORLD_WIDTH = 4000 * PHYSICS_SCALE; // Physics: 400 units (visually 4000m)
      const WORLD_HEIGHT = 3000 * PHYSICS_SCALE; // Physics: 300 units (visually 3000m)
      const MAP_BOTTOM_ALTITUDE = 300; // Physics: 300 units above ground (visually 600m)
      
      // Physics world
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Remove Box2D velocity limits for higher speeds
      // Default is 2.0 units per timestep (120 m/s at 60fps)
      console.log('üîß Attempting to override Box2D velocity limits...');
      
      if (world.setMaxLinearVelocity) {
        world.setMaxLinearVelocity(10.0); // Allow up to 600 m/s
        console.log('‚úÖ Set world max linear velocity to 10.0');
      }
      
      // Alternative method for Planck.js
      if (pl.Settings) {
        console.log('üìä Original Settings:', { 
          maxTranslation: pl.Settings.maxTranslation, 
          maxLinearVelocity: pl.Settings.maxLinearVelocity 
        });
        pl.Settings.maxTranslation = 10.0; // Increase from default 2.0
        pl.Settings.maxLinearVelocity = 600.0; // Direct velocity limit
        console.log('‚úÖ Updated Settings:', { 
          maxTranslation: pl.Settings.maxTranslation, 
          maxLinearVelocity: pl.Settings.maxLinearVelocity 
        });
      } else {
        console.log('‚ö†Ô∏è pl.Settings not available');
      }
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        tileableMap: null,
        spitfire: null,
        spitfireInverted: null,
        spitfireGear: null,
        spitfireInvertedGear: null,
        bullet: null,
        tracer: null,
        casing: null,
        loaded: { map: false, tileableMap: false, spitfire: false, spitfireInverted: false, spitfireGear: false, spitfireInvertedGear: false, bullet: false, tracer: false, casing: false }
      };
      
      async function loadAssets() {
        console.log('üéÆ Starting asset loading...');
        console.log('üìç Current location:', window.location.href);
        console.log('üìÇ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          tileableMap: [
            '../assets/sprites/environment/tileable map.png',
            './assets/sprites/environment/tileable map.png',
            '/assets/sprites/environment/tileable map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            './assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            '/assets/sprites/aircraft/player/Spitfire facing right with gear.png'
          ],
          spitfireInverted: [
            '../assets/sprites/aircraft/player/spitfire upside down.png',
            './assets/sprites/aircraft/player/spitfire upside down.png',
            '/assets/sprites/aircraft/player/spitfire upside down.png'
          ],
          spitfireGear: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ],
          spitfireInvertedGear: [
            '../assets/sprites/aircraft/player/spitfire upside down with gear.png',
            './assets/sprites/aircraft/player/spitfire upside down with gear.png',
            '/assets/sprites/aircraft/player/spitfire upside down with gear.png'
          ],
          bullet: [
            '../assets/sprites/effects/bullet.png',
            './assets/sprites/effects/bullet.png',
            '/assets/sprites/effects/bullet.png'
          ],
          tracer: [
            '../assets/sprites/effects/tracer_round.png',
            './assets/sprites/effects/tracer_round.png',
            '/assets/sprites/effects/tracer_round.png'
          ],
          casing: [
            '../assets/sprites/effects/casing.png',
            './assets/sprites/effects/casing.png',
            '/assets/sprites/effects/casing.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`üì∑ Trying ${name} from: ${currentPath}`);
              console.log(`üîó Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`‚úÖ ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`‚ùå ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load all assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('tileableMap', assetPaths.tileableMap),
            loadImage('spitfire', assetPaths.spitfire),
            loadImage('spitfireInverted', assetPaths.spitfireInverted),
            loadImage('spitfireGear', assetPaths.spitfireGear),
            loadImage('spitfireInvertedGear', assetPaths.spitfireInvertedGear),
            loadImage('bullet', assetPaths.bullet),
            loadImage('tracer', assetPaths.tracer),
            loadImage('casing', assetPaths.casing)
          ]);
          console.log('üéâ All assets loaded successfully!');
          console.log('üìä Final asset load status:', assets.loaded);
          
          // Specifically check gear sprites
          console.log('üõ¨ Gear sprite status:', {
            spitfireGear: { loaded: assets.loaded.spitfireGear, hasImage: !!assets.spitfireGear },
            spitfireInvertedGear: { loaded: assets.loaded.spitfireInvertedGear, hasImage: !!assets.spitfireInvertedGear }
          });
          console.log('üî´ Ordnance asset status:', {
            bullet: { loaded: assets.loaded.bullet, hasImage: !!assets.bullet },
            tracer: { loaded: assets.loaded.tracer, hasImage: !!assets.tracer },
            casing: { loaded: assets.loaded.casing, hasImage: !!assets.casing }
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è Some assets failed to load:', error.message);
          console.log('üéÆ Game will continue with fallback graphics');
          console.log('üìä Asset load status after error:', assets.loaded);
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // Debug: Log initial game state
      setTimeout(() => {
        console.log('üöÄ Initial game state at startup:', {
          inverted: game.inverted,
          gearDown: game.gearDown,
          expectedSprite: 'Should be normal Spitfire facing right (no gear)'
        });
      }, 1000);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.2, maxZoom: 9.0 }, // 3x greater max zoom
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        crashed: false,
        inverted: false,
        gearDown: false,
        projectiles: [], // bullets and tracers
        casings: [] // ejected shells
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        game.keys.add(key);
        console.log('üéØ Key pressed:', key); // Debug key presses
        
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c','f','g',' '].includes(key)) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (key === 'c') {
          game.showCollision = !game.showCollision;
          console.log('üîç Collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
        
        // Toggle inverted flight mode
        if (key === 'f') {
          const oldInverted = game.inverted;
          game.inverted = !game.inverted;
          console.log('üîÑ Flight mode changed:', oldInverted ? 'INVERTED' : 'NORMAL', '‚Üí', game.inverted ? 'INVERTED' : 'NORMAL');
          console.log('üîÑ F key - Game state after flip:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        
        // Toggle landing gear
        if (key === 'g') {
          const oldGear = game.gearDown;
          game.gearDown = !game.gearDown;
          console.log('üõ¨ Gear changed:', oldGear ? 'DOWN' : 'UP', '‚Üí', game.gearDown ? 'DOWN' : 'UP');
          console.log('üõ¨ G key - Game state after gear toggle:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        // Fire guns (space)
        if (key === ' ' || e.code === 'Space') {
          console.log('üéØ SPACE pressed - attempting to fire guns');
          trySpawnGuns();
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn above ground within main map (scaled physics)
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, -300), // 300 physics units above ground (visually 600m)
        angle: 0,
        linearDamping: 0.02, // Reduced from 0.1 for higher top speeds
        angularDamping: 8.0 // Very high damping for instant stop when controls released (works with force-based controls)
      });
      
      aircraft.createFixture({
        shape: pl.Box(4, 1.25), // 8m x 2.5m aircraft (scaled down 2x)
        density: 20, // kg/m¬≤
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create infinite ground collision at y=0 (physical ground - scaled)
        const groundLevel = 0; // ground at 0 altitude
        const halfThickness = 0.25; // scaled down collision thickness (2x scaling)
        const infiniteWidth = 50000; // Very wide ground - scaled down (2x scaling)
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel) // center at y=0
        });
        
        groundBody.createFixture({
          shape: pl.Box(infiniteWidth / 2, halfThickness),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel,
          width: infiniteWidth,
          height: halfThickness * 2,
          isMainGround: true
        });
        
        console.log(`üü¢ Created infinite ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // =============================================================================
      // GUNS AND PROJECTILES
      // =============================================================================
      
      let lastFireTime = 0;
      const fireRate = 600; // rounds per minute
      const fireInterval = 60000 / fireRate; // ms between shots
      
      function trySpawnGuns() {
        console.log('üî´ trySpawnGuns called');
        const now = performance.now();
        console.log('üïí Fire timing:', { now, lastFireTime, interval: fireInterval, canFire: now - lastFireTime >= fireInterval });
        if (now - lastFireTime < fireInterval) {
          console.log('‚è±Ô∏è Fire rate limited, skipping');
          return;
        }
        lastFireTime = now;
        
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const vel = aircraft.getLinearVelocity();
        
        // Wing gun positions (front of wings)
        const wingSpread = 3.0; // Distance from center to wing guns (scaled physics)
        const wingForward = 1.5; // Forward from center to gun muzzles
        
        // Calculate gun positions
        const leftGunPos = {
          x: pos.x + Math.cos(angle) * wingForward - Math.sin(angle) * wingSpread,
          y: pos.y + Math.sin(angle) * wingForward + Math.cos(angle) * wingSpread
        };
        const rightGunPos = {
          x: pos.x + Math.cos(angle) * wingForward + Math.sin(angle) * wingSpread,
          y: pos.y + Math.sin(angle) * wingForward - Math.cos(angle) * wingSpread
        };
        
        // Muzzle velocity (relative to aircraft)
        const muzzleVelocity = 150; // m/s in physics units
        const bulletVel = {
          x: vel.x + Math.cos(angle) * muzzleVelocity,
          y: vel.y + Math.sin(angle) * muzzleVelocity
        };
        
        // Spawn bullets and tracers (every 5th round is a tracer)
        const isTracer = game.projectiles.length % 5 === 0;
        
        // Left gun
        game.projectiles.push({
          x: leftGunPos.x,
          y: leftGunPos.y,
          vx: bulletVel.x,
          vy: bulletVel.y,
          type: isTracer ? 'tracer' : 'bullet',
          life: 5.0, // 5 seconds max flight time
          initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y)
        });
        
        // Right gun
        game.projectiles.push({
          x: rightGunPos.x,
          y: rightGunPos.y,
          vx: bulletVel.x,
          vy: bulletVel.y,
          type: isTracer ? 'tracer' : 'bullet',
          life: 5.0,
          initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y)
        });
        
        // Spawn casing from bottom of aircraft
        const casingPos = {
          x: pos.x - Math.cos(angle) * 0.5, // Slightly behind center
          y: pos.y - Math.sin(angle) * 0.5 + 0.8 // Below aircraft
        };
        
        game.casings.push({
          x: casingPos.x,
          y: casingPos.y,
          vx: vel.x + (Math.random() - 0.5) * 10, // Random sideways velocity
          vy: vel.y + 15 + Math.random() * 10, // Downward with randomness
          rotation: Math.random() * Math.PI * 2,
          angularVel: (Math.random() - 0.5) * 20,
          life: 10.0 // Casings last longer
        });
        
        console.log('üî´ Fired guns! Projectiles:', game.projectiles.length, 'Casings:', game.casings.length);
        console.log('üéØ Latest projectile:', game.projectiles[game.projectiles.length - 1]);
        console.log('üéØ Latest casing:', game.casings[game.casings.length - 1]);
      }
      
      function updateProjectiles(dt) {
        // Update bullets and tracers
        for (let i = game.projectiles.length - 1; i >= 0; i--) {
          const proj = game.projectiles[i];
          
          // Apply drag
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const dragCoeff = 0.02; // Air resistance
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            proj.vx -= (proj.vx / speed) * drag * dt;
            proj.vy -= (proj.vy / speed) * drag * dt;
          }
          
          // Update position
          proj.x += proj.vx * dt;
          proj.y += proj.vy * dt;
          
          // Decrease life
          proj.life -= dt;
          
          // Remove if expired
          if (proj.life <= 0) {
            game.projectiles.splice(i, 1);
          }
        }
        
        // Update casings
        for (let i = game.casings.length - 1; i >= 0; i--) {
          const casing = game.casings[i];
          
          // Apply gravity and drag
          casing.vy += 9.81 * dt; // Gravity
          
          const speed = Math.sqrt(casing.vx * casing.vx + casing.vy * casing.vy);
          const dragCoeff = 0.05; // More drag for casings
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            casing.vx -= (casing.vx / speed) * drag * dt;
            casing.vy -= (casing.vy / speed) * drag * dt;
          }
          
          // Update position and rotation
          casing.x += casing.vx * dt;
          casing.y += casing.vy * dt;
          casing.rotation += casing.angularVel * dt;
          
          // Decrease life
          casing.life -= dt;
          
          // Remove if expired
          if (casing.life <= 0) {
            game.casings.splice(i, 1);
          }
        }
      }
      
      // Add collision detection for landing/crashing system
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft hit ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const verticalSpeed = Math.abs(vel.y); // Vertical component only
          const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          console.log(`üõ¨ Ground contact - Vertical: ${verticalSpeed.toFixed(1)} m/s, Total: ${totalSpeed.toFixed(1)} m/s, Gear: ${game.gearDown ? 'DOWN' : 'UP'}`);
          
          // Define crash threshold for vertical speed
          const crashThreshold = 8.0; // m/s vertical speed threshold
          const hardLandingThreshold = 4.0; // m/s for speed reduction without gear
          
          if (verticalSpeed > crashThreshold) {
            // High vertical speed = crash regardless of gear
            game.crashed = true;
            console.log('üí• CRASHED! Vertical speed too high:', verticalSpeed.toFixed(1), 'm/s');
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else if (!game.gearDown && verticalSpeed > hardLandingThreshold) {
            // Hard landing without gear = lose speed but don't crash
            console.log('‚ö†Ô∏è Hard landing without gear! Losing speed...');
            const speedReduction = 0.3; // Reduce speed by 70%
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * speedReduction,
              vel.y * speedReduction
            ));
            // Add some bounce/instability
            aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 2);
          } else if (game.gearDown) {
            // Safe landing with gear down
            console.log('‚úÖ Safe landing with gear down!');
            // Gentle speed reduction for realistic landing
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.8,
              Math.min(vel.y, 0) // Stop downward motion
            ));
          } else {
            // Low speed ground contact without gear (gentle bump)
            console.log('üü° Gentle ground contact');
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.9,
              Math.min(vel.y, 0)
            ));
          }
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, -300), 0); // Reset to safe altitude above ground (scaled)
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Calculate speed once for use in both controls and aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        // Flight controls - Hybrid approach (force + torque for reliability)
        const controlEffectiveness = Math.min(speed * 0.1, 1.0); // Controls more effective at higher speeds
        const controlTorque = 20000 * controlEffectiveness; // Moderate torque for reliable control
        
        // Debug control inputs
        if (Math.random() < 0.02) { // Occasional debug logging
          console.log('üéÆ Controls:', { pitchUp, pitchDown, rollLeft, rollRight, effectiveness: controlEffectiveness.toFixed(2) });
        }
        
        if (pitchUp) {
          aircraft.applyTorque(-controlTorque, true);
        }
        if (pitchDown) {
          aircraft.applyTorque(controlTorque, true);
        }
        if (rollLeft) {
          aircraft.applyTorque(-controlTorque * 0.6, true);
        }
        if (rollRight) {
          aircraft.applyTorque(controlTorque * 0.6, true);
        }
        
        // Thrust - Further increased for higher top speeds with altitude reduction
        let maxThrust = 120000; // Quadrupled from original 30000 for much higher speeds
        
        // Altitude-based thrust reduction (same as lift)
        const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
        if (visualAltitude > 5000) {
          if (visualAltitude >= 5250) {
            maxThrust = 0; // No thrust above 5250m (engine failure)
          } else {
            // Linear reduction from 5000m to 5250m
            const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
            maxThrust *= reductionFactor;
          }
        }
        
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // Simple aerodynamics
        if (speed > 1) {
          const airDensity = 1.225;
          const wingArea = 20;
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified) with altitude-based reduction
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          let liftCoeff = Math.sin(aoa * 2) * 1.5;
          
          // Altitude-based lift reduction (physics units, converted to visual for calculation)
          const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
          if (visualAltitude > 5000) {
            if (visualAltitude >= 5250) {
              liftCoeff = 0; // No lift above 5250m
            } else {
              // Linear reduction from 5000m to 5250m
              const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
              liftCoeff *= reductionFactor;
            }
          }
          
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag - Minimized for very high top speeds
          const dragCoeff = 0.01 + Math.abs(liftCoeff) * 0.01; // Much lower drag for speeds well above 120 m/s
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background - main map in center, tileable on sides
        const groundLevel = 0; // physical ground reference
        const mapHeight = WORLD_HEIGHT;
        
        if (assets.loaded.map && assets.map && assets.loaded.tileableMap && assets.tileableMap) {
          // Calculate main map dimensions and position
          const mainMapWidth = WORLD_WIDTH; // 4000m wide
          const mainMapPixelWidth = mainMapWidth * SCALE * game.camera.zoom;
          const mainMapPixelHeight = mapHeight * SCALE * game.camera.zoom;
          // Draw main map in center such that its bottom sits at MAP_BOTTOM_ALTITUDE
          // So the draw origin (top-left) is at y = (MAP_BOTTOM_ALTITUDE - mapHeight)
          const mainMapPos = worldToScreen(-mainMapWidth/2, MAP_BOTTOM_ALTITUDE - mapHeight);
          ctx.drawImage(assets.map, mainMapPos.x, mainMapPos.y, mainMapPixelWidth, mainMapPixelHeight);
          
          // Calculate tileable map dimensions
          const tileableMapNaturalRatio = assets.tileableMap.naturalWidth / assets.tileableMap.naturalHeight;
          const tileableMapPixelHeight = mainMapPixelHeight; // Same height as main map
          const tileableMapPixelWidth = tileableMapPixelHeight * tileableMapNaturalRatio;
          const tileableMapWorldWidth = tileableMapPixelWidth / (SCALE * game.camera.zoom);
          
          // Draw tileable maps on the left side
          const leftStartX = -mainMapWidth/2;
          const visibleLeftStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - leftStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + leftStartX;
          for (let x = visibleLeftStart; x > game.camera.x - canvasWidth/(SCALE*game.camera.zoom); x -= tileableMapWorldWidth) {
            const tilePos = worldToScreen(x - tileableMapWorldWidth, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
          // Draw tileable maps on the right side
          const rightStartX = mainMapWidth/2;
          const visibleRightStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - rightStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + rightStartX;
          for (let x = visibleRightStart; x < game.camera.x + canvasWidth/(SCALE*game.camera.zoom); x += tileableMapWorldWidth) {
            const tilePos = worldToScreen(x, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map || !assets.loaded.tileableMap) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading maps...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        // Debug: Log aircraft state periodically
        if (Math.random() < 0.02) { // 2% chance per frame for debugging
          console.log('‚úàÔ∏è Aircraft state:', {
            angle: (angle * 180 / Math.PI).toFixed(1) + '¬∞',
            inverted: game.inverted,
            gearDown: game.gearDown,
            position: { x: pos.x.toFixed(1), y: pos.y.toFixed(1) },
            expectedSprite: game.inverted && game.gearDown ? 'inverted+gear' : 
                          game.inverted && !game.gearDown ? 'inverted' :
                          !game.inverted && game.gearDown ? 'normal+gear' : 'normal'
          });
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        // Choose sprite based on inverted mode and gear state
        let currentSprite, spriteLoaded, spriteDescription;
        
        if (game.inverted && game.gearDown) {
          currentSprite = assets.spitfireInvertedGear;
          spriteLoaded = assets.loaded.spitfireInvertedGear;
          spriteDescription = "inverted with gear";
        } else if (game.inverted && !game.gearDown) {
          currentSprite = assets.spitfireInverted;
          spriteLoaded = assets.loaded.spitfireInverted;
          spriteDescription = "inverted no gear";
        } else if (!game.inverted && game.gearDown) {
          currentSprite = assets.spitfireGear;
          spriteLoaded = assets.loaded.spitfireGear;
          spriteDescription = "normal with gear";
        } else {
          currentSprite = assets.spitfire;
          spriteLoaded = assets.loaded.spitfire;
          spriteDescription = "normal no gear";
        }
        
        // Debug: Log sprite selection when gear changes
        if (game.keys.has('g') && Math.random() < 0.1) { // 10% chance when G is held
          console.log('üé® Sprite selection:', {
            description: spriteDescription,
            spriteLoaded: spriteLoaded,
            hasSprite: !!currentSprite,
            allLoadStates: assets.loaded
          });
        }
        
        if (spriteLoaded && currentSprite) {
          const scale = 0.4 * game.camera.zoom;
          const w = currentSprite.naturalWidth * scale;
          const h = currentSprite.naturalHeight * scale;
          ctx.drawImage(currentSprite, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          let fillColor = '#4169E1'; // Default blue
          if (game.inverted && game.gearDown) fillColor = '#800080'; // Purple for inverted with gear
          else if (game.inverted) fillColor = '#E14169'; // Red for inverted
          else if (game.gearDown) fillColor = '#228B22'; // Green for gear down
          
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = game.inverted ? '#801080' : '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
          
          // Draw gear indicator
          if (game.gearDown) {
            ctx.fillStyle = '#FFD700'; // Gold for gear
            ctx.fillRect(-size*0.3, size*0.3, size*0.6, size*0.2);
          }
        }
        
        ctx.restore();
        
        // Render projectiles (bullets and tracers)
        if (game.projectiles.length > 0) {
          console.log('üé® Rendering', game.projectiles.length, 'projectiles');
        }
        game.projectiles.forEach(proj => {
          const screenPos = worldToScreen(proj.x, proj.y);
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const angle = Math.atan2(proj.vy, proj.vx);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(angle);
          
          if (proj.type === 'tracer') {
            // Tracer gets smaller as it slows down
            const speedRatio = speed / proj.initialSpeed;
            const tracerLength = Math.max(50, 100 * speedRatio * game.camera.zoom); // GIANT for testing
            const tracerWidth = Math.max(20, 40 * speedRatio * game.camera.zoom); // GIANT for testing
            
            if (assets.loaded.tracer && assets.tracer) {
              const scale = tracerLength / assets.tracer.naturalWidth;
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else {
              // Fallback tracer - made more visible
              ctx.fillStyle = `rgba(255, 100, 50, ${Math.max(0.5, 0.8 * speedRatio)})`;
              ctx.strokeStyle = '#FF0000';
              ctx.lineWidth = 1;
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              ctx.strokeRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            }
          } else {
            // Regular bullet
            const bulletSize = Math.max(30, 50 * game.camera.zoom); // GIANT for testing
            
            if (assets.loaded.bullet && assets.bullet) {
              const scale = bulletSize / Math.max(assets.bullet.naturalWidth, assets.bullet.naturalHeight);
              const w = assets.bullet.naturalWidth * scale;
              const h = assets.bullet.naturalHeight * scale;
              ctx.drawImage(assets.bullet, -w/2, -h/2, w, h);
            } else {
              // Fallback bullet - made more visible
              ctx.fillStyle = '#FFD700';
              ctx.strokeStyle = '#FF0000';
              ctx.lineWidth = 2;
              ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
              ctx.strokeRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
            }
          }
          
          ctx.restore();
        });
        
        // Render casings
        game.casings.forEach(casing => {
          const screenPos = worldToScreen(casing.x, casing.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(casing.rotation);
          
          const casingSize = Math.max(40, 60 * game.camera.zoom); // GIANT for testing
          
          if (assets.loaded.casing && assets.casing) {
            const scale = casingSize / Math.max(assets.casing.naturalWidth, assets.casing.naturalHeight);
            const w = assets.casing.naturalWidth * scale;
            const h = assets.casing.naturalHeight * scale;
            ctx.drawImage(assets.casing, -w/2, -h/2, w, h);
          } else {
            // Fallback casing - made more visible
            ctx.fillStyle = '#DAA520'; // Dark golden rod
            ctx.strokeStyle = '#FF0000'; // Red outline for visibility
            ctx.lineWidth = 2;
            ctx.fillRect(-casingSize/2, -casingSize/3, casingSize, casingSize*2/3);
            ctx.strokeRect(-casingSize/2, -casingSize/3, casingSize, casingSize*2/3);
          }
          
          ctx.restore();
        });
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed * VISUAL_SCALE); // Convert to visual speed
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        // Altitude: distance above ground (converted to visual altitude)
        document.getElementById('altitude').textContent = Math.max(0, Math.round(-pos.y * VISUAL_SCALE));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'üí• CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          updateProjectiles(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start the loop now that initializeGame() has been invoked from Start button
      console.log('Starting flight simulator...');
      requestAnimationFrame(gameLoop);
      }
      
      // Do not auto-start; wait for Start button click (handled above)
      
    })();
  </script>
</body>
</html>