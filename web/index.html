<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle ‚Ä¢ A: Pitch Up ‚Ä¢ D: Pitch Down ‚Ä¢ Q/E: Zoom ‚Ä¢ Arrows: Roll ‚Ä¢ F: Flip ‚Ä¢ G: Gear ‚Ä¢ Space: Fire ‚Ä¢ C: Physics Debug ‚Ä¢ V: Pixel Debug ‚Ä¢ R: Reset
  </div>

  <!-- Start Screen -->
  <div id="startScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #2F4F4F 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    font-family: 'Arial', sans-serif;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  ">
    <h1 style="font-size: 4rem; margin-bottom: 1rem; text-align: center;">
      Per Ardua ad Astra
    </h1>
    <p style="font-size: 1.5rem; margin-bottom: 3rem; text-align: center; opacity: 0.9;">
      "Through Adversity to the Stars"
    </p>
    <button id="startButton" style="
      font-size: 1.5rem;
      padding: 1rem 3rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      text-shadow: none;
      font-weight: bold;
    " onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='scale(1.1)'" 
       onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='scale(1)'">
      START FLIGHT
    </button>
    <div style="margin-top: 2rem; text-align: center; opacity: 0.7; font-size: 0.9rem;">
      <p>üéÆ Use W/S for throttle, A/D for pitch, arrows for roll</p>
      <p>üî´ Press SPACE to fire wing guns with tracers and casings</p>
      <p>‚úàÔ∏è Realistic flight physics with altitude effects above 5000m</p>
    </div>
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';
      
      // Game state
      let gameStarted = false;
      
      // Start screen functionality
      document.getElementById('startButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('üöÄ Starting game...');
        
        try {
          // Initialize audio system after user interaction
          initAudio();
          
          // Resume audio context if needed
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('üîä Audio context resumed');
            });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Audio setup failed, continuing without sound:', error);
        }
        
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        initializeGame();
      });
      
      // Initialize game function
      function initializeGame() {

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants - Physics world scaling for higher speeds (more reasonable scaling)
      const PHYSICS_SCALE = 0.5; // Physics objects are 2x smaller for higher speeds
      const VISUAL_SCALE = 2.0; // Visual rendering compensates with 2x scaling  
      const SCALE = 20 * VISUAL_SCALE; // Base pixels per meter (40 after scaling)
      const WORLD_WIDTH = 4000 * PHYSICS_SCALE; // Physics: 400 units (visually 4000m)
      const WORLD_HEIGHT = 3000 * PHYSICS_SCALE; // Physics: 300 units (visually 3000m)
      const MAP_BOTTOM_ALTITUDE = 300; // Physics: 300 units above ground (visually 600m)
      
      // CRITICAL: Set Planck.js settings BEFORE creating the world
      // This is essential to remove the 240 m/s speed cap
      console.log('üîß Setting Box2D velocity limits BEFORE world creation...');
      
      if (typeof planck !== 'undefined' && planck.Settings) {
        console.log('üìä Original planck.Settings:', { 
          maxTranslation: planck.Settings.maxTranslation, 
          velocityThreshold: planck.Settings.velocityThreshold
        });
        // Set extremely high limits to remove all speed caps
        planck.Settings.maxTranslation = 50.0; // Very high limit
        planck.Settings.velocityThreshold = 50.0; // Increase velocity threshold
        console.log('‚úÖ Updated planck.Settings for unlimited speed');
      }
      
      if (typeof pl !== 'undefined' && pl.Settings) {
        console.log('üìä Original pl.Settings:', { 
          maxTranslation: pl.Settings.maxTranslation,
          velocityThreshold: pl.Settings.velocityThreshold
        });
        // Set extremely high limits
        pl.Settings.maxTranslation = 50.0; // Extremely high
        pl.Settings.velocityThreshold = 50.0; // Remove velocity sleeping
        console.log('‚úÖ Updated pl.Settings:', { 
          maxTranslation: pl.Settings.maxTranslation,
          velocityThreshold: pl.Settings.velocityThreshold
        });
      }
      
      // NOW create the physics world with the updated settings
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        tileableMap: null,
        spitfire: null,
        spitfireInverted: null,
        spitfireGear: null,
        spitfireInvertedGear: null,
        bullet: null,
        tracer: null,
        casing: null,
        ju88: null,
        bf109Left: null,
        bf109Right: null,
        explosion: null,
        loaded: { map: false, tileableMap: false, spitfire: false, spitfireInverted: false, spitfireGear: false, spitfireInvertedGear: false, bullet: false, tracer: false, casing: false, ju88: false, bf109Left: false, bf109Right: false, explosion: false }
      };
      
      // Audio system
      let audioContext = null;
      const sounds = {
        gunfire: null,
        explosion: null,
        hit: null
      };
      
      // Pixel-perfect collision system
      const spritePixelData = new Map();
      
      function extractSpritePixelData(image, name) {
        if (!image || !image.complete || image.naturalWidth === 0) return null;
        
        // Create a temporary canvas to extract pixel data
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = image.naturalWidth;
        tempCanvas.height = image.naturalHeight;
        
        // Draw the image to extract pixel data
        tempCtx.drawImage(image, 0, 0);
        
        try {
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixelData = {
            width: tempCanvas.width,
            height: tempCanvas.height,
            data: imageData.data
          };
          
          spritePixelData.set(name, pixelData);
          console.log(`üéØ Extracted pixel data for ${name}: ${pixelData.width}x${pixelData.height}`);
          return pixelData;
        } catch (error) {
          console.log(`‚ö†Ô∏è Failed to extract pixel data for ${name}:`, error);
          return null;
        }
      }
      
      function checkPixelCollision(projX, projY, enemy) {
        // Get enemy position and rotation
        const pos = enemy.body.getPosition();
        const angle = enemy.body.getAngle();
        
        // Get sprite and its pixel data based on enemy type
        let sprite, pixelData, spriteName;
        if (enemy.type === 'bf109') {
          // Choose correct BF-109 sprite based on facing direction
          if (enemy.facingDirection === 'right') {
            sprite = assets.bf109Right;
            spriteName = 'bf109Right';
          } else {
            sprite = assets.bf109Left;
            spriteName = 'bf109Left';
          }
          pixelData = spritePixelData.get(spriteName);
        } else {
          // Ju-88 bomber
          sprite = assets.ju88;
          spriteName = 'ju88';
          pixelData = spritePixelData.get('ju88');
        }
        
        if (!sprite || !pixelData) {
          // Fallback to distance-based collision if no pixel data
          const distance = Math.sqrt((projX - pos.x) * (projX - pos.x) + (projY - pos.y) * (projY - pos.y));
          return distance < (enemy.type === 'bf109' ? 6 : 15); // Smaller collision for fighters
        }
        
        // Calculate sprite dimensions in world space
        const originalAspectRatio = sprite.naturalWidth / sprite.naturalHeight;
        let baseEnemySize;
        if (enemy.type === 'bf109') {
          baseEnemySize = 16; // Doubled fighter size to match rendering
        } else {
          baseEnemySize = 24; // Larger bombers
        }
        const enemyWidth = baseEnemySize * originalAspectRatio;
        const enemyHeight = baseEnemySize;
        
        // Transform projectile position to local sprite coordinates
        // Account for the sprite transformations: translate, rotate, scale(-1, -1)
        const dx = projX - pos.x;
        const dy = projY - pos.y;
        
        // Reverse rotation (rotate by -angle)
        const cosA = Math.cos(-angle);
        const sinA = Math.sin(-angle);
        const rotatedX = dx * cosA - dy * sinA;
        const rotatedY = dx * sinA + dy * cosA;
        
        // Account for the scale(-1, -1) flip
        const flippedX = -rotatedX;
        const flippedY = -rotatedY;
        
        // Convert from world coordinates to sprite pixel coordinates
        // Sprite is rendered from -enemyWidth/2 to +enemyWidth/2, -enemyHeight/2 to +enemyHeight/2
        const spriteX = (flippedX + enemyWidth / 2) * (pixelData.width / enemyWidth);
        const spriteY = (flippedY + enemyHeight / 2) * (pixelData.height / enemyHeight);
        
        // Check if coordinates are within sprite bounds
        if (spriteX < 0 || spriteX >= pixelData.width || spriteY < 0 || spriteY >= pixelData.height) {
          return false;
        }
        
        // Get pixel at the calculated position
        const pixelIndex = (Math.floor(spriteY) * pixelData.width + Math.floor(spriteX)) * 4;
        const alpha = pixelData.data[pixelIndex + 3]; // Alpha channel
        
        // Consider pixel hit if alpha > threshold (not transparent)
        return alpha > 50; // Threshold for semi-transparent areas
      }
      
      function checkPlayerPixelCollision(projX, projY) {
        // Get player position and rotation
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        
        // Determine which player sprite to use based on current state
        let spriteName, sprite;
        if (game.inverted && game.gearDown) {
          spriteName = 'spitfireInvertedGear';
          sprite = assets.spitfireInvertedGear;
        } else if (game.inverted && !game.gearDown) {
          spriteName = 'spitfireInverted';
          sprite = assets.spitfireInverted;
        } else if (!game.inverted && game.gearDown) {
          spriteName = 'spitfireGear';
          sprite = assets.spitfireGear;
        } else {
          spriteName = 'spitfire';
          sprite = assets.spitfire;
        }
        
        const pixelData = spritePixelData.get(spriteName);
        
        if (!sprite || !pixelData) {
          // Fallback to distance-based collision if no pixel data
          const distance = Math.sqrt((projX - pos.x) * (projX - pos.x) + (projY - pos.y) * (projY - pos.y));
          return distance < 4; // Smaller than enemy aircraft
        }
        
        // Calculate sprite dimensions in world space (same as player rendering)
        const basePlayerSize = 0.4; // Same scale factor as in rendering
        const playerWidth = sprite.naturalWidth * basePlayerSize;
        const playerHeight = sprite.naturalHeight * basePlayerSize;
        
        // Transform projectile position to local sprite coordinates
        const dx = projX - pos.x;
        const dy = projY - pos.y;
        
        // Reverse rotation (rotate by -angle)
        const cosA = Math.cos(-angle);
        const sinA = Math.sin(-angle);
        const rotatedX = dx * cosA - dy * sinA;
        const rotatedY = dx * sinA + dy * cosA;
        
        // Convert from world coordinates to sprite pixel coordinates
        // Player sprite is rendered from -w/2 to +w/2, -h/2 to +h/2
        const spriteX = (rotatedX + playerWidth / 2) * (pixelData.width / playerWidth);
        const spriteY = (rotatedY + playerHeight / 2) * (pixelData.height / playerHeight);
        
        // Check if coordinates are within sprite bounds
        if (spriteX < 0 || spriteX >= pixelData.width || spriteY < 0 || spriteY >= pixelData.height) {
          return false;
        }
        
        // Get pixel at the calculated position
        const pixelIndex = (Math.floor(spriteY) * pixelData.width + Math.floor(spriteX)) * 4;
        const alpha = pixelData.data[pixelIndex + 3]; // Alpha channel
        
        // Consider pixel hit if alpha > threshold (not transparent)
        return alpha > 50; // Threshold for semi-transparent areas
      }

      // Pixel-perfect plane vs plane overlap test
      function checkPlanePlanePixelOverlap(enemy) {
        // Sample a small grid of points around the midpoint between planes
        const playerPos = aircraft.getPosition();
        const enemyPos = enemy.body.getPosition();
        
        // Estimate sprite world sizes
        // Player
        let playerSprite;
        if (game.inverted && game.gearDown) playerSprite = assets.spitfireInvertedGear;
        else if (game.inverted && !game.gearDown) playerSprite = assets.spitfireInverted;
        else if (!game.inverted && game.gearDown) playerSprite = assets.spitfireGear;
        else playerSprite = assets.spitfire;
        const basePlayerSize = 0.4;
        const playerWidth = playerSprite ? playerSprite.naturalWidth * basePlayerSize : 8;
        const playerHeight = playerSprite ? playerSprite.naturalHeight * basePlayerSize : 3;
        
        // Enemy
        let enemySprite;
        if (enemy.type === 'bf109') {
          enemySprite = enemy.facingDirection === 'right' ? assets.bf109Right : assets.bf109Left;
        } else {
          enemySprite = assets.ju88;
        }
        const enemyAspect = enemySprite ? (enemySprite.naturalWidth / Math.max(1, enemySprite.naturalHeight)) : 3;
        const enemyBase = enemy.type === 'bf109' ? 16 : 24;
        const enemyWidth = enemyBase * enemyAspect;
        const enemyHeight = enemyBase;
        
        // Define sampling region around the segment midpoint
        const midX = (playerPos.x + enemyPos.x) / 2;
        const midY = (playerPos.y + enemyPos.y) / 2;
        const sampleHalfW = Math.min(playerWidth, enemyWidth) * 0.6;
        const sampleHalfH = Math.min(playerHeight, enemyHeight) * 0.6;
        
        // Sample a coarse grid (7x7) for overlap
        const samples = 7;
        for (let ix = 0; ix < samples; ix++) {
          for (let iy = 0; iy < samples; iy++) {
            const tx = ix / (samples - 1); // 0..1
            const ty = iy / (samples - 1);
            const wx = midX + (tx - 0.5) * 2 * sampleHalfW;
            const wy = midY + (ty - 0.5) * 2 * sampleHalfH;
            // Both must have opaque pixel at this world point
            if (checkPlayerPixelCollision(wx, wy) && checkPixelCollision(wx, wy, enemy)) {
              return true;
            }
          }
        }
        return false;
      }
      
      // Create audio sounds programmatically
      function createGunfireSound() {
        const duration = 0.1;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Sharp crack sound with rapid decay
          data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 50) * Math.sin(t * 2000 * Math.PI);
        }
        
        return buffer;
      }
      
      function createExplosionSound() {
        const duration = 1.5;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Rumbling explosion with bass
          const noise = Math.random() * 2 - 1;
          const decay = Math.exp(-t * 2);
          const lowFreq = Math.sin(t * 100 * Math.PI) * 0.5;
          const midFreq = Math.sin(t * 500 * Math.PI) * 0.3;
          data[i] = (noise * 0.7 + lowFreq + midFreq) * decay;
        }
        
        return buffer;
      }
      
      function createHitSound() {
        const duration = 0.2;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Sharp metallic impact
          data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * Math.sin(t * 1500 * Math.PI);
        }
        
        return buffer;
      }
      
      function initAudio() {
        try {
          // Create audio context on first call
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('üîä Audio context created');
          }
          
          sounds.gunfire = createGunfireSound();
          sounds.explosion = createExplosionSound();
          sounds.hit = createHitSound();
          console.log('üîä Audio system initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Audio initialization failed:', error);
        }
      }
      
      function playSound(soundBuffer, volume = 1.0) {
        if (!soundBuffer || !audioContext) return;
        
        try {
          const source = audioContext.createBufferSource();
          const gainNode = audioContext.createGain();
          
          source.buffer = soundBuffer;
          gainNode.gain.value = volume;
          
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          source.start();
        } catch (error) {
          console.log('‚ö†Ô∏è Sound playback failed:', error);
        }
      }
      
      async function loadAssets() {
        console.log('üéÆ Starting asset loading...');
        console.log('üìç Current location:', window.location.href);
        console.log('üìÇ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        console.log('üõ©Ô∏è Loading Ju-88 sprite from:', '../assets/sprites/aircraft/enemies/ju-88.png');
        console.log('üéØ Loading Tracer sprite from:', '../assets/sprites/effects/tracer_round.png');
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          tileableMap: [
            '../assets/sprites/environment/tileable map.png',
            './assets/sprites/environment/tileable map.png',
            '/assets/sprites/environment/tileable map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            './assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            '/assets/sprites/aircraft/player/Spitfire facing right with gear.png'
          ],
          spitfireInverted: [
            '../assets/sprites/aircraft/player/spitfire upside down.png',
            './assets/sprites/aircraft/player/spitfire upside down.png',
            '/assets/sprites/aircraft/player/spitfire upside down.png'
          ],
          spitfireGear: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ],
          spitfireInvertedGear: [
            '../assets/sprites/aircraft/player/spitfire upside down with gear.png',
            './assets/sprites/aircraft/player/spitfire upside down with gear.png',
            '/assets/sprites/aircraft/player/spitfire upside down with gear.png'
          ],
          bullet: [
            '../assets/sprites/effects/bullet.png',
            './assets/sprites/effects/bullet.png',
            '/assets/sprites/effects/bullet.png'
          ],
          tracer: [
            '../assets/sprites/effects/tracer_round.png',
            './assets/sprites/effects/tracer_round.png',
            '/assets/sprites/effects/tracer_round.png'
          ],
          casing: [
            '../assets/sprites/effects/casing.png',
            './assets/sprites/effects/casing.png',
            '/assets/sprites/effects/casing.png'
          ],
          ju88: [
            '../assets/sprites/aircraft/enemies/ju-88.png',
            './assets/sprites/aircraft/enemies/ju-88.png',
            '/assets/sprites/aircraft/enemies/ju-88.png'
          ],
          bf109Left: [
            '../assets/sprites/aircraft/enemies/bf-109 facing left.png',
            './assets/sprites/aircraft/enemies/bf-109 facing left.png',
            '/assets/sprites/aircraft/enemies/bf-109 facing left.png'
          ],
          bf109Right: [
            '../assets/sprites/aircraft/enemies/bf-109 facing right.png',
            './assets/sprites/aircraft/enemies/bf-109 facing right.png',
            '/assets/sprites/aircraft/enemies/bf-109 facing right.png'
          ],
          explosion: [
            '../assets/sprites/effects/explosion.png',
            './assets/sprites/effects/explosion.png',
            '/assets/sprites/effects/explosion.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`üì∑ Trying ${name} from: ${currentPath}`);
              console.log(`üîó Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`‚úÖ ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`‚ùå ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load all assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('tileableMap', assetPaths.tileableMap),
            loadImage('spitfire', assetPaths.spitfire),
            loadImage('spitfireInverted', assetPaths.spitfireInverted),
            loadImage('spitfireGear', assetPaths.spitfireGear),
            loadImage('spitfireInvertedGear', assetPaths.spitfireInvertedGear),
                      loadImage('bullet', assetPaths.bullet),
          loadImage('tracer', assetPaths.tracer),
          loadImage('casing', assetPaths.casing),
          loadImage('ju88', assetPaths.ju88),
            loadImage('bf109Left', assetPaths.bf109Left),
            loadImage('bf109Right', assetPaths.bf109Right),
          loadImage('explosion', assetPaths.explosion)
        ]);
          console.log('üéâ All assets loaded successfully!');
          console.log('üìä Final asset load status:', assets.loaded);
          
          // Specifically check gear sprites
          console.log('üõ¨ Gear sprite status:', {
            spitfireGear: { loaded: assets.loaded.spitfireGear, hasImage: !!assets.spitfireGear },
            spitfireInvertedGear: { loaded: assets.loaded.spitfireInvertedGear, hasImage: !!assets.spitfireInvertedGear }
          });
          console.log('üî´ Ordnance asset status:', {
            bullet: { loaded: assets.loaded.bullet, hasImage: !!assets.bullet },
            tracer: { loaded: assets.loaded.tracer, hasImage: !!assets.tracer },
            casing: { loaded: assets.loaded.casing, hasImage: !!assets.casing }
          });
          console.log('‚úàÔ∏è Enemy asset status:', {
            ju88: { loaded: assets.loaded.ju88, hasImage: !!assets.ju88, src: assets.ju88?.src },
            explosion: { loaded: assets.loaded.explosion, hasImage: !!assets.explosion }
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è Some assets failed to load:', error.message);
          console.log('üéÆ Game will continue with fallback graphics');
          console.log('üìä Asset load status after error:', assets.loaded);
        }
        
        // Initialize audio system (moved to user interaction)
        // initAudio();
        
        // Extract pixel data for all aircraft sprites
        if (assets.loaded.ju88 && assets.ju88) {
          extractSpritePixelData(assets.ju88, 'ju88');
        }
        if (assets.loaded.bf109Left && assets.bf109Left) {
          extractSpritePixelData(assets.bf109Left, 'bf109Left');
        }
        if (assets.loaded.bf109Right && assets.bf109Right) {
          extractSpritePixelData(assets.bf109Right, 'bf109Right');
        }
        if (assets.loaded.spitfire && assets.spitfire) {
          extractSpritePixelData(assets.spitfire, 'spitfire');
        }
        if (assets.loaded.spitfireInverted && assets.spitfireInverted) {
          extractSpritePixelData(assets.spitfireInverted, 'spitfireInverted');
        }
        if (assets.loaded.spitfireGear && assets.spitfireGear) {
          extractSpritePixelData(assets.spitfireGear, 'spitfireGear');
        }
        if (assets.loaded.spitfireInvertedGear && assets.spitfireInvertedGear) {
          extractSpritePixelData(assets.spitfireInvertedGear, 'spitfireInvertedGear');
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // Debug: Check asset loading status immediately
      console.log('üîç Assets object at startup:', assets);
      console.log('üîç Asset loaded status:', assets.loaded);
      
      // Check asset loading status after a delay
      setTimeout(() => {
        console.log('üìä Asset status after 2 seconds:', {
          loaded: assets.loaded,
          hasImages: {
            map: !!assets.map,
            spitfire: !!assets.spitfire,
            ju88: !!assets.ju88
          }
        });
      }, 2000);
      
      // Debug: Log initial game state
      setTimeout(() => {
        console.log('üöÄ Initial game state at startup:', {
          inverted: game.inverted,
          gearDown: game.gearDown,
          expectedSprite: 'Should be normal Spitfire facing right (no gear)'
        });
      }, 1000);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.05, maxZoom: 9.0 }, // Much further zoom out (0.05 instead of 0.2)
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        showPixelCollision: false,
        crashed: false,
        playerHealth: 5,
        playerMaxHealth: 5,
        inverted: false,
        gearDown: false,
        onGround: false, // Track if aircraft is on ground
        groundSpeed: 0, // Track ground speed for takeoff/landing
        projectiles: [], // bullets and tracers
        casings: [], // ejected shells
        enemies: [], // enemy aircraft
        explosions: [], // explosion effects
        enemyProjectiles: [] // enemy bullets
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        game.keys.add(key);
        console.log('üéØ Key pressed:', key); // Debug key presses
        
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c','v','f','g',' '].includes(key)) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (key === 'c') {
          game.showCollision = !game.showCollision;
          console.log('üîç Physics collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
        
        // Toggle pixel collision debug view
        if (key === 'v') {
          game.showPixelCollision = !game.showPixelCollision;
          console.log('üéØ Pixel collision debug:', game.showPixelCollision ? 'ON' : 'OFF');
        }
        
        // Toggle inverted flight mode
        if (key === 'f') {
          const oldInverted = game.inverted;
          game.inverted = !game.inverted;
          console.log('üîÑ Flight mode changed:', oldInverted ? 'INVERTED' : 'NORMAL', '‚Üí', game.inverted ? 'INVERTED' : 'NORMAL');
          console.log('üîÑ F key - Game state after flip:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        
        // Toggle landing gear
        if (key === 'g') {
          const oldGear = game.gearDown;
          game.gearDown = !game.gearDown;
          console.log('üõ¨ Gear changed:', oldGear ? 'DOWN' : 'UP', '‚Üí', game.gearDown ? 'DOWN' : 'UP');
          console.log('üõ¨ G key - Game state after gear toggle:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        // Fire guns (space) - now handled in physics update for continuous fire
        if (key === ' ' || e.code === 'Space') {
          console.log('üéØ SPACE pressed - continuous fire mode');
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn above ground within main map (scaled physics)
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, -300), // 300 physics units above ground (visually 600m)
        angle: 0,
        linearDamping: 0.0, // Removed damping to eliminate speed cap
        angularDamping: 8.0 // Very high damping for instant stop when controls released (works with force-based controls)
      });
      
      aircraft.createFixture({
        shape: pl.Box(4, 1.25), // 8m x 2.5m aircraft (scaled down 2x)
        density: 20, // kg/m¬≤
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create infinite ground collision at y=0 (physical ground - scaled)
        const groundLevel = 0; // ground at 0 altitude
        const halfThickness = 0.25; // scaled down collision thickness (2x scaling)
        const infiniteWidth = 50000; // Very wide ground - scaled down (2x scaling)
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel) // center at y=0
        });
        
        groundBody.createFixture({
          shape: pl.Box(infiniteWidth / 2, halfThickness),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel,
          width: infiniteWidth,
          height: halfThickness * 2,
          isMainGround: true
        });
        
        console.log(`üü¢ Created infinite ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // Create initial enemy aircraft
      createInitialEnemies();
      
      // =============================================================================
      // GUNS AND PROJECTILES
      // =============================================================================
      
      // Initialize external projectiles module (after aircraft/world exist)
      setTimeout(() => {
        if (window.initProjectiles) {
          window.initProjectiles();
        }
      }, 0);
        
        // =============================================================================
        // ENEMY SYSTEM
        // =============================================================================
        
        // Enemy spawning system variables (initialize explicitly)
        var lastSpawnTime = 0;
        var spawnInterval = 20000; // Spawn new formation every 20 seconds (reduce clustering)
        var formationCounter = 0;
        
        function createInitialEnemies() {
          console.log('‚úàÔ∏è Creating initial enemy aircraft formations...');
          // Spawn only one initial formation to mitigate large crowds at start
          spawnEnemyFormation();
          // Delay next spawn by setting lastSpawnTime to now
          lastSpawnTime = performance.now();
        }
        
        function spawnEnemyFormation() {
          console.log('‚úàÔ∏è Spawning new enemy formation with escorts...');
          
          const bomberAltitude = -500; // 1000m above ground in physics units (500 * VISUAL_SCALE = 1000m)
          const vSpacing = 100; // 200m between aircraft in V formation
          const vOffset = 50; // 100m vertical offset for V wings
          
          // Spawn from the right side of the map, far ahead of player
          const spawnX = 2000; // 4000m to the right
          
          // Add some random altitude variation
          const altitudeVariation = (Math.random() - 0.5) * 200; // ¬±200m variation
          const baseAltitude = bomberAltitude + altitudeVariation;
          
          // Create V formation of 3 ju-88 bombers
          for (let pos = 0; pos < 3; pos++) {
            let x, y;
            
            if (pos === 0) {
              // Lead aircraft (center of V)
              x = spawnX;
              y = baseAltitude;
            } else if (pos === 1) {
              // Left wing (relative to their flight direction - behind and below)
              x = spawnX + vSpacing;
              y = baseAltitude - vOffset;
            } else {
              // Right wing (relative to their flight direction - behind and above)
              x = spawnX + vSpacing;
              y = baseAltitude + vOffset;
            }
            
            // Create Box2D body for enemy
            const enemyBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(x, y),
              angle: Math.PI, // Face left (180 degrees)
              linearDamping: 0.02,
              angularDamping: 2.0
            });
            
            enemyBody.createFixture({
              shape: pl.Box(12, 8), // Larger Ju-88 bomber (24m x 16m - 2x larger to match visual size)
              density: 25,
              friction: 0.3,
              restitution: 0.1
            });
            
            // Enemy data with reduced health for faster damage
            const enemy = {
              body: enemyBody,
              health: 5, // Reduced from 10 for faster damage
              maxHealth: 5,
              targetSpeed: 80,
              destroyed: false,
              thrustReduction: 0, // Progressive thrust loss (0-1)
              liftReduction: 0, // Progressive lift loss (0-1)
              type: 'ju88',
              formation: formationCounter,
              position: pos,
              spawnTime: performance.now(),
              targetAltitude: y, // Store initial altitude to maintain level flight
              smoking: false, // Visual damage indicator
              onFire: false, // Critical damage indicator
                pitchingDown: false, // Crash state
                // Defensive gunner
                hasGunner: true,
                gunnerLastShotTime: 0,
                gunnerBurstRemaining: 0,
                gunnerBurstSize: 5,
                gunnerShotInterval: 150, // Slower fire rate than fighters
                gunnerBurstCooldown: 2000, // 2 seconds between bursts
                gunnerLastBurstTime: 0,
                gunnerRange: 100 // 200m defensive range
            };
            
            // Store reference for collision detection
            enemyBody.setUserData({ type: 'enemy', enemy: enemy });
            
            game.enemies.push(enemy);
            console.log(`‚úàÔ∏è Spawned Ju-88 bomber at (${x}, ${y}) - Formation ${formationCounter}, Position ${pos}`);
          }
          
          // Add bf-109 escort fighters
          const escortAltitude = baseAltitude - 25; // Fighters fly slightly lower
          const escortOffset = 150; // Distance from bombers
          
          // Create exactly 2 bf-109 escorts per formation
          const numEscorts = 2; // Exactly 2 escorts as requested
          for (let i = 0; i < numEscorts; i++) {
            // Position escorts around the bomber formation
            const escortX = spawnX + (i % 2 === 0 ? -escortOffset : escortOffset) + (Math.random() - 0.5) * 50;
            const escortY = escortAltitude + (Math.floor(i / 2) * 30) + (Math.random() - 0.5) * 20;
            
            // Create Box2D body for escort fighter
            const escortBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(escortX, escortY),
              angle: Math.PI, // Face left initially
              linearDamping: 0.02,
              angularDamping: 2.0
            });
            
            escortBody.createFixture({
              shape: pl.Box(6, 2), // Doubled fighter size (12m x 4m)
              density: 15,
              friction: 0.3,
              restitution: 0.1
            });
            
            // BF-109 escort data with enhanced AI
            const escort = {
              body: escortBody,
              health: 3, // Lower health than bombers
              maxHealth: 3,
              targetSpeed: 120, // Faster than bombers
              destroyed: false,
              thrustReduction: 0,
              liftReduction: 0,
              type: 'bf109',
              formation: formationCounter,
              position: i,
              spawnTime: performance.now(),
              targetAltitude: escortY,
              smoking: false,
              onFire: false,
              pitchingDown: false,
              // Enhanced Combat AI state machine
              aiState: 'patrol', // patrol, engage, attack, evade, boom_zoom, disengage
              previousState: 'patrol',
              stateTimer: 0,
              target: null, // Target for attack
              lastShotTime: 0,
              burstShotsRemaining: 0,
              burstCooldown: 0,
              shotInterval: 100, // 100ms between shots in a burst
              burstSize: 3 + Math.floor(Math.random() * 3), // 3-5 shot bursts
              burstCooldownTime: 1000 + Math.random() * 1000, // 1-2s between bursts
              facingDirection: 'right', // Track which sprite to use (right sprite when flying left)
              // Advanced AI parameters
              skillLevel: Math.random() > 0.8 ? 'ace' : 'regular', // 20% chance of ace pilot
              aggressiveness: 0.5 + Math.random() * 0.5, // 0.5-1.0 aggression factor
              reactionTime: 200 + Math.random() * 300, // 200-500ms reaction delay
              lastReactionUpdate: 0,
              // Maneuver tracking
              currentManeuver: null,
              maneuverTimer: 0,
              preferredEngagementRange: 50 + Math.random() * 50, // 100-200m preferred combat range
              // Energy management
              energyState: 'neutral', // low, neutral, high
              lastEnergyCheck: 0,
              // Evasion tracking
              timeSinceLastHit: 0,
              consecutiveHits: 0,
              isEvading: false,
              evasionDirection: 1, // 1 or -1 for roll direction
              // Tactical awareness
              lastKnownPlayerPos: null,
              predictedPlayerPos: null,
              leadCalculation: null
            };
            
            // Store reference for collision detection
            escortBody.setUserData({ type: 'enemy', enemy: escort });
            
            game.enemies.push(escort);
            console.log(`üõ©Ô∏è Spawned BF-109 escort at (${escortX}, ${escortY}) - Formation ${formationCounter}, Position ${i}`);
          }
          
          formationCounter++;
        }
        
        function updateEnemySpawning() {
          const now = performance.now();
          if (now - lastSpawnTime > spawnInterval) {
            spawnEnemyFormation();
            lastSpawnTime = now;
          }
          
          // Clean up enemies that are too far from the player or have crashed
          const playerPos = aircraft.getPosition();
          const maxDistance = 5000; // 10000m from player (really far)
          
          for (let i = game.enemies.length - 1; i >= 0; i--) {
            const enemy = game.enemies[i];
              const pos = enemy.body.getPosition();
            
            // Remove if too far from player
              const distance = Math.sqrt(
                (pos.x - playerPos.x) * (pos.x - playerPos.x) + 
                (pos.y - playerPos.y) * (pos.y - playerPos.y)
              );
              
            // Remove if crashed into ground or too far away
            const hasHitGround = pos.y > 5; // Below ground level
            const tooFarAway = distance > maxDistance;
            
            if (!enemy.destroyed && tooFarAway) {
                console.log(`üóëÔ∏è Removing enemy too far from player (distance: ${distance * VISUAL_SCALE}m)`);
                world.destroyBody(enemy.body);
                game.enemies.splice(i, 1);
            } else if (enemy.destroyed && hasHitGround) {
              console.log(`üí• Removing crashed enemy`);
              world.destroyBody(enemy.body);
              game.enemies.splice(i, 1);
              
              // Create ground explosion
              game.explosions.push({
                x: pos.x,
                y: 0, // Ground level
                time: 0,
                duration: 1.5,
                size: 25,
                type: 'destruction'
              });
              playSound(sounds.explosion, 0.6);
            }
          }
        }
        
        // Function to make enemy aircraft fire their weapons
        function fireEnemyWeapon(enemy) {
          const pos = enemy.body.getPosition();
          const vel = enemy.body.getLinearVelocity();
          const angle = enemy.body.getAngle();
          
          // Define gun mounts (Ju-88 has defensive turrets)
          const gunMounts = [];
          if (enemy.type === 'ju88') {
            gunMounts.push({ offset: { x: 2.0, y: 0 }, arc: Math.PI / 3 });          // Front
            gunMounts.push({ offset: { x: -0.5, y: -1.0 }, arc: Math.PI / 2 });      // Top
            gunMounts.push({ offset: { x: -2.0, y: 0 }, arc: Math.PI / 2 });         // Rear
          } else {
            gunMounts.push({ offset: { x: 2.0, y: 0 }, arc: Math.PI / 6 });          // Fighter forward guns
          }
          
          // Calculate bullet velocity with lead prediction
          const playerPos = aircraft.getPosition();
          const playerVel = aircraft.getLinearVelocity();
          const distance = Math.sqrt(
            (playerPos.x - pos.x) * (playerPos.x - pos.x) + 
            (playerPos.y - pos.y) * (playerPos.y - pos.y)
          );
          
          // Lead calculation for ace pilots
          let leadFactor = 0;
          if (enemy.skillLevel === 'ace') {
            const bulletSpeed = 400; // m/s
            const timeToTarget = distance / bulletSpeed;
            leadFactor = timeToTarget * 0.5; // Aces lead shots better
          }
          
          // Calculate firing angle with lead
          const predictedX = playerPos.x + playerVel.x * leadFactor;
          const predictedY = playerPos.y + playerVel.y * leadFactor;
          const firingAngle = Math.atan2(predictedY - pos.y, predictedX - pos.x);
          
          // Add some spread/inaccuracy (less for aces)
          const spread = enemy.skillLevel === 'ace' ? 0.02 : 0.05;
          const actualAngle = firingAngle + (Math.random() - 0.5) * spread;
          
          // Muzzle velocity
          const muzzleVelocity = 400;
          const bulletVel = {
            x: vel.x + Math.cos(actualAngle) * muzzleVelocity,
            y: vel.y + Math.sin(actualAngle) * muzzleVelocity
          };
          
          if (!game.enemyProjectiles) game.enemyProjectiles = [];
          
          gunMounts.forEach(() => { /* placeholder to keep structure if no mount loop below */ });
          
          gunMounts.forEach((mount) => {
            // Mount world position
            const gunPos = {
              x: pos.x + Math.cos(angle) * mount.offset.x - Math.sin(angle) * mount.offset.y,
              y: pos.y + Math.sin(angle) * mount.offset.x + Math.cos(angle) * mount.offset.y
            };
            // Angle to player
            const toPlayerAngle = Math.atan2(playerPos.y - gunPos.y, playerPos.x - gunPos.x);
            // Check arc limits
            let rel = toPlayerAngle - angle;
            while (rel > Math.PI) rel -= 2 * Math.PI;
            while (rel < -Math.PI) rel += 2 * Math.PI;
            if (Math.abs(rel) > mount.arc) return;
            
            // Random defensive fire when player is near: ignore precise lead
            const baseAngle = Math.atan2(playerPos.y - gunPos.y, playerPos.x - gunPos.x);
            const randomSpread = (Math.random() - 0.5) * 0.6; // Wide spread
            let firingAngle = baseAngle + randomSpread;
            
            // Avoid friendly fire
            const friendlyNear = game.enemies.some(other => {
              if (other === enemy || other.destroyed) return false;
              const o = other.body.getPosition();
              const along = (o.x - gunPos.x) * Math.cos(firingAngle) + (o.y - gunPos.y) * Math.sin(firingAngle);
              if (along <= 0 || along > 150) return false;
              const perp = Math.abs(-(o.x - gunPos.x) * Math.sin(firingAngle) + (o.y - gunPos.y) * Math.cos(firingAngle));
              return perp < 10;
            });
            if (friendlyNear) return;
            
            // Spread
            const spread = 0.15; // Additional inaccuracy
            const actualAngle = firingAngle + (Math.random() - 0.5) * spread;
            const muzzleVelocity = 350;
            const bulletVel = {
              x: vel.x + Math.cos(actualAngle) * muzzleVelocity,
              y: vel.y + Math.sin(actualAngle) * muzzleVelocity
            };
            
            enemy._shotIndex = (enemy._shotIndex || 0) + 1;
            const isTracer = (enemy._shotIndex % 2 === 0);
            
            game.enemyProjectiles.push({
              x: gunPos.x,
              y: gunPos.y,
              vx: bulletVel.x,
              vy: bulletVel.y,
              type: isTracer ? 'tracer' : 'bullet',
              life: 3.0,
              initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y),
              owner: enemy
            });
          });
          
          // Play enemy gunfire sound (quieter than player)
          if (sounds.gunfire) {
            playSound(sounds.gunfire, 0.15);
          }
        }
        
        function updateEnemies(dt) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed && !enemy.pitchingDown) return; // Allow crashing aircraft to continue updating
            
            const pos = enemy.body.getPosition();
            const vel = enemy.body.getLinearVelocity();
            const angle = enemy.body.getAngle();
            const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);

            // Heavily damaged BF-109 spin prevention
            const bf109Damaged = (enemy.type === 'bf109') && (enemy.onFire || enemy.liftReduction > 0.5 || enemy.thrustReduction > 0.6 || enemy.health <= 1);
            if (bf109Damaged) {
              if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(10.0);
              const w = enemy.body.getAngularVelocity();
              const maxW = 0.8;
              const clamped = Math.max(-maxW, Math.min(maxW, w));
              enemy.body.setAngularVelocity(clamped * 0.85);
              // Keep a small forward force to avoid rotating about a point
              const forwardForce = Math.max(4000, (1 - (enemy.thrustReduction || 0)) * 12000);
              enemy.body.applyForceToCenter(pl.Vec2(Math.cos(angle) * forwardForce, Math.sin(angle) * forwardForce), true);
            }
            
            // Enhanced AI behavior for BF-109 fighters
            if (enemy.type === 'bf109') {
              const playerPos = aircraft.getPosition();
              const playerVel = aircraft.getLinearVelocity();
              const distanceToPlayer = Math.sqrt(
                (pos.x - playerPos.x) * (pos.x - playerPos.x) + 
                (pos.y - playerPos.y) * (pos.y - playerPos.y)
              );
              
              // Update reaction timer
              const now = performance.now();
              enemy.stateTimer += dt;
              enemy.timeSinceLastHit += dt;
              
              // Energy state assessment
              if (now - enemy.lastEnergyCheck > 1000) {
                const altitude = -pos.y * VISUAL_SCALE;
                const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y) * VISUAL_SCALE;
                const totalEnergy = altitude + (speed * speed) / (2 * 9.81);
                
                if (totalEnergy < 500) enemy.energyState = 'low';
                else if (totalEnergy > 1500) enemy.energyState = 'high';
                else enemy.energyState = 'neutral';
                
                enemy.lastEnergyCheck = now;
              }
              
              // Check for coordinated attacks with other fighters
              let nearbyAllies = [];
              if (enemy.aiState === 'engage' || enemy.aiState === 'attack') {
                nearbyAllies = game.enemies.filter(other => 
                  other !== enemy && 
                  other.type === 'bf109' && 
                  !other.destroyed &&
                  Math.sqrt((other.body.getPosition().x - pos.x) ** 2 + 
                           (other.body.getPosition().y - pos.y) ** 2) < 100
                );
              }
              
              // State machine transitions
              switch(enemy.aiState) {
                case 'patrol':
                  // Patrol: Stay with formation, scan for threats
                  if (distanceToPlayer < 200) { // 400m detection range
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                    enemy.target = aircraft;
                    
                    // Coordinate attack if allies nearby
                    if (nearbyAllies.length > 0) {
                      // One attacks from above, one from below
                      const attackFromAbove = nearbyAllies.filter(a => a.aiState !== 'attack').length % 2 === 0;
                      enemy.preferredEngagementRange = attackFromAbove ? 75 : 50;
                      enemy.targetAltitude = playerPos.y + (attackFromAbove ? -50 : 50);
                      console.log(`üéØ ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 engaging (coordinated ${attackFromAbove ? 'high' : 'low'})!`);
                    } else {
                      console.log(`üéØ ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 engaging!`);
                    }
                  }
                  enemy.targetSpeed = 100;
                  enemy.facingDirection = 'right'; // Flying left means showing right-facing sprite
                  break;
                  
                case 'engage':
                  // Engage: Position for attack
                  if (distanceToPlayer > 300) {
                    enemy.aiState = 'patrol';
                    enemy.stateTimer = 0;
                    console.log('‚úàÔ∏è BF-109 disengaging - target too far');
                  } else if (distanceToPlayer < enemy.preferredEngagementRange && enemy.stateTimer > enemy.reactionTime / 1000) {
                    // Check if we have a good attack angle
                    const angleToPlayer = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                const currentAngle = enemy.body.getAngle();
                    let angleDiff = Math.abs(angleToPlayer - currentAngle);
                    while (angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - 2 * Math.PI);
                    
                    // Coordinate timing with allies
                    let shouldAttack = angleDiff < Math.PI / 6; // Within 30 degrees
                    if (shouldAttack && nearbyAllies.length > 0) {
                      // Stagger attacks - don't all attack at once
                      const attackingAllies = nearbyAllies.filter(a => a.aiState === 'attack');
                      if (attackingAllies.length > 0 && enemy.skillLevel !== 'ace') {
                        shouldAttack = false; // Wait for ally to finish unless we're an ace
                      }
                    }
                    
                    if (shouldAttack) {
                      enemy.aiState = 'attack';
                      enemy.stateTimer = 0;
                      enemy.burstShotsRemaining = enemy.burstSize;
                      console.log(`üî´ ${nearbyAllies.length > 0 ? 'ü§ù Coordinated' : ''} BF-109 has firing solution!`);
                    }
                  }
                  
                  // Calculate intercept course with lead
                  const timeToIntercept = distanceToPlayer / 150; // Rough estimate
                  const predictedX = playerPos.x + playerVel.x * timeToIntercept * 0.3; // Partial lead
                  const predictedY = playerPos.y + playerVel.y * timeToIntercept * 0.3;
                  enemy.predictedPlayerPos = { x: predictedX, y: predictedY };
                  
                  const angleToIntercept = Math.atan2(predictedY - pos.y, predictedX - pos.x);
                  const currentAngle = enemy.body.getAngle();
                  let angleDiff = angleToIntercept - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                  // Ace pilots turn faster
                  const turnRate = enemy.skillLevel === 'ace' ? 30000 : 20000;
                  enemy.body.applyTorque(angleDiff * turnRate, true);
                  enemy.facingDirection = Math.cos(angleToIntercept) < 0 ? 'right' : 'left';
                  enemy.targetSpeed = 140;
                  break;
                  
                case 'attack':
                  // Attack: Fire weapons at target
                  if (distanceToPlayer > enemy.preferredEngagementRange * 2 || enemy.burstShotsRemaining <= 0) {
                    // Exit attack, decide next action
                    if (enemy.energyState === 'low' || enemy.consecutiveHits > 2) {
                      enemy.aiState = 'evade';
                      enemy.evasionDirection = Math.random() > 0.5 ? 1 : -1;
                    } else if (enemy.energyState === 'high' && enemy.skillLevel === 'ace') {
                      enemy.aiState = 'boom_zoom';
                    } else {
                      enemy.aiState = 'engage';
                    }
                    enemy.stateTimer = 0;
                    enemy.burstCooldown = enemy.burstCooldownTime;
                  }
                  
                  // Fire weapons during attack
                  if (enemy.burstShotsRemaining > 0 && now - enemy.lastShotTime > enemy.shotInterval) {
                    fireEnemyWeapon(enemy);
                    enemy.burstShotsRemaining--;
                    enemy.lastShotTime = now;
                  }
                  
                  // Continue tracking target
                  const attackAngle = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                  const currAngle = enemy.body.getAngle();
                  let aDiff = attackAngle - currAngle;
                  while (aDiff > Math.PI) aDiff -= 2 * Math.PI;
                  while (aDiff < -Math.PI) aDiff += 2 * Math.PI;
                  
                  enemy.body.applyTorque(aDiff * 25000, true);
                  enemy.facingDirection = Math.cos(attackAngle) < 0 ? 'right' : 'left';
                  enemy.targetSpeed = 160; // Full speed during attack
                  break;
                  
                case 'evade':
                  // Evade: Defensive maneuvers
                  if (enemy.stateTimer > 2) { // Evade for 2 seconds
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                    enemy.isEvading = false;
                    enemy.consecutiveHits = 0;
                  }
                  
                  // Barrel roll evasion
                  const rollAngle = angle + enemy.evasionDirection * Math.sin(enemy.stateTimer * 10) * 0.5;
                  enemy.body.setAngle(rollAngle);
                  
                  // Dive or climb based on energy state
                  if (enemy.energyState === 'high') {
                    enemy.targetAltitude = pos.y + 50; // Dive
                    enemy.targetSpeed = 180;
              } else {
                    enemy.targetAltitude = pos.y - 30; // Gentle climb
                    enemy.targetSpeed = 90;
                  }
                  break;
                  
                case 'boom_zoom':
                  // Boom and Zoom: High speed attack from altitude
                  if (enemy.stateTimer < 1.5) {
                    // Climb phase
                    enemy.targetAltitude = pos.y - 100;
                    enemy.targetSpeed = 100;
                  } else if (enemy.stateTimer < 3) {
                    // Dive attack phase
                    const diveAngle = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                    const cAngle = enemy.body.getAngle();
                    let dDiff = diveAngle - cAngle;
                    while (dDiff > Math.PI) dDiff -= 2 * Math.PI;
                    while (dDiff < -Math.PI) dDiff += 2 * Math.PI;
                    
                    enemy.body.applyTorque(dDiff * 30000, true);
                    enemy.targetSpeed = 200; // Maximum speed
                    enemy.targetAltitude = playerPos.y;
                    
                    // Fire if in range
                    if (distanceToPlayer < 75 && Math.abs(dDiff) < Math.PI / 8) {
                      if (now - enemy.lastShotTime > enemy.shotInterval) {
                        fireEnemyWeapon(enemy);
                        enemy.lastShotTime = now;
                      }
                    }
                  } else {
                    // Exit boom and zoom
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                  }
                  enemy.facingDirection = Math.cos(angle) < 0 ? 'right' : 'left';
                  break;
                  
                case 'disengage':
                  // Disengage: Break off and retreat
                enemy.targetSpeed = 120;
                  enemy.targetAltitude = pos.y - 50; // Climb away
                  const escapeAngle = Math.atan2(pos.y - playerPos.y, pos.x - playerPos.x);
                  enemy.body.setAngle(escapeAngle);
                  enemy.facingDirection = Math.cos(escapeAngle) < 0 ? 'right' : 'left';
                  
                  if (distanceToPlayer > 400 || enemy.stateTimer > 5) {
                    enemy.aiState = 'patrol';
                    enemy.stateTimer = 0;
                  }
                  break;
                  
                default:
                  // Fallback to patrol if unknown state
                  enemy.aiState = 'patrol';
                  break;
              }
              
              // Update burst cooldown
              if (enemy.burstCooldown > 0) {
                enemy.burstCooldown -= dt * 1000;
              }
              
              // Ace pilot bonuses
              if (enemy.skillLevel === 'ace') {
                enemy.targetSpeed *= 1.15; // 15% speed bonus
                // Aces also get better turn rates and reaction times (already implemented above)
              }
            } else if (enemy.type === 'ju88' && enemy.hasGunner && !enemy.destroyed) {
              // Ju-88 bomber defensive gunner behavior (random defensive fire)
              const playerPos = aircraft.getPosition();
              const distanceToPlayer = Math.sqrt((pos.x - playerPos.x) ** 2 + (pos.y - playerPos.y) ** 2);
              const now = performance.now();

              // Stop defensive fire when heavily damaged
              const heavilyDamaged = enemy.onFire || (enemy.health / enemy.maxHealth) <= 0.4 || enemy.liftReduction > 0.5;
              if (heavilyDamaged) {
                enemy.gunnerBurstRemaining = 0;
                return;
              }

              if (distanceToPlayer < enemy.gunnerRange) {
                // Fixed 5 rounds per second
                enemy.gunnerShotInterval = 200;
                // Use multiple mounts with random spread
                const mounts = [
                  { offset: { x: 2.0, y: 0 }, arc: Math.PI / 3 },       // Front
                  { offset: { x: -0.5, y: -1.0 }, arc: Math.PI / 2 },   // Top
                  { offset: { x: -2.0, y: 0 }, arc: Math.PI / 2 }       // Rear
                ];

                // Fire one round per interval from a random mount
                if (now - enemy.gunnerLastShotTime > enemy.gunnerShotInterval) {
                  const mount = mounts[Math.floor(Math.random() * mounts.length)];
                  const bomberAngle = enemy.body.getAngle();
                  const gunPos = {
                    x: pos.x + Math.cos(bomberAngle) * mount.offset.x - Math.sin(bomberAngle) * mount.offset.y,
                    y: pos.y + Math.sin(bomberAngle) * mount.offset.x + Math.cos(bomberAngle) * mount.offset.y
                  };
                  // Random firing direction within mount arc
                  const randomRel = (Math.random() - 0.5) * 2 * mount.arc;
                  const firingAngle = bomberAngle + randomRel;

                  // Avoid friendly fire corridor
                  const friendlyNear = game.enemies.some(other => {
                    if (other === enemy || other.destroyed) return false;
                    const o = other.body.getPosition();
                    const along = (o.x - gunPos.x) * Math.cos(firingAngle) + (o.y - gunPos.y) * Math.sin(firingAngle);
                    if (along <= 0 || along > 150) return false;
                    const perp = Math.abs(-(o.x - gunPos.x) * Math.sin(firingAngle) + (o.y - gunPos.y) * Math.cos(firingAngle));
                    return perp < 10;
                  });
                  if (!friendlyNear) {
                    const muzzleVelocity = 350;
                    const bulletVel = {
                      x: vel.x + Math.cos(firingAngle) * muzzleVelocity,
                      y: vel.y + Math.sin(firingAngle) * muzzleVelocity
                    };
                    if (!game.enemyProjectiles) game.enemyProjectiles = [];
                    // 100% tracers
                    game.enemyProjectiles.push({
                      x: gunPos.x,
                      y: gunPos.y,
                      vx: bulletVel.x,
                      vy: bulletVel.y,
                      type: 'tracer',
                      life: 3.0,
                      initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y),
                      owner: enemy
                    });
                    enemy.gunnerLastShotTime = now;
                    if (sounds.gunfire) playSound(sounds.gunfire, 0.1);
                  }
                }
              }
            }
            
            // Use same physics as player aircraft but with AI controls
            
            // Progressive thrust reduction based on damage
            let maxThrust = 30000; // Base thrust for heavy bomber
            
            // Apply progressive damage reduction
            maxThrust *= (1 - enemy.thrustReduction);
              
              // Apply altitude-based thrust reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                maxThrust *= altitudeReduction;
              }
              
            const thrust = 0.5 * maxThrust; // 50% throttle for slower cruise
              const thrustForce = pl.Vec2(Math.cos(angle) * thrust, Math.sin(angle) * thrust);
              enemy.body.applyForceToCenter(thrustForce, true);
            
            // Aerodynamics (enhanced for level flight)
            if (speed > 1) {
              const q = 0.5 * 1.225 * speed * speed; // Dynamic pressure
              const wingArea = enemy.type === 'ju88' ? 100 : 30; // Ju-88s need much more wing area to stay aloft
              
              // Calculate angle of attack relative to velocity
              const velocityAngle = Math.atan2(vel.y, vel.x);
              const aoa = angle - velocityAngle;
              
              // Enhanced lift coefficient for stable level flight
              let liftCoeff = Math.sin(aoa * 2) * 1.5;
              
              // Add minimum lift to counteract gravity for level flight
              const minLiftForLevelFlight = 1.2; // Higher minimum lift coefficient
              if (Math.abs(liftCoeff) < minLiftForLevelFlight) {
                liftCoeff = Math.sign(liftCoeff || 1) * minLiftForLevelFlight;
              }
              
              // Apply altitude-based lift reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                liftCoeff *= altitudeReduction;
              }
              
              // Apply lift with progressive damage reduction
              const lift = q * wingArea * liftCoeff * (1 - enemy.liftReduction);
                const liftAngle = velocityAngle + Math.PI/2;
                const liftForce = pl.Vec2(Math.cos(liftAngle) * lift, Math.sin(liftAngle) * lift);
                enemy.body.applyForceToCenter(liftForce, true);
              
              // Additional upward force to counteract gravity (reduced by damage)
              // Ju-88s get more lift to prevent crashing, BF-109s are more agile
              const liftMultiplier = enemy.type === 'ju88' ? 1.0 : 0.8;
              const gravityCounterForce = enemy.body.getMass() * 9.81 * liftMultiplier * (1 - enemy.liftReduction * 0.5);
              enemy.body.applyForceToCenter(pl.Vec2(0, -gravityCounterForce), true);
              
              // Drag - reduce for Ju-88s to let them cruise easier
              const baseDrag = enemy.type === 'ju88' ? 0.003 : 0.01; // Lower drag for Ju-88s
              const inducedScale = enemy.type === 'ju88' ? 0.004 : 0.01; // Lower induced drag for Ju-88s
              const dragCoeff = baseDrag + Math.abs(liftCoeff) * inducedScale;
              const drag = q * wingArea * dragCoeff;
              const dragForce = pl.Vec2(-vel.x / speed * drag, -vel.y / speed * drag);
              enemy.body.applyForceToCenter(dragForce, true);
            }
            
            // Enhanced AI: Maintain altitude and heading (unless pitching down to crash)
            if (!enemy.pitchingDown) {
              // Normal flight: Altitude control - maintain level flight
              const altitudeError = pos.y - enemy.targetAltitude;
              
              // Calculate desired pitch based on altitude error
              let desiredPitch = 0.1; // Stronger upward pitch for level flight (5.7 degrees)
              if (Math.abs(altitudeError) > 2.5) { // 5m deadband in visual altitude
                // Pitch up if too low, pitch down if too high
                const pitchCorrection = -Math.sign(altitudeError) * Math.min(Math.abs(altitudeError) * 0.05, 0.25); // Stronger correction
                desiredPitch += pitchCorrection;
              }
              
              // Combine with left-facing heading
              const targetAngle = Math.PI + desiredPitch; // Fly left with pitch adjustment
            const angleDiff = targetAngle - angle;
            
            // Normalize angle difference to [-œÄ, œÄ]
            let normalizedAngleDiff = angleDiff;
            while (normalizedAngleDiff > Math.PI) normalizedAngleDiff -= 2 * Math.PI;
            while (normalizedAngleDiff < -Math.PI) normalizedAngleDiff += 2 * Math.PI;
            
              // Apply correction torque to maintain target angle (heading + altitude)
              const bf109HeavilyDamaged = (enemy.type === 'bf109') && (enemy.onFire || enemy.liftReduction > 0.5 || enemy.thrustReduction > 0.6);
              if (Math.abs(normalizedAngleDiff) > 0.02 && !bf109HeavilyDamaged) { // 1.1 degree deadband for precise control
                const correctionTorque = normalizedAngleDiff * 40000; // Much stronger correction for altitude control
                enemy.body.applyTorque(correctionTorque, true);
              }

              // If BF-109 is heavily damaged, clamp spin and reduce angular velocity instead of adding torque
              if (bf109HeavilyDamaged) {
                if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(10.0);
                const w = enemy.body.getAngularVelocity();
                const maxW = 1.0; // rad/s
                const clamped = Math.max(-maxW, Math.min(maxW, w));
                enemy.body.setAngularVelocity(clamped * 0.9);
                // Keep some forward force so it doesn't rotate in place
                const ang = enemy.body.getAngle();
                const forward = Math.max(5000, (1 - enemy.thrustReduction) * 15000);
                enemy.body.applyForceToCenter(pl.Vec2(Math.cos(ang) * forward, Math.sin(ang) * forward), true);
              }
            } else {
              // Crashing
              if (enemy.type !== 'bf109') {
                const crashTorque = 30000; // Continuous downward pitch for bombers
                enemy.body.applyTorque(crashTorque, true);
              } else {
                // For BF-109s: clamp/damp spin and glide instead of spinning around a point
                if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(10.0);
                const w = enemy.body.getAngularVelocity();
                const maxW = 1.0;
                const clamped = Math.max(-maxW, Math.min(maxW, w));
                enemy.body.setAngularVelocity(clamped * 0.9);
              }
            }
          });
        }
        
        function checkProjectileEnemyCollision(proj, projIndex) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            // Pixel-perfect collision detection
            if (checkPixelCollision(proj.x, proj.y, enemy)) {
              console.log('üéØ Pixel-perfect hit detected!', { projectilePos: { x: proj.x, y: proj.y }, enemyHealth: enemy.health });
              
              // Create small hit explosion effect
              game.explosions.push({
                x: proj.x,
                y: proj.y,
                time: 0,
                duration: 0.3, // Short hit explosion
                size: 3, // Small hit explosion (6m diameter)
                type: 'hit' // Mark as hit explosion for different rendering
              });
              
              // Play hit sound effect
              playSound(sounds.hit, 0.2);
              
              // Damage enemy
              enemy.health--;
              
              // Remove projectile
              game.projectiles.splice(projIndex, 1);
              
              // Trigger evasive action for intelligent enemies
              if (enemy.type === 'bf109' && !enemy.destroyed) {
                enemy.consecutiveHits++;
                enemy.timeSinceLastHit = 0;
                
                // Immediate evasion if taking fire
                if (enemy.aiState !== 'evade' && enemy.aiState !== 'boom_zoom') {
                  // Higher chance to evade if damaged or ace pilot
                  const evasionChance = enemy.skillLevel === 'ace' ? 0.8 : 0.6;
                  if (Math.random() < evasionChance || enemy.health <= 1) {
                    enemy.previousState = enemy.aiState;
                    enemy.aiState = 'evade';
                    enemy.stateTimer = 0;
                    enemy.evasionDirection = Math.random() > 0.5 ? 1 : -1;
                    enemy.isEvading = true;
                    console.log(`üí® ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 taking evasive action!`);
                  }
                }
              }
              
              // Progressive damage system with realistic crash physics
              if (enemy.health <= 0 && !enemy.destroyed) {
                enemy.destroyed = true;
                enemy.thrustReduction = 1.0; // Complete thrust loss
                enemy.liftReduction = 1.0; // Complete lift loss
                enemy.onFire = true;
                enemy.pitchingDown = true; // Mark for pitch down behavior
                console.log('üí• Enemy critically damaged - pitching down to crash');
                
                // Force nose down and disable altitude control
                const crashTorque = 50000; // Strong downward pitch force
                enemy.body.applyTorque(crashTorque, true);
              } else {
                              // Progressive damage based on remaining health and aircraft type
              const damageRatio = 1 - (enemy.health / enemy.maxHealth);
              
              if (enemy.type === 'bf109') {
                // BF-109 damage thresholds (lower health)
                if (enemy.health <= 2) {
                  enemy.thrustReduction = Math.min(0.7, damageRatio * 1.0);
                  if (!enemy.smoking) {
                    enemy.smoking = true;
                    console.log('üí® BF-109 engine smoking');
                  }
                }
                
                if (enemy.health <= 1) {
                  enemy.liftReduction = Math.min(0.5, damageRatio * 0.6);
                  if (!enemy.onFire) {
                    enemy.onFire = true;
                    console.log('üî• BF-109 on fire - losing control');
                  }
                }
              } else {
                // Ju-88 damage thresholds (higher health)
                if (enemy.health <= 3) {
                  enemy.thrustReduction = Math.min(0.8, damageRatio * 1.2);
                  if (!enemy.smoking) {
                    enemy.smoking = true;
                    console.log('üí® Ju-88 engine smoking');
                  }
                }
                
                if (enemy.health <= 2) {
                  enemy.liftReduction = Math.min(0.6, damageRatio * 0.8);
                  if (!enemy.onFire) {
                    enemy.onFire = true;
                    console.log('üî• Ju-88 on fire - losing lift');
                  }
                }
              }
              }
            }
          });
        }
        
        function destroyEnemy(enemy) {
          // This function is now only called for ground impact destruction
          console.log('üí• Enemy destroyed by ground impact!');
          enemy.destroyed = true;
          
          const pos = enemy.body.getPosition();
          
          // Create destruction explosion effect only for ground impact
          game.explosions.push({
            x: pos.x,
            y: pos.y,
            time: 0,
            duration: 1.0, // 1 second explosion
            size: 20, // 40m explosion diameter
            type: 'destruction' // Mark as destruction explosion
          });
          
          // Play explosion sound effect
          playSound(sounds.explosion, 0.5);
          
          // Remove body from physics world
          world.destroyBody(enemy.body);
        }
        
        function updateExplosions(dt) {
          for (let i = game.explosions.length - 1; i >= 0; i--) {
            const explosion = game.explosions[i];
            explosion.time += dt;
            
            if (explosion.time >= explosion.duration) {
              game.explosions.splice(i, 1);
            }
          }
        }
      
      function checkEnemyProjectilePlayerCollision(proj, projIndex) {
        // Check if enemy bullet hits player
        if (checkPlayerPixelCollision(proj.x, proj.y)) {
          console.log('üí• Player hit by enemy fire!');
          
          // Create hit explosion effect
          game.explosions.push({
            x: proj.x,
            y: proj.y,
            time: 0,
            duration: 0.2,
            size: 2,
            type: 'hit'
          });
          
          // Play hit sound
          playSound(sounds.hit, 0.3);
          
          // Remove projectile
          game.enemyProjectiles.splice(projIndex, 1);
          
          // Player damage system
          // Use hit points: each hit removes 1 (both bullet and tracer)
          const damage = 1;
          game.playerHealth = Math.max(0, game.playerHealth - damage);
          if (game.playerHealth <= 0 && !game.crashed) {
            console.log('üíÄ Player destroyed!');
            game.crashed = true;
          }
        }
      }
      
      function trySpawnGuns() {
        console.log('üî´ trySpawnGuns called');
        const now = performance.now();
        console.log('üïí Fire timing:', { now, lastFireTime, interval: fireInterval, canFire: now - lastFireTime >= fireInterval });
        if (now - lastFireTime < fireInterval) {
          console.log('‚è±Ô∏è Fire rate limited, skipping');
          return;
        }
        lastFireTime = now;
        
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const vel = aircraft.getLinearVelocity();
        
        // Center gun position (middle of plane)
        const gunForward = 2.0; // Forward from center to gun muzzle
        
        // Calculate gun position (center of plane)
        const gunPos = {
          x: pos.x + Math.cos(angle) * gunForward,
          y: pos.y + Math.sin(angle) * gunForward
        };
        
        // Muzzle velocity (relative to aircraft)
        const muzzleVelocity = 400; // m/s in physics units (increased from 150)
        const bulletVel = {
          x: vel.x + Math.cos(angle) * muzzleVelocity,
          y: vel.y + Math.sin(angle) * muzzleVelocity
        };
        
        // Increment shot counter and determine tracer pattern
        shotCounter++;
        // Spawn bullets and tracers (every 4th round is a tracer: bullet, bullet, bullet, tracer)
        const isTracer = shotCounter % 4 === 0;
        console.log(`üéØ Shot #${shotCounter}: ${isTracer ? 'TRACER' : 'BULLET'} (pattern: ${shotCounter % 4})`);
        
        // Center gun
        game.projectiles.push({
          x: gunPos.x,
          y: gunPos.y,
          vx: bulletVel.x,
          vy: bulletVel.y,
          type: isTracer ? 'tracer' : 'bullet',
          life: 5.0, // 5 seconds max flight time
          initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y)
        });
        
        // Spawn casing from bottom of aircraft
        const casingPos = {
          x: pos.x - Math.cos(angle) * 0.5, // Slightly behind center
          y: pos.y - Math.sin(angle) * 0.5 + 0.8 // Below aircraft
        };
        
        game.casings.push({
          x: casingPos.x,
          y: casingPos.y,
          vx: vel.x + (Math.random() - 0.5) * 10, // Random sideways velocity
          vy: vel.y + 15 + Math.random() * 10, // Downward with randomness
          rotation: Math.random() * Math.PI * 2,
          angularVel: (Math.random() - 0.5) * 20,
          life: 10.0 // Casings last longer
        });
        
        // Play gunfire sound effect
        playSound(sounds.gunfire, 0.3);
        
        console.log('üî´ Fired guns! Projectiles:', game.projectiles.length, 'Casings:', game.casings.length);
        console.log('üéØ Latest projectile:', game.projectiles[game.projectiles.length - 1]);
        console.log('üéØ Latest casing:', game.casings[game.casings.length - 1]);
      }
      
      function updateProjectiles(dt) {
        // Update player bullets and tracers
        for (let i = game.projectiles.length - 1; i >= 0; i--) {
          const proj = game.projectiles[i];
          
          // Check collision with enemies before updating position
          checkProjectileEnemyCollision(proj, i);
          
          // Apply drag
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const dragCoeff = 0.02; // Air resistance
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            proj.vx -= (proj.vx / speed) * drag * dt;
            proj.vy -= (proj.vy / speed) * drag * dt;
          }
          
          // Update position
          proj.x += proj.vx * dt;
          proj.y += proj.vy * dt;
          
          // Decrease life
          proj.life -= dt;
          
          // Remove if expired
          if (proj.life <= 0) {
            game.projectiles.splice(i, 1);
          }
        }
        
        // Update enemy projectiles
        if (game.enemyProjectiles) {
          for (let i = game.enemyProjectiles.length - 1; i >= 0; i--) {
            const proj = game.enemyProjectiles[i];
            
            // Check collision with player
            checkEnemyProjectilePlayerCollision(proj, i);
            
            // Apply drag
            const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
            const dragCoeff = 0.02;
            const drag = dragCoeff * speed;
            
            if (speed > 0) {
              proj.vx -= (proj.vx / speed) * drag * dt;
              proj.vy -= (proj.vy / speed) * drag * dt;
            }
            
            // Update position
            proj.x += proj.vx * dt;
            proj.y += proj.vy * dt;
            
            // Decrease life
            proj.life -= dt;
            
            // Remove if expired
            if (proj.life <= 0) {
              game.enemyProjectiles.splice(i, 1);
            }
          }
        }
        
        // Update casings
        for (let i = game.casings.length - 1; i >= 0; i--) {
          const casing = game.casings[i];
          
          // Apply gravity and drag
          casing.vy += 9.81 * dt; // Gravity
          
          const speed = Math.sqrt(casing.vx * casing.vx + casing.vy * casing.vy);
          const dragCoeff = 0.8; // Extreme drag for casings (was 0.3)
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            casing.vx -= (casing.vx / speed) * drag * dt;
            casing.vy -= (casing.vy / speed) * drag * dt;
          }
          
          // Update position and rotation
          casing.x += casing.vx * dt;
          casing.y += casing.vy * dt;
          casing.rotation += casing.angularVel * dt;
          
          // Decrease life
          casing.life -= dt;
          
          // Remove if expired
          if (casing.life <= 0) {
            game.casings.splice(i, 1);
          }
        }
      }
      
      // Add collision detection for landing/crashing system
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check for aircraft-enemy collision (plane to plane)
        const isAircraftA = bodyA === aircraft;
        const isAircraftB = bodyB === aircraft;
        const enemyDataA = bodyA.getUserData();
        const enemyDataB = bodyB.getUserData();
        const enemyFromA = enemyDataA?.type === 'enemy' ? enemyDataA.enemy : null;
        const enemyFromB = enemyDataB?.type === 'enemy' ? enemyDataB.enemy : null;
        
        if ((isAircraftA && enemyFromB) || (isAircraftB && enemyFromA)) {
          const enemy = enemyFromA || enemyFromB;
          
          if (!enemy.destroyed) {
            console.log('‚úàÔ∏èüí• Mid-air collision with enemy!');
            
            // Pixel-perfect verification: only collide if opaque pixels overlap
            if (!checkPlanePlanePixelOverlap(enemy)) {
              // Ignore false positives from broad-phase contact
              return;
            }
            
            // Major damage to both aircraft
            game.crashed = true;
            enemy.health = Math.max(0, enemy.health - 7);
            
            // Destroy enemy if killed
            if (enemy.health <= 0) {
              destroyEnemy(enemy);
            }
            
            // Apply collision forces to separate aircraft
            const playerVel = aircraft.getLinearVelocity();
            const enemyVel = enemy.body.getLinearVelocity();
            
            // Bounce apart
            aircraft.setLinearVelocity(pl.Vec2(playerVel.x * -0.5, playerVel.y * 0.3));
            enemy.body.setLinearVelocity(pl.Vec2(enemyVel.x * -0.5, enemyVel.y * 0.3));
            
            // Add spin from collision
            aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 10);
            enemy.body.setAngularVelocity(enemy.body.getAngularVelocity() + (Math.random() - 0.5) * 10);
          }
          
          return; // Skip ground check if we hit an enemy
        }
        
        // Enhanced ground collision for realistic landing/takeoff
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const verticalSpeed = Math.abs(vel.y);
          const horizontalSpeed = Math.abs(vel.x);
          const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          game.onGround = true;
          game.groundSpeed = horizontalSpeed;
          
          console.log(`üõ¨ Ground contact - Vertical: ${verticalSpeed.toFixed(1)} m/s, Horizontal: ${horizontalSpeed.toFixed(1)} m/s, Gear: ${game.gearDown ? 'DOWN' : 'UP'}`);
          
          // Improved landing physics
          const crashThreshold = game.gearDown ? 10.0 : 6.0; // Higher tolerance with gear
          const hardLandingThreshold = game.gearDown ? 6.0 : 3.0;
          
          if (verticalSpeed > crashThreshold) {
            // High vertical speed = crash
            game.crashed = true;
            console.log('üí• CRASHED! Vertical speed too high:', verticalSpeed.toFixed(1), 'm/s');
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else if (verticalSpeed > hardLandingThreshold) {
            // Hard landing
            const gearProtection = game.gearDown ? 0.7 : 0.3; // Gear absorbs impact
            console.log(game.gearDown ? '‚ö†Ô∏è Hard landing with gear!' : '‚ö†Ô∏è Hard landing without gear!');
            
            // Apply ground friction and impact absorption
            const frictionCoeff = game.gearDown ? 0.95 : 0.85; // Gear has better braking
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * frictionCoeff * gearProtection,
              Math.min(vel.y * 0.1, 0) // Absorb vertical impact
            ));
            
            // Add instability for gear-up landings
            if (!game.gearDown) {
              aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 3);
            }
          } else {
            // Smooth landing
            const friction = game.gearDown ? 0.98 : 0.92; // Gear provides better control
            console.log(game.gearDown ? '‚úÖ Smooth landing with gear!' : 'üü° Belly landing');
            
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * friction,
              Math.min(vel.y * 0.05, 0) // Gentle touchdown
            ));
          }
        }
        
        // Check if enemy aircraft hit ground
        const enemyBodyA = bodyA.getUserData()?.type === 'enemy' ? bodyA : null;
        const enemyBodyB = bodyB.getUserData()?.type === 'enemy' ? bodyB : null;
        
        if (enemyBodyA || enemyBodyB) {
          const enemyBody = enemyBodyA || enemyBodyB;
          const enemy = enemyBody.getUserData().enemy;
          
          if (enemy && !enemy.destroyed) {
            const vel = enemyBody.getLinearVelocity();
            const verticalSpeed = Math.abs(vel.y);
            const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
            
            console.log(`üí• Enemy ground collision! Vertical: ${verticalSpeed.toFixed(1)} m/s, Total: ${totalSpeed.toFixed(1)} m/s`);
            
            // Enemy takes damage based on impact speed
            let damage = 0;
            if (verticalSpeed > 15) {
              damage = 5; // High speed impact - major damage
              console.log('üí• Enemy heavy ground impact - major damage!');
            } else if (verticalSpeed > 8) {
              damage = 3; // Medium speed impact - moderate damage
              console.log('üí• Enemy moderate ground impact - damage taken!');
            } else if (verticalSpeed > 3) {
              damage = 1; // Low speed impact - minor damage
              console.log('üí• Enemy light ground contact - minor damage!');
            }
            
            if (damage > 0) {
              enemy.health -= damage;
              console.log(`‚ö†Ô∏è Enemy health: ${enemy.health}/${enemy.maxHealth}`);
              
              // Check if enemy is destroyed
              if (enemy.health <= 0 && !enemy.destroyed) {
                destroyEnemy(enemy);
              } else {
                // Reduce enemy speed on ground impact
                enemyBody.setLinearVelocity(pl.Vec2(vel.x * 0.4, vel.y * 0.1));
                // Add some spin from the impact
                enemyBody.setAngularVelocity(enemyBody.getAngularVelocity() + (Math.random() - 0.5) * 4);
              }
            }
          }
        }
      });
      
      // Add ground contact end detection for takeoff
      world.on('end-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft left ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          // Small delay to ensure we're actually airborne
          setTimeout(() => {
            const pos = aircraft.getPosition();
            const groundClearance = -pos.y; // Distance above ground
            if (groundClearance > 2) { // 4m clearance before considering truly airborne
              game.onGround = false;
              game.groundSpeed = 0;
              console.log('üõ´ Aircraft airborne');
            }
          }, 100);
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, -300), 0); // Reset to safe altitude above ground (scaled)
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Calculate speed once for use in both controls and aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        // Flight controls - Hybrid approach (force + torque for reliability)
        const controlEffectiveness = Math.min(speed * 0.1, 1.0); // Controls more effective at higher speeds
        const controlTorque = 20000 * controlEffectiveness; // Moderate torque for reliable control
        
        // Debug control inputs
        if (Math.random() < 0.02) { // Occasional debug logging
          console.log('üéÆ Controls:', { pitchUp, pitchDown, rollLeft, rollRight, effectiveness: controlEffectiveness.toFixed(2) });
        }
        
        if (pitchUp) {
          aircraft.applyTorque(-controlTorque, true);
        }
        if (pitchDown) {
          aircraft.applyTorque(controlTorque, true);
        }
        if (rollLeft) {
          aircraft.applyTorque(-controlTorque * 0.6, true);
        }
        if (rollRight) {
          aircraft.applyTorque(controlTorque * 0.6, true);
        }
        
        // Continuous firing while holding space
        const firing = game.keys.has(' ');
        if (firing) {
          trySpawnGuns();
        }
        
        // Enhanced thrust system with ground effects
        let maxThrust = 300000; // Base thrust
        
        // Ground effect: slightly reduced thrust efficiency on ground
        if (game.onGround) {
          maxThrust *= 0.95; // 5% reduction on ground due to prop wash
        }
        
        // Gear drag: landing gear creates extra drag
        if (game.gearDown) {
          maxThrust *= 0.9; // 10% thrust reduction with gear down
        }
        
        // Altitude-based thrust reduction (same as lift)
        const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
        if (visualAltitude > 5000) {
          if (visualAltitude >= 5250) {
            maxThrust = 0; // No thrust above 5250m (engine failure)
          } else {
            // Linear reduction from 5000m to 5250m
            const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
            maxThrust *= reductionFactor;
          }
        }
        
        // Ground roll physics for takeoff
        if (game.onGround && game.groundSpeed < 25) { // Below takeoff speed
          maxThrust *= 1.1; // Extra thrust for ground roll
        }
        
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // CRITICAL FIX: Manually override Box2D's velocity cap
        // Box2D caps at ~120 m/s physics (240 m/s visual), we need to break through
        const currentSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        const targetSpeed = game.throttle * 250; // Target speed based on throttle (up to 250 m/s physics = 500 m/s visual)
        
        // If we're near the 120 m/s cap and should be going faster, boost manually
        if (game.throttle > 0.5 && currentSpeed > 115 && currentSpeed < 125 && targetSpeed > currentSpeed) {
          const velocityDirection = Math.atan2(vel.y, vel.x);
          const newVelX = Math.cos(velocityDirection) * targetSpeed;
          const newVelY = Math.sin(velocityDirection) * targetSpeed;
          aircraft.setLinearVelocity(pl.Vec2(newVelX, newVelY));
          console.log(`‚ö° Breaking speed cap: ${(currentSpeed * VISUAL_SCALE).toFixed(0)} ‚Üí ${(targetSpeed * VISUAL_SCALE).toFixed(0)} m/s`);
        }
        
        // Enhanced aerodynamics with ground effects and gear effects
        if (speed > 1) {
          const airDensity = 1.225;
          let wingArea = 20;
          
          // Ground effect: increased lift near ground
          if (game.onGround || -pos.y < 5) { // Within 10m of ground
            wingArea *= 1.15; // 15% more effective wing area in ground effect
          }
          
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified) with altitude-based reduction
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          let liftCoeff = Math.sin(aoa * 2) * 1.5;
          
          // Gear effects on lift
          if (game.gearDown) {
            liftCoeff *= 0.9; // Gear creates some disruption to airflow
          }
          
          // Altitude-based lift reduction (physics units, converted to visual for calculation)
          const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
          if (visualAltitude > 5000) {
            if (visualAltitude >= 5250) {
              liftCoeff = 0; // No lift above 5250m
            } else {
              // Linear reduction from 5000m to 5250m
              const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
              liftCoeff *= reductionFactor;
            }
          }
          
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag - Minimized for very high top speeds
          const dragCoeff = 0.005 + Math.abs(liftCoeff) * 0.005; // Even lower drag to break 240 m/s barrier
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background - main map in center, tileable on sides
        const groundLevel = 0; // physical ground reference
        const mapHeight = WORLD_HEIGHT;
        
        if (assets.loaded.map && assets.map && assets.loaded.tileableMap && assets.tileableMap) {
          // Calculate main map dimensions and position
          const mainMapWidth = WORLD_WIDTH; // 4000m wide
          const mainMapPixelWidth = mainMapWidth * SCALE * game.camera.zoom;
          const mainMapPixelHeight = mapHeight * SCALE * game.camera.zoom;
          // Draw main map in center such that its bottom sits at MAP_BOTTOM_ALTITUDE
          // So the draw origin (top-left) is at y = (MAP_BOTTOM_ALTITUDE - mapHeight)
          const mainMapPos = worldToScreen(-mainMapWidth/2, MAP_BOTTOM_ALTITUDE - mapHeight);
          ctx.drawImage(assets.map, mainMapPos.x, mainMapPos.y, mainMapPixelWidth, mainMapPixelHeight);
          
          // Calculate tileable map dimensions
          const tileableMapNaturalRatio = assets.tileableMap.naturalWidth / assets.tileableMap.naturalHeight;
          const tileableMapPixelHeight = mainMapPixelHeight; // Same height as main map
          const tileableMapPixelWidth = tileableMapPixelHeight * tileableMapNaturalRatio;
          const tileableMapWorldWidth = tileableMapPixelWidth / (SCALE * game.camera.zoom);
          
          // Draw tileable maps on the left side
          const leftStartX = -mainMapWidth/2;
          const visibleLeftStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - leftStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + leftStartX;
          for (let x = visibleLeftStart; x > game.camera.x - canvasWidth/(SCALE*game.camera.zoom); x -= tileableMapWorldWidth) {
            const tilePos = worldToScreen(x - tileableMapWorldWidth, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
          // Draw tileable maps on the right side
          const rightStartX = mainMapWidth/2;
          const visibleRightStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - rightStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + rightStartX;
          for (let x = visibleRightStart; x < game.camera.x + canvasWidth/(SCALE*game.camera.zoom); x += tileableMapWorldWidth) {
            const tilePos = worldToScreen(x, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map || !assets.loaded.tileableMap) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading maps...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        // Debug: Log aircraft state periodically
        if (Math.random() < 0.02) { // 2% chance per frame for debugging
          console.log('‚úàÔ∏è Aircraft state:', {
            angle: (angle * 180 / Math.PI).toFixed(1) + '¬∞',
            inverted: game.inverted,
            gearDown: game.gearDown,
            position: { x: pos.x.toFixed(1), y: pos.y.toFixed(1) },
            expectedSprite: game.inverted && game.gearDown ? 'inverted+gear' : 
                          game.inverted && !game.gearDown ? 'inverted' :
                          !game.inverted && game.gearDown ? 'normal+gear' : 'normal'
          });
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        // Choose sprite based on inverted mode and gear state
        let currentSprite, spriteLoaded, spriteDescription;
        
        if (game.inverted && game.gearDown) {
          currentSprite = assets.spitfireInvertedGear;
          spriteLoaded = assets.loaded.spitfireInvertedGear;
          spriteDescription = "inverted with gear";
        } else if (game.inverted && !game.gearDown) {
          currentSprite = assets.spitfireInverted;
          spriteLoaded = assets.loaded.spitfireInverted;
          spriteDescription = "inverted no gear";
        } else if (!game.inverted && game.gearDown) {
          currentSprite = assets.spitfireGear;
          spriteLoaded = assets.loaded.spitfireGear;
          spriteDescription = "normal with gear";
        } else {
          currentSprite = assets.spitfire;
          spriteLoaded = assets.loaded.spitfire;
          spriteDescription = "normal no gear";
        }
        
        // Debug: Log sprite selection when gear changes
        if (game.keys.has('g') && Math.random() < 0.1) { // 10% chance when G is held
          console.log('üé® Sprite selection:', {
            description: spriteDescription,
            spriteLoaded: spriteLoaded,
            hasSprite: !!currentSprite,
            allLoadStates: assets.loaded
          });
        }
        
        if (spriteLoaded && currentSprite) {
          const scale = 0.4 * game.camera.zoom;
          const w = currentSprite.naturalWidth * scale;
          const h = currentSprite.naturalHeight * scale;
          ctx.drawImage(currentSprite, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          let fillColor = '#4169E1'; // Default blue
          if (game.inverted && game.gearDown) fillColor = '#800080'; // Purple for inverted with gear
          else if (game.inverted) fillColor = '#E14169'; // Red for inverted
          else if (game.gearDown) fillColor = '#228B22'; // Green for gear down
          
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = game.inverted ? '#801080' : '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
          
          // Draw gear indicator
          if (game.gearDown) {
            ctx.fillStyle = '#FFD700'; // Gold for gear
            ctx.fillRect(-size*0.3, size*0.3, size*0.6, size*0.2);
          }
        }
        
        ctx.restore();
        
        // Render projectiles (bullets and tracers)
        if (game.projectiles.length > 0) {
          console.log('üé® Rendering', game.projectiles.length, 'projectiles');
        }
        game.projectiles.forEach(proj => {
          const screenPos = worldToScreen(proj.x, proj.y);
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const angle = Math.atan2(proj.vy, proj.vx);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(angle);
          
          if (proj.type === 'tracer') {
            // Tracer gets smaller as it slows down, but maintains world scale
            const speedRatio = speed / proj.initialSpeed;
            const sizeMultiplier = 1.3; // 1.3x size increase as requested
            const tracerLength = TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom * sizeMultiplier;
            const tracerWidth = TRACER_WIDTH * speedRatio * SCALE * game.camera.zoom * sizeMultiplier;
            
            // Bright yellow tracer with glow effect
            ctx.shadowColor = '#FFFF00';
            ctx.shadowBlur = 8 * game.camera.zoom;
            
            if (assets.loaded.tracer && assets.tracer) {
              // Apply yellow tint to sprite
              ctx.globalCompositeOperation = 'screen';
              ctx.fillStyle = '#FFFF00';
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              ctx.globalCompositeOperation = 'source-over';
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else {
              // Fallback tracer - bright yellow with gradient
              const gradient = ctx.createLinearGradient(-tracerLength/2, 0, tracerLength/2, 0);
              gradient.addColorStop(0, `rgba(255, 255, 100, ${Math.max(0.4, 0.6 * speedRatio)})`);
              gradient.addColorStop(0.5, `rgba(255, 255, 0, ${Math.max(0.8, 1.0 * speedRatio)})`);
              gradient.addColorStop(1, `rgba(255, 255, 200, ${Math.max(0.4, 0.6 * speedRatio)})`);
              ctx.fillStyle = gradient;
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              
              // Add bright core
              ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0.6, 0.9 * speedRatio)})`;
              ctx.fillRect(-tracerLength/4, -tracerWidth/4, tracerLength/2, tracerWidth/2);
            }
            
            // Reset shadow
            ctx.shadowBlur = 0;
          } else {
            // Regular bullet - world scale
            const bulletSize = BULLET_SIZE * SCALE * game.camera.zoom;
            
            if (assets.loaded.bullet && assets.bullet) {
              const scale = bulletSize / Math.max(assets.bullet.naturalWidth, assets.bullet.naturalHeight);
              const w = assets.bullet.naturalWidth * scale;
              const h = assets.bullet.naturalHeight * scale;
              ctx.drawImage(assets.bullet, -w/2, -h/2, w, h);
            } else {
              // Fallback bullet - bright gold/yellow
              ctx.fillStyle = '#FFD700';
              ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
            }
          }
          
          ctx.restore();
        });
        
        // Render casings
        game.casings.forEach(casing => {
          const screenPos = worldToScreen(casing.x, casing.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(casing.rotation);
          
          const casingSize = CASING_SIZE * SCALE * game.camera.zoom;
          
          if (assets.loaded.casing && assets.casing) {
            const scale = casingSize / Math.max(assets.casing.naturalWidth, assets.casing.naturalHeight);
            const w = assets.casing.naturalWidth * scale;
            const h = assets.casing.naturalHeight * scale;
            ctx.drawImage(assets.casing, -w/2, -h/2, w, h);
          } else {
            // Fallback casing - brass colored
            ctx.fillStyle = '#DAA520'; // Dark golden rod (brass color)
            ctx.fillRect(-casingSize/2, -casingSize/3, casingSize, casingSize*2/3);
          }
          
          ctx.restore();
        });
        
        // Render enemies
        game.enemies.forEach(enemy => {
          if (enemy.destroyed && !enemy.pitchingDown) return;
          
          const pos = enemy.body.getPosition();
          const angle = enemy.body.getAngle();
          const screenPos = worldToScreen(pos.x, pos.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          
          if (enemy.type === 'bf109') {
            // BF-109 rendering
            ctx.rotate(angle);
            
            const baseSize = 16 * SCALE * game.camera.zoom; // Doubled fighter size
            let sprite = null;
            let spriteLoaded = false;
            
            // Choose correct sprite based on facing direction
            if (enemy.facingDirection === 'right') {
              sprite = assets.bf109Right;
              spriteLoaded = assets.loaded.bf109Right;
            } else {
              sprite = assets.bf109Left;
              spriteLoaded = assets.loaded.bf109Left;
            }
            
            if (spriteLoaded && sprite) {
              const aspectRatio = sprite.naturalWidth / sprite.naturalHeight;
              const width = baseSize * aspectRatio;
              const height = baseSize;
              
              // Add golden glow for ace pilots
              if (enemy.skillLevel === 'ace' && !enemy.destroyed) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 10 * game.camera.zoom;
                ctx.globalAlpha = 0.9;
              }
              
              // Flip vertically to correct upside-down orientation
              ctx.scale(1, -1);
              ctx.drawImage(sprite, -width/2, -height/2, width, height);
              ctx.scale(1, -1); // Reset scale
              
              // Reset shadow and alpha
              ctx.shadowBlur = 0;
              ctx.globalAlpha = 1.0;
            } else {
              // Fallback BF-109 - smaller grey fighter
              let baseColor = '#666666';
              if (enemy.onFire) baseColor = '#8B0000';
              else if (enemy.smoking) baseColor = '#808080';
              else if (enemy.skillLevel === 'ace') baseColor = '#444499'; // Ace pilots get blue tint
              
              ctx.fillStyle = baseColor;
              const width = baseSize * 1.5; // Fighter aspect ratio
              const height = baseSize;
              ctx.fillRect(-width/2, -height/2, width, height);
              
              // Fighter outline (gold for aces)
              ctx.strokeStyle = enemy.skillLevel === 'ace' ? '#FFD700' : '#333333';
              ctx.lineWidth = enemy.skillLevel === 'ace' ? 2 : 1;
              ctx.strokeRect(-width/2, -height/2, width, height);
            }
            
            // Add ace indicator star
            if (enemy.skillLevel === 'ace' && !enemy.destroyed) {
              ctx.fillStyle = '#FFD700';
              ctx.font = `${8 * game.camera.zoom}px Arial`;
              ctx.textAlign = 'center';
              ctx.fillText('‚≠ê', 0, -baseSize);
            }
          } else {
            // Ju-88 rendering (existing code)
            ctx.rotate(angle);
            
            const originalAspectRatio = assets.loaded.ju88 && assets.ju88 ? assets.ju88.naturalWidth / assets.ju88.naturalHeight : 1.5;
            const baseEnemySize = 24 * SCALE * game.camera.zoom;
            const enemyWidth = baseEnemySize * originalAspectRatio;
            const enemyHeight = baseEnemySize;
            
            if (assets.loaded.ju88 && assets.ju88) {
              ctx.scale(-1, -1); // Flip for ju-88
              ctx.drawImage(assets.ju88, -enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
            } else {
              // Fallback bomber
              let baseColor = '#444444';
              if (enemy.onFire) baseColor = '#8B0000';
              else if (enemy.smoking) baseColor = '#696969';
              
              ctx.fillStyle = baseColor;
              ctx.fillRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
              
              ctx.strokeStyle = '#222222';
              ctx.lineWidth = 2;
              ctx.strokeRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
            }
          }
          
          // Add visual damage effects
          if (enemy.smoking || enemy.onFire) {
            // Determine effect size based on aircraft type
            let effectSize;
            if (enemy.type === 'bf109') {
              effectSize = 8 * SCALE * game.camera.zoom * 0.3; // Smaller effects for fighters
            } else {
              effectSize = (24 * SCALE * game.camera.zoom * (assets.loaded.ju88 ? assets.ju88.naturalWidth / assets.ju88.naturalHeight : 1.5)) * 0.3;
            }
            
            const effectX = Math.random() * effectSize * 0.8 - effectSize * 0.4;
            const effectY = -effectSize * 0.3 + Math.random() * effectSize * 0.2;
            
            if (enemy.onFire) {
              // Fire effect - orange/red particles
              const numParticles = enemy.type === 'bf109' ? 2 : 3;
              for (let i = 0; i < numParticles; i++) {
                const fireX = effectX + (Math.random() - 0.5) * effectSize;
                const fireY = effectY + (Math.random() - 0.5) * effectSize * 0.5;
                const fireSize = effectSize * 0.2 * Math.random();
                
                ctx.fillStyle = i % 2 === 0 ? '#FF4500' : '#FF8C00';
                ctx.beginPath();
                ctx.arc(fireX, fireY, fireSize, 0, Math.PI * 2);
                ctx.fill();
              }
            } else if (enemy.smoking) {
              // Smoke effect - grey particles
              const numParticles = enemy.type === 'bf109' ? 1 : 2;
              for (let i = 0; i < numParticles; i++) {
                const smokeX = effectX + (Math.random() - 0.5) * effectSize;
                const smokeY = effectY + (Math.random() - 0.5) * effectSize * 0.5;
                const smokeSize = effectSize * 0.15 * Math.random();
                
                ctx.fillStyle = `rgba(105, 105, 105, ${0.4 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
          
          // Health bar removed - keeping invisible as requested
          // const barWidth = enemyWidth;
          // const barHeight = 4;
          // const barY = -enemyHeight/2 - 10;
          // 
          // // Background
          // ctx.fillStyle = '#FF0000';
          // ctx.fillRect(-barWidth/2, barY, barWidth, barHeight);
          // 
          // // Health
          // const healthRatio = enemy.health / enemy.maxHealth;
          // ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.25 ? '#FFFF00' : '#FF0000');
          // ctx.fillRect(-barWidth/2, barY, barWidth * healthRatio, barHeight);
          
          ctx.restore();
        });
        
        // Render enemy projectiles
        if (game.enemyProjectiles) {
          game.enemyProjectiles.forEach(proj => {
            const screenPos = worldToScreen(proj.x, proj.y);
            const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
            const angle = Math.atan2(proj.vy, proj.vx);
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(angle);
            
            if (proj.type === 'tracer' && assets.loaded.tracer && assets.tracer) {
              // Scale tracer sprite by speed (longer/fatter at higher speed)
              const speedRatio = Math.max(0.2, Math.min(1.0, speed / (proj.initialSpeed || speed || 1)));
              const tracerLength = Math.max(8, TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom);
              const tracerWidth = Math.max(3, TRACER_WIDTH * (0.6 + 0.4 * speedRatio) * SCALE * game.camera.zoom);
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else if (proj.type === 'bullet' && assets.loaded.bullet && assets.bullet) {
              const size = BULLET_SIZE * SCALE * game.camera.zoom;
              ctx.drawImage(assets.bullet, -size/2, -size/2, size, size);
            } else {
              // Fallback
              if (proj.type === 'tracer') {
                const speedRatio = Math.max(0.2, Math.min(1.0, speed / (proj.initialSpeed || speed || 1)));
                const tracerLength = Math.max(8, TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom);
                const tracerWidth = Math.max(3, TRACER_WIDTH * (0.6 + 0.4 * speedRatio) * SCALE * game.camera.zoom);
                ctx.fillStyle = '#FFFF66';
                ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              } else {
                const bulletSize = Math.max(3, BULLET_SIZE * SCALE * game.camera.zoom);
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
              }
            }
            
            ctx.restore();
          });
        }
        
        // Render explosions
        game.explosions.forEach(explosion => {
          const screenPos = worldToScreen(explosion.x, explosion.y);
          const progress = explosion.time / explosion.duration;
          const isHitExplosion = explosion.type === 'hit';
          
          let size;
          if (isHitExplosion) {
            // Hit explosions stay small and flash bright
            size = explosion.size * SCALE * game.camera.zoom * (1 + progress * 0.5);
          } else {
            // Destruction explosions expand dramatically
            size = explosion.size * SCALE * game.camera.zoom * (1 + progress * 2);
          }
          
          const alpha = 1 - progress; // Fade out
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          
          if (assets.loaded.explosion && assets.explosion && !isHitExplosion) {
            // Use explosion sprite only for large explosions
            ctx.globalAlpha = alpha;
            ctx.drawImage(assets.explosion, -size/2, -size/2, size, size);
          } else {
            // Fallback explosion or hit explosion
            ctx.globalAlpha = alpha;
            
            if (isHitExplosion) {
              // Small bright flash for hits
              const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
              gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`); // Bright white center
              gradient.addColorStop(0.3, `rgba(255, 255, 0, ${alpha})`); // Yellow
              gradient.addColorStop(0.6, `rgba(255, 150, 0, ${alpha})`); // Orange
              gradient.addColorStop(1, `rgba(255, 0, 0, 0)`); // Transparent edge
              
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(0, 0, size/2, 0, Math.PI * 2);
              ctx.fill();
            } else {
              // Large fireball for destruction
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
            gradient.addColorStop(0, `rgba(255, 255, 0, ${alpha})`); // Yellow center
            gradient.addColorStop(0.3, `rgba(255, 100, 0, ${alpha})`); // Orange
            gradient.addColorStop(0.7, `rgba(255, 0, 0, ${alpha})`); // Red
            gradient.addColorStop(1, `rgba(50, 0, 0, 0)`); // Transparent edge
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI * 2);
            ctx.fill();
            }
          }
          
          ctx.restore();
        });
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          ctx.restore();
        }
        
        // Debug: Draw pixel collision outlines (press 'V' to toggle)
        if (game.showPixelCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
          ctx.lineWidth = 1;
          
          // Draw player aircraft pixel bounds
          const playerPos = aircraft.getPosition();
          const playerAngle = aircraft.getAngle();
          const playerScreenPos = worldToScreen(playerPos.x, playerPos.y);
          
          let playerSprite;
          if (game.inverted && game.gearDown) {
            playerSprite = assets.spitfireInvertedGear;
          } else if (game.inverted && !game.gearDown) {
            playerSprite = assets.spitfireInverted;
          } else if (!game.inverted && game.gearDown) {
            playerSprite = assets.spitfireGear;
          } else {
            playerSprite = assets.spitfire;
          }
          
          if (playerSprite) {
            const scale = 0.4 * game.camera.zoom;
            const w = playerSprite.naturalWidth * scale;
            const h = playerSprite.naturalHeight * scale;
            
            ctx.translate(playerScreenPos.x, playerScreenPos.y);
            ctx.rotate(playerAngle);
            ctx.strokeRect(-w/2, -h/2, w, h);
            ctx.resetTransform();
          }
          
          // Draw enemy aircraft pixel bounds
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            const pos = enemy.body.getPosition();
            const angle = enemy.body.getAngle();
            const screenPos = worldToScreen(pos.x, pos.y);
            
            if (assets.loaded.ju88 && assets.ju88) {
              const originalAspectRatio = assets.ju88.naturalWidth / assets.ju88.naturalHeight;
              const baseEnemySize = 24 * SCALE * game.camera.zoom;
              const enemyWidth = baseEnemySize * originalAspectRatio;
              const enemyHeight = baseEnemySize;
              
              ctx.translate(screenPos.x, screenPos.y);
              ctx.rotate(angle);
              ctx.strokeRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
              ctx.resetTransform();
            }
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed * VISUAL_SCALE); // Convert to visual speed
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        // Altitude: distance above ground (converted to visual altitude)
        document.getElementById('altitude').textContent = Math.max(0, Math.round(-pos.y * VISUAL_SCALE));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Add landing gear and ground status indicators
        const gearStatus = document.querySelector('.gear-status') || (() => {
          const div = document.createElement('div');
          div.className = 'gear-status';
          div.style.cssText = 'position:fixed;top:120px;left:20px;color:#fff;font-size:14px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);';
          document.body.appendChild(div);
          return div;
        })();
        
        let statusText = `Gear: ${game.gearDown ? 'DOWN' : 'UP'}`;
        if (game.onGround) {
          statusText += ` | On Ground (${Math.round(game.groundSpeed * VISUAL_SCALE)} m/s)`;
        }
        gearStatus.textContent = statusText;
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'üí• CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          updateProjectiles(timeStep);
          updateEnemies(timeStep);
          updateEnemySpawning(); // Handle continuous spawning and cleanup
          updateExplosions(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start the game loop at the end of initializeGame
      console.log('Starting flight simulator...');
      requestAnimationFrame(gameLoop);
      }
      
      // Do not auto-start; wait for Start button click (handled above)
      
    })();
  </script>
  <script src="/web/js/projectiles.js"></script>
</body>
</html>