<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle • A: Pitch Up • D: Pitch Down • Q/E: Zoom • Arrows: Roll • R: Reset
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants
      const SCALE = 20; // pixels per meter
      const WORLD_WIDTH = 4000; // meters
      const WORLD_HEIGHT = 3000; // meters
      
      // Physics world
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // IMAGES
      // =============================================================================
      
      const assets = {
        map: new Image(),
        spitfire: new Image(),
        loaded: { map: false, spitfire: false }
      };
      
      assets.map.onload = () => {
        assets.loaded.map = true;
        console.log('✓ Map loaded:', assets.map.naturalWidth, 'x', assets.map.naturalHeight);
      };
      
      assets.map.onerror = (e) => {
        console.error('✗ Map failed to load:', e);
      };
      
      assets.spitfire.onload = () => {
        assets.loaded.spitfire = true;
        console.log('✓ Spitfire loaded:', assets.spitfire.naturalWidth, 'x', assets.spitfire.naturalHeight);
      };
      
      assets.spitfire.onerror = (e) => {
        console.error('✗ Spitfire failed to load:', e);
      };
      
      // Load images - try both relative paths
      const mapPath = '../assets/sprites/environment/map.png';
      const spitfirePath = '../assets/sprites/aircraft/player/Spitfire facing right.png';
      
      console.log('Attempting to load:', mapPath);
      console.log('Attempting to load:', spitfirePath);
      
      assets.map.src = mapPath;
      assets.spitfire.src = spitfirePath;
      
      // Test if images can be reached by trying to fetch them
      fetch(mapPath)
        .then(response => console.log('Map fetch result:', response.status, response.statusText))
        .catch(err => {
          console.error('Map fetch failed:', err);
          // Try alternative path
          console.log('Trying alternative path...');
          assets.map.src = './assets/sprites/environment/map.png';
        });
        
      fetch(spitfirePath)
        .then(response => console.log('Spitfire fetch result:', response.status, response.statusText))
        .catch(err => {
          console.error('Spitfire fetch failed:', err);
          // Try alternative path
          console.log('Trying alternative spitfire path...');
          assets.spitfire.src = './assets/sprites/aircraft/player/Spitfire facing right.png';
        });
      
      console.log('Loading assets...');
      console.log('Current page URL:', window.location.href);
      console.log('Base URL:', window.location.origin + window.location.pathname);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.2, maxZoom: 3.0 },
        throttle: 0.4,
        keys: new Set()
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        game.keys.add(e.key.toLowerCase());
        if (['w','s','a','d','q','e','arrowleft','arrowright','r'].includes(e.key.toLowerCase())) {
          e.preventDefault();
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(200, 400),
        angle: 0,
        linearDamping: 0.1,
        angularDamping: 0.9
      });
      
      aircraft.createFixture({
        shape: pl.Box(8, 2.5), // 16m x 5m aircraft
        density: 20, // kg/m²
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground (simple rectangle for collision)
      const ground = world.createBody({
        type: 'static',
        position: pl.Vec2(0, 800)
      });
      
      ground.createFixture({
        shape: pl.Box(WORLD_WIDTH, 50),
        friction: 1.0,
        restitution: 0.1
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(200, 400), 0);
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Flight controls
        const torque = 12000;
        if (pitchUp) aircraft.applyTorque(-torque, true);
        if (pitchDown) aircraft.applyTorque(torque, true);
        if (rollLeft) aircraft.applyTorque(-torque * 0.5, true);
        if (rollRight) aircraft.applyTorque(torque * 0.5, true);
        
        // Thrust
        const maxThrust = 30000;
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // Simple aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        if (speed > 1) {
          const airDensity = 1.225;
          const wingArea = 20;
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified)
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          const liftCoeff = Math.sin(aoa * 2) * 1.5;
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag
          const dragCoeff = 0.08 + Math.abs(liftCoeff) * 0.1;
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background
        if (assets.loaded.map) {
          const mapW = WORLD_WIDTH * SCALE * game.camera.zoom;
          const mapH = WORLD_HEIGHT * SCALE * game.camera.zoom;
          const mapPos = worldToScreen(-WORLD_WIDTH/2, -WORLD_HEIGHT/2);
          ctx.drawImage(assets.map, mapPos.x, mapPos.y, mapW, mapH);
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        if (assets.loaded.spitfire) {
          const scale = 0.4 * game.camera.zoom;
          const w = assets.spitfire.naturalWidth * scale;
          const h = assets.spitfire.naturalHeight * scale;
          ctx.drawImage(assets.spitfire, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          ctx.fillStyle = '#4169E1';
          ctx.strokeStyle = '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
        }
        
        ctx.restore();
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed);
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        document.getElementById('altitude').textContent = Math.round(Math.max(0, 750 - pos.y));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start
      console.log('Starting flight simulator...');
      gameLoop(performance.now());
      
    })();
  </script>
</body>
</html>