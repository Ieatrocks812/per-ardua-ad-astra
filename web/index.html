<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle ‚Ä¢ A/D: Fast Pitch ‚Ä¢ Q/E: Slow Pitch ‚Ä¢ Arrows: Roll ‚Ä¢ F: Flip ‚Ä¢ G: Gear ‚Ä¢ Space: Fire ‚Ä¢ Mouse Wheel: Zoom ‚Ä¢ C: Physics Debug ‚Ä¢ V: Pixel Debug ‚Ä¢ R: Reset
  </div>

  <!-- Start Screen -->
  <div id="startScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #2F4F4F 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    font-family: 'Arial', sans-serif;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  ">
    <h1 style="font-size: 4rem; margin-bottom: 1rem; text-align: center;">
      Per Ardua ad Astra
    </h1>
    <p style="font-size: 1.5rem; margin-bottom: 3rem; text-align: center; opacity: 0.9;">
      "Through Adversity to the Stars"
    </p>
    <div style="display: flex; gap: 2rem; flex-direction: column; align-items: center;">
      <button id="startButton" style="
        font-size: 1.5rem;
        padding: 1rem 3rem;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid white;
        color: white;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        text-shadow: none;
        font-weight: bold;
      " onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='scale(1.1)'" 
         onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='scale(1)'">
        CAMPAIGN
      </button>
      
      <button id="freeFlightButton" style="
        font-size: 1.2rem;
        padding: 0.8rem 2rem;
        background: rgba(52, 152, 219, 0.2);
        border: 2px solid #3498db;
        color: #3498db;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        text-shadow: none;
        font-weight: bold;
      " onmouseover="this.style.background='rgba(52,152,219,0.3)'; this.style.transform='scale(1.1)'" 
         onmouseout="this.style.background='rgba(52,152,219,0.2)'; this.style.transform='scale(1)'">
        FREE FLIGHT
      </button>
      
      <button id="debugButton" style="
        font-size: 1.2rem;
        padding: 0.8rem 2rem;
        background: rgba(255, 165, 0, 0.2);
        border: 2px solid orange;
        color: orange;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        text-shadow: none;
        font-weight: bold;
      " onmouseover="this.style.background='rgba(255,165,0,0.3)'; this.style.transform='scale(1.1)'" 
         onmouseout="this.style.background='rgba(255,165,0,0.2)'; this.style.transform='scale(1)'">
        üõ†Ô∏è DEBUG MODE
      </button>
    </div>
    <div style="margin-top: 2rem; text-align: center; opacity: 0.7; font-size: 0.9rem;">
      <p>üéÆ Use W/S for throttle, A/D for pitch, arrows for roll</p>
      <p>üî´ Press SPACE to fire wing guns with tracers and casings</p>
      <p>‚úàÔ∏è Realistic flight physics with altitude effects above 5000m</p>
    </div>
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <!-- Load game modules -->
  <script src="js/projectiles.js"></script>
  <script src="js/save-system.js"></script>
  <script src="js/mission-manager.js"></script>
  <script src="js/upgrade-system.js"></script>
  <script src="js/ui-screens.js"></script>
  <script>
    (() => {
      'use strict';
      
      // Game state
      let gameStarted = false;
      let debugMode = false;
      
      // Start screen functionality - Campaign mode
      document.getElementById('startButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('üöÄ Starting campaign mode...');
        
        try {
          // Initialize audio system after user interaction
          initAudio();
          
          // Resume audio context if needed
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('üîä Audio context resumed');
            });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Audio setup failed, continuing without sound:', error);
        }
        
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        debugMode = false;
        window.campaignMode = true;
        // Show mission selection
        window.uiScreens.showMissionSelect();
      });
      
      // Free flight mode
      document.getElementById('freeFlightButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('‚úàÔ∏è Starting free flight mode...');
        
        try {
          // Initialize audio system after user interaction
          initAudio();
          
          // Resume audio context if needed
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('üîä Audio context resumed');
            });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Audio setup failed, continuing without sound:', error);
        }
        
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        debugMode = false;
        window.campaignMode = false;
        // Mark game start time for spawn protection
        window.gameStartTime = performance.now();
        initializeGame();
      });

      // Debug mode functionality
      document.getElementById('debugButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('üõ†Ô∏è Starting debug mode...');
        
        try {
          // Initialize audio system after user interaction
          initAudio();
          
          // Resume audio context if needed
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('üîä Audio context resumed');
            });
          }
        } catch (error) {
          console.log('‚ö†Ô∏è Audio setup failed, continuing without sound:', error);
        }
        
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        debugMode = true;
        // Mark game start time for spawn protection
        window.gameStartTime = performance.now();
        initializeDebugMode();
      });
      
      // Initialize game function (called directly or from UI)
      window.initializeGame = function initializeGame() {
      // Spawn protection for first few seconds (ensure game exists)
      try { game.spawnShieldUntil = performance.now() + 4000; } catch(e) { /* game not yet defined here; will set after state init */ }

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants - Physics world scaling for higher speeds (more reasonable scaling)
      const PHYSICS_SCALE = 0.5; // Physics objects are 2x smaller for higher speeds
      const VISUAL_SCALE = 2.0; // Visual rendering compensates with 2x scaling  
      const SCALE = 20 * VISUAL_SCALE; // Base pixels per meter (40 after scaling)
      const WORLD_WIDTH = 4000 * PHYSICS_SCALE; // Physics: 400 units (visually 4000m)
      const WORLD_HEIGHT = 3000 * PHYSICS_SCALE; // Physics: 300 units (visually 3000m)
      const MAP_BOTTOM_ALTITUDE = 300; // Physics: 300 units above ground (visually 600m)
      
      // CRITICAL: Set Planck.js settings BEFORE creating the world
      // This is essential to remove the 240 m/s speed cap
      console.log('üîß Setting Box2D velocity limits BEFORE world creation...');
      
      if (typeof planck !== 'undefined' && planck.Settings) {
        console.log('üìä Original planck.Settings:', { 
          maxTranslation: planck.Settings.maxTranslation, 
          velocityThreshold: planck.Settings.velocityThreshold
        });
        // Set extremely high limits to remove all speed caps
        planck.Settings.maxTranslation = 50.0; // Very high limit
        planck.Settings.velocityThreshold = 50.0; // Increase velocity threshold
        console.log('‚úÖ Updated planck.Settings for unlimited speed');
      }
      
      if (typeof pl !== 'undefined' && pl.Settings) {
        console.log('üìä Original pl.Settings:', { 
          maxTranslation: pl.Settings.maxTranslation,
          velocityThreshold: pl.Settings.velocityThreshold
        });
        // Set extremely high limits
        pl.Settings.maxTranslation = 50.0; // Extremely high
        pl.Settings.velocityThreshold = 50.0; // Remove velocity sleeping
        console.log('‚úÖ Updated pl.Settings:', { 
          maxTranslation: pl.Settings.maxTranslation,
          velocityThreshold: pl.Settings.velocityThreshold
        });
      }
      
      // NOW create the physics world with the updated settings
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        tileableMap: null,
        spitfire: null,
        spitfireInverted: null,
        spitfireGear: null,
        spitfireInvertedGear: null,
        bullet: null,
        tracer: null,
        casing: null,
        ju88: null,
        bf109Left: null,
        explosion: null,
        loaded: { map: false, tileableMap: false, spitfire: false, spitfireInverted: false, spitfireGear: false, spitfireInvertedGear: false, bullet: false, tracer: false, casing: false, ju88: false, bf109Left: false, explosion: false }
      };
      
      // Audio system
      let audioContext = null;
      const sounds = {
        gunfire: null,
        explosion: null,
        hit: null
      };
      
      // Pixel-perfect collision system
      const spritePixelData = new Map();
      const spriteColoredBounds = new Map(); // Store actual colored bounds for each sprite
      
      function extractSpritePixelData(image, name) {
        if (!image || !image.complete || image.naturalWidth === 0) return null;
        
        // Create a temporary canvas to extract pixel data
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = image.naturalWidth;
        tempCanvas.height = image.naturalHeight;
        
        // Draw the image to extract pixel data
        tempCtx.drawImage(image, 0, 0);
        
        try {
          const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
          const pixelData = {
            width: tempCanvas.width,
            height: tempCanvas.height,
            data: imageData.data
          };
          
          // Calculate actual colored bounds (non-transparent pixels with color)
          let minX = tempCanvas.width, maxX = 0, minY = tempCanvas.height, maxY = 0;
          let hasColoredPixels = false;
          
          for (let y = 0; y < tempCanvas.height; y++) {
            for (let x = 0; x < tempCanvas.width; x++) {
              const idx = (y * tempCanvas.width + x) * 4;
              const red = imageData.data[idx];
              const green = imageData.data[idx + 1];
              const blue = imageData.data[idx + 2];
              const alpha = imageData.data[idx + 3];
              
              // Check for colored, opaque pixels
              const hasColor = (red > 10 || green > 10 || blue > 10);
              const isOpaque = alpha > 128;
              
              if (hasColor && isOpaque) {
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                hasColoredPixels = true;
              }
            }
          }
          
          // Store colored bounds
          const coloredBounds = hasColoredPixels ? {
            left: minX,
            right: maxX,
            top: minY,
            bottom: maxY,
            width: maxX - minX + 1,
            height: maxY - minY + 1
          } : {
            left: 0, right: tempCanvas.width - 1,
            top: 0, bottom: tempCanvas.height - 1,
            width: tempCanvas.width,
            height: tempCanvas.height
          };
          
          spritePixelData.set(name, pixelData);
          spriteColoredBounds.set(name, coloredBounds);
          console.log(`üéØ Extracted pixel data for ${name}: ${pixelData.width}x${pixelData.height}, colored bounds: ${coloredBounds.width}x${coloredBounds.height} at (${coloredBounds.left},${coloredBounds.top})`);
          return pixelData;
        } catch (error) {
          console.log(`‚ö†Ô∏è Failed to extract pixel data for ${name}:`, error);
          return null;
        }
      }
      
      function checkPixelCollision(projX, projY, enemy) {
        // Get enemy position and rotation
        const pos = enemy.body.getPosition();
        const angle = enemy.body.getAngle();
        
        // Get sprite and its pixel data based on enemy type
        let sprite, pixelData, spriteName;
        if (enemy.type === 'bf109') {
          // Always use bf109Left sprite (only one available)
          sprite = assets.bf109Left;
          spriteName = 'bf109Left';
          pixelData = spritePixelData.get(spriteName);
        } else {
          // Ju-88 bomber
          sprite = assets.ju88;
          spriteName = 'ju88';
          pixelData = spritePixelData.get('ju88');
        }
        
        if (!sprite || !pixelData) {
          // Fallback to distance-based collision if no pixel data
          const distance = Math.sqrt((projX - pos.x) * (projX - pos.x) + (projY - pos.y) * (projY - pos.y));
          return distance < (enemy.type === 'bf109' ? 6 : 15); // Smaller collision for fighters
        }
        
        // Calculate sprite dimensions in world space
        const originalAspectRatio = sprite.naturalWidth / sprite.naturalHeight;
        let baseEnemySize;
        if (enemy.type === 'bf109') {
          baseEnemySize = 16; // Doubled fighter size to match rendering
        } else {
          baseEnemySize = 24; // Larger bombers
        }
        const enemyWidth = baseEnemySize * originalAspectRatio;
        const enemyHeight = baseEnemySize;
        
        // Transform projectile position to local sprite coordinates
        // Account for the sprite transformations: translate, rotate, scale(-1, -1)
        const dx = projX - pos.x;
        const dy = projY - pos.y;
        
        // Reverse rotation (rotate by -angle)
        const cosA = Math.cos(-angle);
        const sinA = Math.sin(-angle);
        const rotatedX = dx * cosA - dy * sinA;
        const rotatedY = dx * sinA + dy * cosA;
        
        // Account for the scale(-1, -1) flip
        const flippedX = -rotatedX;
        const flippedY = -rotatedY;
        
        // Convert from world coordinates to sprite pixel coordinates
        // Sprite is rendered from -enemyWidth/2 to +enemyWidth/2, -enemyHeight/2 to +enemyHeight/2
        const spriteX = (flippedX + enemyWidth / 2) * (pixelData.width / enemyWidth);
        const spriteY = (flippedY + enemyHeight / 2) * (pixelData.height / enemyHeight);
        
        // Check if coordinates are within sprite bounds
        if (spriteX < 0 || spriteX >= pixelData.width || spriteY < 0 || spriteY >= pixelData.height) {
          return false;
        }
        
        // Get pixel at the calculated position
        const pixelIndex = (Math.floor(spriteY) * pixelData.width + Math.floor(spriteX)) * 4;
        const red = pixelData.data[pixelIndex];
        const green = pixelData.data[pixelIndex + 1];
        const blue = pixelData.data[pixelIndex + 2];
        const alpha = pixelData.data[pixelIndex + 3];
        
        // Debug: Log collision attempts and alpha values
        if (game.showPixelCollision) {
          console.log(`üéØ Enemy pixel check: sprite=${spriteName} pos=(${spriteX.toFixed(1)}, ${spriteY.toFixed(1)}) alpha=${alpha} hasColor=${red > 10 || green > 10 || blue > 10}`);
        }
        
        // Must have both significant alpha AND actual color content
        const hasColor = (red > 10 || green > 10 || blue > 10); // Not pure black/transparent
        const isOpaque = alpha > 128; // At least 50% opacity
        
        return hasColor && isOpaque;
      }
      
      function checkPlayerPixelCollision(projX, projY) {
        // Get player position and rotation
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        
        // Determine which player sprite to use based on current state
        let spriteName, sprite;
        if (game.inverted && game.gearDown) {
          spriteName = 'spitfireInvertedGear';
          sprite = assets.spitfireInvertedGear;
        } else if (game.inverted && !game.gearDown) {
          spriteName = 'spitfireInverted';
          sprite = assets.spitfireInverted;
        } else if (!game.inverted && game.gearDown) {
          spriteName = 'spitfireGear';
          sprite = assets.spitfireGear;
        } else {
          spriteName = 'spitfire';
          sprite = assets.spitfire;
        }
        
        const pixelData = spritePixelData.get(spriteName);
        
        if (!sprite || !pixelData) {
          // Fallback to very small distance-based collision if no pixel data
          const distance = Math.sqrt((projX - pos.x) * (projX - pos.x) + (projY - pos.y) * (projY - pos.y));
          console.log(`‚ö†Ô∏è Using fallback player collision (no pixel data). Distance: ${distance.toFixed(2)}, sprite: ${spriteName}, hasSprite: ${!!sprite}, hasPixelData: ${!!pixelData}`);
          return distance < 0.4; // Even smaller fallback - only 0.8m visual radius
        }
        
        // Use colored bounds instead of full sprite dimensions for much more accurate collision
        const coloredBounds = spriteColoredBounds.get(spriteName);
        const basePlayerSize = 0.4; // Restored to original size since timing was the real issue
        
        let playerWidth, playerHeight, boundsOffsetX, boundsOffsetY;
        if (coloredBounds) {
          // Use actual colored pixel bounds
          playerWidth = coloredBounds.width * basePlayerSize;
          playerHeight = coloredBounds.height * basePlayerSize;
          
          // Calculate offset from sprite center to colored bounds center
          const coloredCenterX = (coloredBounds.left + coloredBounds.right) / 2;
          const coloredCenterY = (coloredBounds.top + coloredBounds.bottom) / 2;
          const spriteCenterX = sprite.naturalWidth / 2;
          const spriteCenterY = sprite.naturalHeight / 2;
          
          boundsOffsetX = (coloredCenterX - spriteCenterX) * basePlayerSize;
          boundsOffsetY = (coloredCenterY - spriteCenterY) * basePlayerSize;
        } else {
          // Fallback to full sprite (shouldn't happen)
          playerWidth = sprite.naturalWidth * basePlayerSize;
          playerHeight = sprite.naturalHeight * basePlayerSize;
          boundsOffsetX = 0;
          boundsOffsetY = 0;
        }
        
        // Transform projectile position to local sprite coordinates
        // Account for the offset between sprite center and colored bounds center
        const dx = projX - (pos.x + boundsOffsetX);
        const dy = projY - (pos.y + boundsOffsetY);
        
        // Reverse rotation (rotate by -angle)
        const cosA = Math.cos(-angle);
        const sinA = Math.sin(-angle);
        const rotatedX = dx * cosA - dy * sinA;
        const rotatedY = dx * sinA + dy * cosA;
        
        // Convert from world coordinates to sprite pixel coordinates
        // Map to the colored bounds within the sprite
        if (coloredBounds) {
          const localX = rotatedX + playerWidth / 2;
          const localY = rotatedY + playerHeight / 2;
          
          const spriteX = coloredBounds.left + (localX / playerWidth) * coloredBounds.width;
          const spriteY = coloredBounds.top + (localY / playerHeight) * coloredBounds.height;
          
          // Check if coordinates are within colored bounds
          if (spriteX < coloredBounds.left || spriteX > coloredBounds.right || 
              spriteY < coloredBounds.top || spriteY > coloredBounds.bottom) {
            return false;
          }
          
          // Get pixel at the calculated position
          const pixelIndex = (Math.floor(spriteY) * pixelData.width + Math.floor(spriteX)) * 4;
          const red = pixelData.data[pixelIndex];
          const green = pixelData.data[pixelIndex + 1];
          const blue = pixelData.data[pixelIndex + 2];
          const alpha = pixelData.data[pixelIndex + 3];
          
          // Debug logging
          if (game.showPixelCollision) {
            console.log(`üéØ Colored bounds check: sprite=${spriteName} bounds=(${spriteX.toFixed(1)}, ${spriteY.toFixed(1)}) alpha=${alpha} hasColor=${red > 10 || green > 10 || blue > 10} rgb=(${red},${green},${blue}) coloredBounds=${coloredBounds.left}-${coloredBounds.right},${coloredBounds.top}-${coloredBounds.bottom}`);
          }
          
          // Must have both significant alpha AND actual color content
          const hasColor = (red > 10 || green > 10 || blue > 10);
          const isOpaque = alpha > 128;
          
          return hasColor && isOpaque;
        } else {
          // Fallback to old method
          const spriteX = (rotatedX + playerWidth / 2) * (pixelData.width / playerWidth);
          const spriteY = (rotatedY + playerHeight / 2) * (pixelData.height / playerHeight);
          
          if (spriteX < 0 || spriteX >= pixelData.width || spriteY < 0 || spriteY >= pixelData.height) {
            return false;
          }
          
          const pixelIndex = (Math.floor(spriteY) * pixelData.width + Math.floor(spriteX)) * 4;
          const red = pixelData.data[pixelIndex];
          const green = pixelData.data[pixelIndex + 1];
          const blue = pixelData.data[pixelIndex + 2];
          const alpha = pixelData.data[pixelIndex + 3];
          
          const hasColor = (red > 10 || green > 10 || blue > 10);
          const isOpaque = alpha > 128;
          
          return hasColor && isOpaque;
        }

      }

      // Pixel-perfect plane vs plane overlap test
      function checkPlanePlanePixelOverlap(enemy) {
        // Sample a small grid of points around the midpoint between planes
        const playerPos = aircraft.getPosition();
        const enemyPos = enemy.body.getPosition();
        
        // Estimate sprite world sizes
        // Player
        let playerSprite;
        if (game.inverted && game.gearDown) playerSprite = assets.spitfireInvertedGear;
        else if (game.inverted && !game.gearDown) playerSprite = assets.spitfireInverted;
        else if (!game.inverted && game.gearDown) playerSprite = assets.spitfireGear;
        else playerSprite = assets.spitfire;
        const basePlayerSize = 0.25; // Match the hitbox from pixel collision
        const playerWidth = playerSprite ? playerSprite.naturalWidth * basePlayerSize : 8;
        const playerHeight = playerSprite ? playerSprite.naturalHeight * basePlayerSize : 3;
        
        // Enemy
        let enemySprite;
        if (enemy.type === 'bf109') {
          enemySprite = assets.bf109Left; // Only one sprite available
        } else {
          enemySprite = assets.ju88;
        }
        const enemyAspect = enemySprite ? (enemySprite.naturalWidth / Math.max(1, enemySprite.naturalHeight)) : 3;
        const enemyBase = enemy.type === 'bf109' ? 16 : 24;
        const enemyWidth = enemyBase * enemyAspect;
        const enemyHeight = enemyBase;
        
        // Define sampling region around the segment midpoint
        const midX = (playerPos.x + enemyPos.x) / 2;
        const midY = (playerPos.y + enemyPos.y) / 2;
        const sampleHalfW = Math.min(playerWidth, enemyWidth) * 0.6;
        const sampleHalfH = Math.min(playerHeight, enemyHeight) * 0.6;
        
        // Sample a coarse grid (7x7) for overlap
        const samples = 7;
        for (let ix = 0; ix < samples; ix++) {
          for (let iy = 0; iy < samples; iy++) {
            const tx = ix / (samples - 1); // 0..1
            const ty = iy / (samples - 1);
            const wx = midX + (tx - 0.5) * 2 * sampleHalfW;
            const wy = midY + (ty - 0.5) * 2 * sampleHalfH;
            // Both must have opaque pixel at this world point
            if (checkPlayerPixelCollision(wx, wy) && checkPixelCollision(wx, wy, enemy)) {
              return true;
            }
          }
        }
        return false;
      }
      
      // Create audio sounds programmatically
      function createGunfireSound() {
        const duration = 0.1;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Sharp crack sound with rapid decay
          data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 50) * Math.sin(t * 2000 * Math.PI);
        }
        
        return buffer;
      }
      
      function createExplosionSound() {
        const duration = 1.5;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Rumbling explosion with bass
          const noise = Math.random() * 2 - 1;
          const decay = Math.exp(-t * 2);
          const lowFreq = Math.sin(t * 100 * Math.PI) * 0.5;
          const midFreq = Math.sin(t * 500 * Math.PI) * 0.3;
          data[i] = (noise * 0.7 + lowFreq + midFreq) * decay;
        }
        
        return buffer;
      }
      
      function createHitSound() {
        const duration = 0.2;
        const sampleRate = audioContext.sampleRate;
        const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < buffer.length; i++) {
          const t = i / sampleRate;
          // Sharp metallic impact
          data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * Math.sin(t * 1500 * Math.PI);
        }
        
        return buffer;
      }
      
      function initAudio() {
        try {
          // Create audio context on first call
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('üîä Audio context created');
          }
          
          sounds.gunfire = createGunfireSound();
          sounds.explosion = createExplosionSound();
          sounds.hit = createHitSound();
          console.log('üîä Audio system initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Audio initialization failed:', error);
        }
      }
      
      function playSound(soundBuffer, volume = 1.0) {
        if (!soundBuffer || !audioContext) return;
        
        try {
          const source = audioContext.createBufferSource();
          const gainNode = audioContext.createGain();
          
          source.buffer = soundBuffer;
          gainNode.gain.value = volume;
          
          source.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          source.start();
        } catch (error) {
          console.log('‚ö†Ô∏è Sound playback failed:', error);
        }
      }
      
      async function loadAssets() {
        console.log('üéÆ Starting asset loading...');
        console.log('üìç Current location:', window.location.href);
        console.log('üìÇ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        console.log('üõ©Ô∏è Loading Ju-88 sprite from:', '../assets/sprites/aircraft/enemies/ju-88.png');
        console.log('üéØ Loading Tracer sprite from:', '../assets/sprites/effects/tracer_round.png');
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          tileableMap: [
            '../assets/sprites/environment/tileable map.png',
            './assets/sprites/environment/tileable map.png',
            '/assets/sprites/environment/tileable map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            './assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            '/assets/sprites/aircraft/player/Spitfire facing right with gear.png'
          ],
          spitfireInverted: [
            '../assets/sprites/aircraft/player/spitfire upside down.png',
            './assets/sprites/aircraft/player/spitfire upside down.png',
            '/assets/sprites/aircraft/player/spitfire upside down.png'
          ],
          spitfireGear: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ],
          spitfireInvertedGear: [
            '../assets/sprites/aircraft/player/spitfire upside down with gear.png',
            './assets/sprites/aircraft/player/spitfire upside down with gear.png',
            '/assets/sprites/aircraft/player/spitfire upside down with gear.png'
          ],
          bullet: [
            '../assets/sprites/effects/bullet.png',
            './assets/sprites/effects/bullet.png',
            '/assets/sprites/effects/bullet.png'
          ],
          tracer: [
            '../assets/sprites/effects/tracer_round.png',
            './assets/sprites/effects/tracer_round.png',
            '/assets/sprites/effects/tracer_round.png'
          ],
          casing: [
            '../assets/sprites/effects/casing.png',
            './assets/sprites/effects/casing.png',
            '/assets/sprites/effects/casing.png'
          ],
          ju88: [
            '../assets/sprites/aircraft/enemies/ju-88.png',
            './assets/sprites/aircraft/enemies/ju-88.png',
            '/assets/sprites/aircraft/enemies/ju-88.png'
          ],
          bf109Left: [
            '../assets/sprites/aircraft/enemies/bf-109 facing left.png',
            './assets/sprites/aircraft/enemies/bf-109 facing left.png',
            '/assets/sprites/aircraft/enemies/bf-109 facing left.png'
          ],

          explosion: [
            '../assets/sprites/effects/explosion.png',
            './assets/sprites/effects/explosion.png',
            '/assets/sprites/effects/explosion.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`üì∑ Trying ${name} from: ${currentPath}`);
              console.log(`üîó Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`‚úÖ ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`‚ùå ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load all assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('tileableMap', assetPaths.tileableMap),
            loadImage('spitfire', assetPaths.spitfire),
            loadImage('spitfireInverted', assetPaths.spitfireInverted),
            loadImage('spitfireGear', assetPaths.spitfireGear),
            loadImage('spitfireInvertedGear', assetPaths.spitfireInvertedGear),
                      loadImage('bullet', assetPaths.bullet),
          loadImage('tracer', assetPaths.tracer),
          loadImage('casing', assetPaths.casing),
          loadImage('ju88', assetPaths.ju88),
            loadImage('bf109Left', assetPaths.bf109Left),
          loadImage('explosion', assetPaths.explosion)
        ]);
          console.log('üéâ All assets loaded successfully!');
          console.log('üìä Final asset load status:', assets.loaded);
          
          // Specifically check gear sprites
          console.log('üõ¨ Gear sprite status:', {
            spitfireGear: { loaded: assets.loaded.spitfireGear, hasImage: !!assets.spitfireGear },
            spitfireInvertedGear: { loaded: assets.loaded.spitfireInvertedGear, hasImage: !!assets.spitfireInvertedGear }
          });
          console.log('üî´ Ordnance asset status:', {
            bullet: { loaded: assets.loaded.bullet, hasImage: !!assets.bullet },
            tracer: { loaded: assets.loaded.tracer, hasImage: !!assets.tracer },
            casing: { loaded: assets.loaded.casing, hasImage: !!assets.casing }
          });
          console.log('‚úàÔ∏è Enemy asset status:', {
            ju88: { loaded: assets.loaded.ju88, hasImage: !!assets.ju88, src: assets.ju88?.src },
            explosion: { loaded: assets.loaded.explosion, hasImage: !!assets.explosion }
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è Some assets failed to load:', error.message);
          console.log('üéÆ Game will continue with fallback graphics');
          console.log('üìä Asset load status after error:', assets.loaded);
        }
        
        // Initialize audio system (moved to user interaction)
        // initAudio();
        
        // Extract pixel data for all aircraft sprites
        if (assets.loaded.ju88 && assets.ju88) {
          extractSpritePixelData(assets.ju88, 'ju88');
        }
        if (assets.loaded.bf109Left && assets.bf109Left) {
          extractSpritePixelData(assets.bf109Left, 'bf109Left');
        }

        if (assets.loaded.spitfire && assets.spitfire) {
          extractSpritePixelData(assets.spitfire, 'spitfire');
        }
        if (assets.loaded.spitfireInverted && assets.spitfireInverted) {
          extractSpritePixelData(assets.spitfireInverted, 'spitfireInverted');
        }
        if (assets.loaded.spitfireGear && assets.spitfireGear) {
          extractSpritePixelData(assets.spitfireGear, 'spitfireGear');
        }
        if (assets.loaded.spitfireInvertedGear && assets.spitfireInvertedGear) {
          extractSpritePixelData(assets.spitfireInvertedGear, 'spitfireInvertedGear');
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // Debug: Check asset loading status immediately
      console.log('üîç Assets object at startup:', assets);
      console.log('üîç Asset loaded status:', assets.loaded);
      
      // Check asset loading status after a delay
      setTimeout(() => {
        console.log('üìä Asset status after 2 seconds:', {
          loaded: assets.loaded,
          hasImages: {
            map: !!assets.map,
            spitfire: !!assets.spitfire,
            ju88: !!assets.ju88
          }
        });
      }, 2000);
      
      // Debug: Log initial game state
      setTimeout(() => {
        console.log('üöÄ Initial game state at startup:', {
          inverted: game.inverted,
          gearDown: game.gearDown,
          expectedSprite: 'Should be normal Spitfire facing right (no gear)'
        });
      }, 1000);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.05, maxZoom: 9.0 }, // Much further zoom out (0.05 instead of 0.2)
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        showPixelCollision: false,
        crashed: false,
        playerHealth: 5,
        playerMaxHealth: 5,
        spawnShieldUntil: 0,
        inverted: false,
        gearDown: false,
        onGround: false, // Track if aircraft is on ground
        groundSpeed: 0, // Track ground speed for takeoff/landing
        projectiles: [], // bullets and tracers
        casings: [], // ejected shells
        enemies: [], // enemy aircraft
        explosions: [], // explosion effects
        enemyProjectiles: [], // enemy bullets
        playerCollisionCooldownUntil: 0,
        // Mission system integration
        player: null, // Will be set to aircraft body
        missionActive: false,
        enemyIdentificationEnabled: false,
        weaponConfig: null,
        dialogueSystem: null,
        debug: {
          showMenu: false,
          godMode: false,
          enemiesStopFiring: false,
          showFPS: false,
          showPhysicsInfo: false,
          unlimitedAmmo: false,
          noRecoil: false,
          enemiesStopMoving: false,
          showConsole: false,
          isPaused: false,
          mouseInspect: false,
          hoverData: null,
          showSpriteBounds: false,
          showPlayerHitbox: false
        },
        debugConsole: {
          messages: [],
          maxMessages: 50
        }
      };
      // Ensure spawn shield is set after game object exists
      if (!game.spawnShieldUntil || game.spawnShieldUntil < performance.now()) {
        game.spawnShieldUntil = performance.now() + 4000;
      }
      
      // Override console.log to capture debug messages
      const originalConsoleLog = console.log;
      console.log = function(...args) {
        // Call original console.log
        originalConsoleLog.apply(console, args);
        
        // Capture for debug display
        const message = args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' ');
        
        const timestamp = new Date().toLocaleTimeString();
        game.debugConsole.messages.push({
          time: timestamp,
          content: message
        });
        
        // Keep only the last N messages
        if (game.debugConsole.messages.length > game.debugConsole.maxMessages) {
          game.debugConsole.messages.shift();
        }
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      // Mouse handling for debug inspection
      canvas.addEventListener('mousemove', (e) => {
        if (!game.debug.mouseInspect) return;
        
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Convert screen coordinates to world coordinates
        const worldX = (mouseX - canvasWidth/2) / game.camera.zoom + game.camera.x;
        const worldY = (mouseY - canvasHeight/2) / game.camera.zoom + game.camera.y;
        
        game.debug.hoverData = { worldX, worldY, screenX: mouseX, screenY: mouseY };
        
        // Check what objects are under the mouse
        let hoverObject = null;
        
        // Check player
        const playerPos = aircraft.getPosition();
        const playerDist = Math.sqrt((worldX - playerPos.x)**2 + (worldY - playerPos.y)**2);
        if (playerDist < 10) {
          const vel = aircraft.getLinearVelocity();
          hoverObject = {
            type: 'player',
            position: playerPos,
            velocity: vel,
            speed: Math.sqrt(vel.x*vel.x + vel.y*vel.y),
            angle: aircraft.getAngle(),
            health: game.playerHealth
          };
        }
        
        // Check enemies
        if (!hoverObject) {
          for (const enemy of game.enemies) {
            if (enemy.destroyed) continue;
            const pos = enemy.body.getPosition();
            const dist = Math.sqrt((worldX - pos.x)**2 + (worldY - pos.y)**2);
            if (dist < (enemy.type === 'ju88' ? 20 : 10)) {
              const vel = enemy.body.getLinearVelocity();
              hoverObject = {
                type: 'enemy',
                enemyType: enemy.type,
                position: pos,
                velocity: vel,
                speed: Math.sqrt(vel.x*vel.x + vel.y*vel.y),
                angle: enemy.body.getAngle(),
                health: enemy.health,
                aiState: enemy.aiState || 'none'
              };
              break;
            }
          }
        }
        
        game.debug.hoverData.object = hoverObject;
      });
      
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        game.keys.add(key);
        console.log('üéØ Key pressed:', key); // Debug key presses
        
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c','v','f','g',' '].includes(key)) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (key === 'c') {
          game.showCollision = !game.showCollision;
          console.log('üîç Physics collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
        
        // Toggle pixel collision debug view
        if (key === 'v') {
          game.showPixelCollision = !game.showPixelCollision;
          console.log('üéØ Pixel collision debug:', game.showPixelCollision ? 'ON' : 'OFF');
        }
        
        // Toggle debug menu
        if (key === 'h') {
          game.debug.showMenu = !game.debug.showMenu;
          console.log('üõ†Ô∏è Debug menu:', game.debug.showMenu ? 'OPEN' : 'CLOSED');
        }
        
        // Debug menu shortcuts (when debug menu is open)
        if (game.debug.showMenu) {
          if (key === '1') {
            game.debug.godMode = !game.debug.godMode;
            console.log('üõ°Ô∏è God Mode:', game.debug.godMode ? 'ON' : 'OFF');
          }
          if (key === '2') {
            game.debug.enemiesStopFiring = !game.debug.enemiesStopFiring;
            console.log('üî´ Enemies Stop Firing:', game.debug.enemiesStopFiring ? 'ON' : 'OFF');
          }
          if (key === '3') {
            game.debug.showFPS = !game.debug.showFPS;
            console.log('üìä Show FPS:', game.debug.showFPS ? 'ON' : 'OFF');
          }
          if (key === '4') {
            game.debug.showPhysicsInfo = !game.debug.showPhysicsInfo;
            console.log('‚ö° Show Physics Info:', game.debug.showPhysicsInfo ? 'ON' : 'OFF');
          }
          if (key === '5') {
            game.debug.unlimitedAmmo = !game.debug.unlimitedAmmo;
            console.log('üéØ Unlimited Ammo:', game.debug.unlimitedAmmo ? 'ON' : 'OFF');
          }
          if (key === '6') {
            game.debug.noRecoil = !game.debug.noRecoil;
            console.log('üéØ No Recoil:', game.debug.noRecoil ? 'ON' : 'OFF');
          }
          if (key === '7') {
            game.debug.enemiesStopMoving = !game.debug.enemiesStopMoving;
            console.log('‚úàÔ∏è Enemies Stop Moving:', game.debug.enemiesStopMoving ? 'ON' : 'OFF');
          }
          if (key === '8') {
            // Spawn enemy formation manually
            spawnEnemyFormation();
            console.log('‚úàÔ∏è Spawned enemy formation');
          }
          if (key === '9') {
            // Clear all enemies
            game.enemies.forEach(enemy => destroyEnemy(enemy));
            game.enemies = [];
            console.log('üí• Cleared all enemies');
          }
          if (key === '0') {
            // Full heal player
            game.playerHealth = game.playerMaxHealth;
            game.crashed = false;
            console.log('‚ù§Ô∏è Player fully healed');
          }
          if (key === 'equal' || key === 'plus') {
            // Increase max health (debug only)
            game.playerMaxHealth++;
            game.playerHealth = game.playerMaxHealth; // Also heal to new max
            console.log(`‚ù§Ô∏è Max health increased to ${game.playerMaxHealth}`);
          }
          if (key === 'minus') {
            // Decrease max health (debug only)
            if (game.playerMaxHealth > 1) {
              game.playerMaxHealth--;
              game.playerHealth = Math.min(game.playerHealth, game.playerMaxHealth);
              console.log(`‚ù§Ô∏è Max health decreased to ${game.playerMaxHealth}`);
            }
          }
          if (key === 'c') {
            // Toggle console display (different from collision debug)
            game.debug.showConsole = !game.debug.showConsole;
            console.log('üìú Debug console:', game.debug.showConsole ? 'VISIBLE' : 'HIDDEN');
          }
          if (key === 'p') {
            // Pause/unpause game
            game.debug.isPaused = !game.debug.isPaused;
            console.log('‚è∏Ô∏è Game paused:', game.debug.isPaused ? 'YES' : 'NO');
          }
          if (key === 'm') {
            // Toggle mouse inspect mode
            game.debug.mouseInspect = !game.debug.mouseInspect;
            console.log('üîç Mouse inspect:', game.debug.mouseInspect ? 'ON' : 'OFF');
          }
          if (key === 'b') {
            // Toggle sprite bounds display
            game.debug.showSpriteBounds = !game.debug.showSpriteBounds;
            console.log('üñºÔ∏è Sprite bounds:', game.debug.showSpriteBounds ? 'ON' : 'OFF');
          }
          if (key === 'n') {
            // Toggle player hitbox display (actual collision area)
            game.debug.showPlayerHitbox = !game.debug.showPlayerHitbox;
            console.log('üéØ Player Hitbox:', game.debug.showPlayerHitbox ? 'ON' : 'OFF');
          }
        }
        
        // Toggle inverted flight mode
        if (key === 'f') {
          const oldInverted = game.inverted;
          game.inverted = !game.inverted;
          console.log('üîÑ Flight mode changed:', oldInverted ? 'INVERTED' : 'NORMAL', '‚Üí', game.inverted ? 'INVERTED' : 'NORMAL');
          console.log('üîÑ F key - Game state after flip:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        
        // Toggle landing gear
        if (key === 'g') {
          const oldGear = game.gearDown;
          game.gearDown = !game.gearDown;
          console.log('üõ¨ Gear changed:', oldGear ? 'DOWN' : 'UP', '‚Üí', game.gearDown ? 'DOWN' : 'UP');
          console.log('üõ¨ G key - Game state after gear toggle:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        // Fire guns (space) - now handled in physics update for continuous fire
        if (key === ' ' || e.code === 'Space') {
          console.log('üéØ SPACE pressed - continuous fire mode');
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn above ground within main map (scaled physics)
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, -300), // 300 physics units above ground (visually 600m)
        angle: 0,
        linearDamping: 0.0, // Removed damping to eliminate speed cap
        angularDamping: 8.0 // Very high damping for instant stop when controls released (works with force-based controls)
      });
      
      aircraft.createFixture({
        shape: pl.Box(2.5, 0.8), // 5m x 1.6m aircraft - much smaller and more accurate
        density: 20, // kg/m¬≤
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create infinite ground collision at y=0 (physical ground - scaled)
        const groundLevel = 0; // ground at 0 altitude
        const halfThickness = 0.25; // scaled down collision thickness (2x scaling)
        const infiniteWidth = 50000; // Very wide ground - scaled down (2x scaling)
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel) // center at y=0
        });
        
        groundBody.createFixture({
          shape: pl.Box(infiniteWidth / 2, halfThickness),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel,
          width: infiniteWidth,
          height: halfThickness * 2,
          isMainGround: true
        });
        
        console.log(`üü¢ Created infinite ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // Create initial enemy aircraft
      createInitialEnemies();
      
      // =============================================================================
      // GUNS AND PROJECTILES
      // =============================================================================
      
      // Initialize external projectiles module (after aircraft/world exist)
      setTimeout(() => {
        if (window.initProjectiles) {
          window.initProjectiles();
        }
      }, 0);
        
        // =============================================================================
        // ENEMY SYSTEM
        // =============================================================================
        
        // Enemy spawning system variables (initialize explicitly)
        var lastSpawnTime = 0;
        var spawnInterval = 20000; // Spawn new formation every 20 seconds (reduce clustering)
        var formationCounter = 0;
        
        function createInitialEnemies() {
          console.log('‚úàÔ∏è Creating initial enemy aircraft formations...');
          // Spawn only one initial formation to mitigate large crowds at start
          spawnEnemyFormation();
          // Delay next spawn by setting lastSpawnTime to now
          lastSpawnTime = performance.now();
        }
        
        // Standalone enemy spawning function for mission system
        function spawnEnemy(x, y, type = 'bf109') {
          if (type === 'training_dummy') {
            // Create training dummy
            const dummyBody = world.createBody({
              type: 'static',
              position: pl.Vec2(x, y)
            });
            
            const dummyShape = pl.Circle(3); // 6m diameter sphere
            dummyBody.createFixture(dummyShape, {
              density: 1.0,
              friction: 0.3,
              restitution: 0.2
            });
            
            const dummy = {
              body: dummyBody,
              health: 5,
              maxHealth: 5,
              destroyed: false,
              type: 'training_dummy',
              spawnTime: performance.now(),
              hitCount: 0
            };
            
            dummyBody.setUserData({ type: 'enemy', enemy: dummy });
            game.enemies.push(dummy);
            console.log(`üéØ Spawned training dummy at (${x}, ${y})`);
            return dummy;
            
          } else if (type === 'ju88') {
            // Create bomber
            const enemyBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(x, y),
              linearDamping: 0.5,
              angularDamping: 1.0
            });
            
            const enemyShape = pl.Box(2, 0.5);
            enemyBody.createFixture(enemyShape, {
              density: 1.0,
              friction: 0.3,
              restitution: 0.2
            });
            
            const enemy = {
              body: enemyBody,
              health: 5,
              maxHealth: 5,
              targetSpeed: 80,
              destroyed: false,
              thrustReduction: 0,
              liftReduction: 0,
              type: 'ju88',
              formation: 0,
              position: 0,
              spawnTime: performance.now(),
              targetAltitude: y,
              smoking: false,
              onFire: false,
              pitchingDown: false,
              hasGunner: true,
              gunnerLastShotTime: 0,
              gunnerBurstRemaining: 0,
              gunnerBurstSize: 5,
              gunnerShotInterval: 150,
              gunnerBurstCooldown: 2000,
              gunnerLastBurstTime: 0,
              gunnerRange: 100
            };
            
            enemyBody.setUserData({ type: 'enemy', enemy: enemy });
            game.enemies.push(enemy);
            console.log(`‚úàÔ∏è Spawned Ju-88 bomber at (${x}, ${y})`);
            return enemy;
            
          } else {
            // Create fighter (bf109)
            const enemyBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(x, y),
              linearDamping: 0.5,
              angularDamping: 1.0
            });
            
            const enemyShape = pl.Box(1.5, 0.4);
            enemyBody.createFixture(enemyShape, {
              density: 0.8,
              friction: 0.3,
              restitution: 0.2
            });
            
            const enemy = {
              body: enemyBody,
              health: 3,
              maxHealth: 3,
              targetSpeed: 100,
              destroyed: false,
              thrustReduction: 0,
              liftReduction: 0,
              type: 'bf109',
              spawnTime: performance.now(),
              targetAltitude: y,
              smoking: false,
              onFire: false,
              pitchingDown: false,
              lastShotTime: 0,
              burstRemaining: 0,
              lastBurstTime: 0,
              burstCooldownTime: 1500,
              shotInterval: 100,
              burstSize: 4,
              facingDirection: 'right',
              skillLevel: Math.random() > 0.8 ? 'ace' : 'regular',
              aggressiveness: 0.5 + Math.random() * 0.5,
              reactionTime: 200 + Math.random() * 300,
              lastReactionUpdate: 0,
              currentManeuver: null,
              maneuverTimer: 0,
              preferredEngagementRange: 50 + Math.random() * 50,
              energyState: 'neutral',
              lastEnergyCheck: 0,
              timeSinceLastHit: 0,
              consecutiveHits: 0,
              isEvading: false,
              evasionDirection: 1,
              lastKnownPlayerPos: null,
              predictedPlayerPos: null,
              leadCalculation: null
            };
            
            enemyBody.setUserData({ type: 'enemy', enemy: enemy });
            game.enemies.push(enemy);
            console.log(`üõ©Ô∏è Spawned BF-109 fighter at (${x}, ${y})`);
            return enemy;
          }
        }
        
        // Make spawnEnemy globally accessible for mission system
        window.spawnEnemy = spawnEnemy;
        
        function spawnEnemyFormation() {
          console.log('‚úàÔ∏è Spawning new enemy formation with escorts...');
          
          const bomberAltitude = -500; // 1000m above ground in physics units (500 * VISUAL_SCALE = 1000m)
          const vSpacing = 150; // 300m between aircraft in V formation
          const vOffset = 75; // 150m vertical offset for V wings
          
          // Spawn from the right side of the map, far ahead of player
          const spawnX = 2000; // 4000m to the right
          
          // Add some random altitude variation
          const altitudeVariation = (Math.random() - 0.5) * 200; // ¬±200m variation
          const baseAltitude = bomberAltitude + altitudeVariation;
          
          // Create V formation of 3 ju-88 bombers
          for (let pos = 0; pos < 3; pos++) {
            let x, y;
            
            if (pos === 0) {
              // Lead aircraft (center of V)
              x = spawnX;
              y = baseAltitude;
            } else if (pos === 1) {
              // Left wing (relative to their flight direction - behind and below)
              x = spawnX + vSpacing;
              y = baseAltitude - vOffset;
            } else {
              // Right wing (relative to their flight direction - behind and above)
              x = spawnX + vSpacing;
              y = baseAltitude + vOffset;
            }
            
            // Create Box2D body for enemy
            const enemyBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(x, y),
              angle: Math.PI, // Face left (180 degrees)
              linearDamping: 0.02,
              angularDamping: 2.0
            });
            
            enemyBody.createFixture({
              shape: pl.Box(12, 8), // Larger Ju-88 bomber (24m x 16m - 2x larger to match visual size)
              density: 25,
              friction: 0.3,
              restitution: 0.1
            });
            
            // Enemy data with reduced health for faster damage
            const enemy = {
              body: enemyBody,
              health: 5, // Reduced from 10 for faster damage
              maxHealth: 5,
              targetSpeed: 80,
              destroyed: false,
              thrustReduction: 0, // Progressive thrust loss (0-1)
              liftReduction: 0, // Progressive lift loss (0-1)
              type: 'ju88',
              formation: formationCounter,
              position: pos,
              spawnTime: performance.now(),
              targetAltitude: y, // Store initial altitude to maintain level flight
              smoking: false, // Visual damage indicator
              onFire: false, // Critical damage indicator
                pitchingDown: false, // Crash state
                // Defensive gunner
                hasGunner: true,
                gunnerLastShotTime: 0,
                gunnerBurstRemaining: 0,
                gunnerBurstSize: 5,
                gunnerShotInterval: 150, // Slower fire rate than fighters
                gunnerBurstCooldown: 2000, // 2 seconds between bursts
                gunnerLastBurstTime: 0,
                gunnerRange: 100 // 200m defensive range
            };
            
            // Store reference for collision detection
            enemyBody.setUserData({ type: 'enemy', enemy: enemy });
            
            game.enemies.push(enemy);
            console.log(`‚úàÔ∏è Spawned Ju-88 bomber at (${x}, ${y}) - Formation ${formationCounter}, Position ${pos}`);
          }
          
          // Add bf-109 escort fighters
          const escortAltitude = baseAltitude - 25; // Fighters fly slightly lower
          const escortOffset = 150; // Distance from bombers
          
          // Create exactly 2 bf-109 escorts per formation
          const numEscorts = 2; // Exactly 2 escorts as requested
          for (let i = 0; i < numEscorts; i++) {
            // Position escorts around the bomber formation
            const escortX = spawnX + (i % 2 === 0 ? -escortOffset : escortOffset) + (Math.random() - 0.5) * 50;
            const escortY = escortAltitude + (Math.floor(i / 2) * 30) + (Math.random() - 0.5) * 20;
            
            // Create Box2D body for escort fighter
            const escortBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(escortX, escortY),
              angle: Math.PI, // Face left initially
              linearDamping: 0.02,
              angularDamping: 2.0
            });
            
            escortBody.createFixture({
              shape: pl.Box(6, 2), // Doubled fighter size (12m x 4m)
              density: 15,
              friction: 0.3,
              restitution: 0.1
            });
            
            // BF-109 escort data with enhanced AI
            const escort = {
              body: escortBody,
              health: 3, // Lower health than bombers
              maxHealth: 3,
              targetSpeed: 120, // Faster than bombers
              destroyed: false,
              thrustReduction: 0,
              liftReduction: 0,
              type: 'bf109',
              formation: formationCounter,
              position: i,
              spawnTime: performance.now(),
              targetAltitude: escortY,
              smoking: false,
              onFire: false,
              pitchingDown: false,
              // Enhanced Combat AI state machine
              aiState: 'patrol', // patrol, engage, attack, evade, boom_zoom, disengage
              previousState: 'patrol',
              stateTimer: 0,
              target: null, // Target for attack
              lastShotTime: 0,
              burstShotsRemaining: 0,
              burstCooldown: 0,
              shotInterval: 100, // 100ms between shots in a burst
              burstSize: 3 + Math.floor(Math.random() * 3), // 3-5 shot bursts
              burstCooldownTime: 1000 + Math.random() * 1000, // 1-2s between bursts
              facingDirection: 'right', // Track which sprite to use (right sprite when flying left)
              // Advanced AI parameters
              skillLevel: Math.random() > 0.8 ? 'ace' : 'regular', // 20% chance of ace pilot
              aggressiveness: 0.5 + Math.random() * 0.5, // 0.5-1.0 aggression factor
              reactionTime: 200 + Math.random() * 300, // 200-500ms reaction delay
              lastReactionUpdate: 0,
              // Maneuver tracking
              currentManeuver: null,
              maneuverTimer: 0,
              preferredEngagementRange: 50 + Math.random() * 50, // 100-200m preferred combat range
              // Energy management
              energyState: 'neutral', // low, neutral, high
              lastEnergyCheck: 0,
              // Evasion tracking
              timeSinceLastHit: 0,
              consecutiveHits: 0,
              isEvading: false,
              evasionDirection: 1, // 1 or -1 for roll direction
              // Tactical awareness
              lastKnownPlayerPos: null,
              predictedPlayerPos: null,
              leadCalculation: null
            };
            
            // Store reference for collision detection
            escortBody.setUserData({ type: 'enemy', enemy: escort });
            
            game.enemies.push(escort);
            console.log(`üõ©Ô∏è Spawned BF-109 escort at (${escortX}, ${escortY}) - Formation ${formationCounter}, Position ${i}`);
          }
          
          formationCounter++;
        }
        
        function updateEnemySpawning() {
          // Only auto-spawn in free flight mode
          if (!window.campaignMode) {
            const now = performance.now();
            if (now - lastSpawnTime > spawnInterval) {
              spawnEnemyFormation();
              lastSpawnTime = now;
            }
          }
          
          // Clean up enemies that are too far from the player or have crashed
          const playerPos = aircraft.getPosition();
          const maxDistance = 5000; // 10000m from player (really far)
          
          for (let i = game.enemies.length - 1; i >= 0; i--) {
            const enemy = game.enemies[i];
              const pos = enemy.body.getPosition();
            
            // Remove if too far from player
              const distance = Math.sqrt(
                (pos.x - playerPos.x) * (pos.x - playerPos.x) + 
                (pos.y - playerPos.y) * (pos.y - playerPos.y)
              );
              
            // Remove if crashed into ground or too far away
            const hasHitGround = pos.y > 5; // Below ground level
            const tooFarAway = distance > maxDistance;
            
            if (!enemy.destroyed && tooFarAway) {
                console.log(`üóëÔ∏è Removing enemy too far from player (distance: ${distance * VISUAL_SCALE}m)`);
                world.destroyBody(enemy.body);
                game.enemies.splice(i, 1);
            } else if (enemy.destroyed && hasHitGround) {
              console.log(`üí• Removing crashed enemy`);
              world.destroyBody(enemy.body);
              game.enemies.splice(i, 1);
              
              // Create ground explosion
              game.explosions.push({
                x: pos.x,
                y: 0, // Ground level
                time: 0,
                duration: 1.5,
                size: 25,
                type: 'destruction'
              });
              playSound(sounds.explosion, 0.6);
            }
          }
        }
        
        // Function to make enemy aircraft fire their weapons
        function fireEnemyWeapon(enemy) {
          // Check debug setting to stop enemies from firing
          if (game.debug.enemiesStopFiring) {
            return;
          }
          
          const pos = enemy.body.getPosition();
          const vel = enemy.body.getLinearVelocity();
          const angle = enemy.body.getAngle();
          
          // Define gun mounts (Ju-88 has defensive turrets)
          const gunMounts = [];
          if (enemy.type === 'ju88') {
            gunMounts.push({ offset: { x: 2.0, y: 0 }, arc: Math.PI / 3 });          // Front
            gunMounts.push({ offset: { x: -0.5, y: -1.0 }, arc: Math.PI / 2 });      // Top
            gunMounts.push({ offset: { x: -2.0, y: 0 }, arc: Math.PI / 2 });         // Rear
          } else {
            gunMounts.push({ offset: { x: 2.0, y: 0 }, arc: Math.PI / 6 });          // Fighter forward guns
          }
          
          // Calculate bullet velocity with lead prediction
          const playerPos = aircraft.getPosition();
          const playerVel = aircraft.getLinearVelocity();
          const distance = Math.sqrt(
            (playerPos.x - pos.x) * (playerPos.x - pos.x) + 
            (playerPos.y - pos.y) * (playerPos.y - pos.y)
          );
          
          // Lead calculation for ace pilots
          let leadFactor = 0;
          if (enemy.skillLevel === 'ace') {
            const bulletSpeed = 400; // m/s
            const timeToTarget = distance / bulletSpeed;
            leadFactor = timeToTarget * 0.5; // Aces lead shots better
          }
          
          // Calculate firing angle with lead
          const predictedX = playerPos.x + playerVel.x * leadFactor;
          const predictedY = playerPos.y + playerVel.y * leadFactor;
          const firingAngle = Math.atan2(predictedY - pos.y, predictedX - pos.x);
          
          // Add some spread/inaccuracy (less for aces) - reduced accuracy
          const spread = enemy.skillLevel === 'ace' ? 0.08 : 0.15; // Much wider spread
          const actualAngle = firingAngle + (Math.random() - 0.5) * spread;
          
          // Muzzle velocity
          const muzzleVelocity = 400;
          const bulletVel = {
            x: vel.x + Math.cos(actualAngle) * muzzleVelocity,
            y: vel.y + Math.sin(actualAngle) * muzzleVelocity
          };
          
          if (!game.enemyProjectiles) game.enemyProjectiles = [];
          
          gunMounts.forEach(() => { /* placeholder to keep structure if no mount loop below */ });
          
          gunMounts.forEach((mount) => {
            // Mount world position
            const gunPos = {
              x: pos.x + Math.cos(angle) * mount.offset.x - Math.sin(angle) * mount.offset.y,
              y: pos.y + Math.sin(angle) * mount.offset.x + Math.cos(angle) * mount.offset.y
            };
            // Angle to player
            const toPlayerAngle = Math.atan2(playerPos.y - gunPos.y, playerPos.x - gunPos.x);
            // Check arc limits
            let rel = toPlayerAngle - angle;
            while (rel > Math.PI) rel -= 2 * Math.PI;
            while (rel < -Math.PI) rel += 2 * Math.PI;
            if (Math.abs(rel) > mount.arc) return;
            
            // Random defensive fire when player is near: completely random direction within arc
            const randomRel = (Math.random() - 0.5) * 2 * mount.arc;
            let firingAngle = angle + randomRel;
            
            // Avoid friendly fire
            const friendlyNear = game.enemies.some(other => {
              if (other === enemy || other.destroyed) return false;
              const o = other.body.getPosition();
              const along = (o.x - gunPos.x) * Math.cos(firingAngle) + (o.y - gunPos.y) * Math.sin(firingAngle);
              if (along <= 0 || along > 150) return false;
              const perp = Math.abs(-(o.x - gunPos.x) * Math.sin(firingAngle) + (o.y - gunPos.y) * Math.cos(firingAngle));
              return perp < 10;
            });
            if (friendlyNear) return;
            
            // Spread
            const spread = 0.15; // Additional inaccuracy
            const actualAngle = firingAngle + (Math.random() - 0.5) * spread;
            const muzzleVelocity = 350;
            const bulletVel = {
              x: vel.x + Math.cos(actualAngle) * muzzleVelocity,
              y: vel.y + Math.sin(actualAngle) * muzzleVelocity
            };

            // Spawn slightly ahead of the mount along the firing direction to avoid hitting own airframe
            const muzzleOffset = 3.0; // meters
            const spawnX = gunPos.x + Math.cos(actualAngle) * muzzleOffset;
            const spawnY = gunPos.y + Math.sin(actualAngle) * muzzleOffset;
            
            enemy._shotIndex = (enemy._shotIndex || 0) + 1;
            const isTracer = (enemy._shotIndex % 2 === 0);
            
            // Create unique ID for tracer-collision projectile pairs
            const collisionId = Math.random().toString(36).substr(2, 9);
            
            game.enemyProjectiles.push({
              x: spawnX,
              y: spawnY,
              vx: bulletVel.x,
              vy: bulletVel.y,
              type: isTracer ? 'tracer' : 'bullet',
              life: 3.0,
              initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y),
              owner: enemy,
              collisionId: isTracer ? collisionId : null
            });
            
            // Create collision projectile for tracers (smaller, invisible projectile for physics hitbox collision)
            if (isTracer) {
              if (!game.enemyCollisionProjectiles) game.enemyCollisionProjectiles = [];
              game.enemyCollisionProjectiles.push({
                x: spawnX,
                y: spawnY,
                vx: bulletVel.x,
                vy: bulletVel.y,
                life: 3.0,
                collisionId: collisionId,
                owner: enemy,
                spawnTime: performance.now()
              });
            }
          });
          
          // Play enemy gunfire sound (quieter than player)
          if (sounds.gunfire) {
            playSound(sounds.gunfire, 0.15);
          }
        }
        
        function updateEnemies(dt) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed && !enemy.pitchingDown) return; // Allow crashing aircraft to continue updating
            
            // Debug: Stop enemy movement
            if (game.debug.enemiesStopMoving) {
              enemy.body.setLinearVelocity(pl.Vec2(0, 0));
              enemy.body.setAngularVelocity(0);
              return;
            }
            
            const pos = enemy.body.getPosition();
            const vel = enemy.body.getLinearVelocity();
            const angle = enemy.body.getAngle();
            const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);

            // BF-109 stability improvements - prevent high-speed spinning
            if (enemy.type === 'bf109') {
              // Apply moderate angular damping to all BF-109s for stability
              if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(3.0);
              
              // Limit angular velocity to prevent wild spinning
              const w = enemy.body.getAngularVelocity();
              const maxW = enemy.onFire || enemy.liftReduction > 0.5 || enemy.thrustReduction > 0.6 || enemy.health <= 1 ? 0.8 : 2.0;
              if (Math.abs(w) > maxW) {
                const clamped = Math.max(-maxW, Math.min(maxW, w));
                enemy.body.setAngularVelocity(clamped * 0.9);
              }
              
              // For heavily damaged BF-109s, apply additional stabilization
              const bf109Damaged = enemy.onFire || enemy.liftReduction > 0.5 || enemy.thrustReduction > 0.6 || enemy.health <= 1;
              if (bf109Damaged) {
                // Keep a small forward force to avoid rotating about a point
                const forwardForce = Math.max(4000, (1 - (enemy.thrustReduction || 0)) * 12000);
                enemy.body.applyForceToCenter(pl.Vec2(Math.cos(angle) * forwardForce, Math.sin(angle) * forwardForce), true);
              }
            }
            
            // Enhanced AI behavior for BF-109 fighters
            if (enemy.type === 'bf109') {
              const playerPos = aircraft.getPosition();
              const playerVel = aircraft.getLinearVelocity();
              const distanceToPlayer = Math.sqrt(
                (pos.x - playerPos.x) * (pos.x - playerPos.x) + 
                (pos.y - playerPos.y) * (pos.y - playerPos.y)
              );
              
              // Update reaction timer
              const now = performance.now();
              enemy.stateTimer += dt;
              enemy.timeSinceLastHit += dt;
              
              // Energy state assessment
              if (now - enemy.lastEnergyCheck > 1000) {
                const altitude = -pos.y * VISUAL_SCALE;
                const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y) * VISUAL_SCALE;
                const totalEnergy = altitude + (speed * speed) / (2 * 9.81);
                
                if (totalEnergy < 500) enemy.energyState = 'low';
                else if (totalEnergy > 1500) enemy.energyState = 'high';
                else enemy.energyState = 'neutral';
                
                enemy.lastEnergyCheck = now;
              }
              
              // Check for coordinated attacks with other fighters
              let nearbyAllies = [];
              if (enemy.aiState === 'engage' || enemy.aiState === 'attack') {
                nearbyAllies = game.enemies.filter(other => 
                  other !== enemy && 
                  other.type === 'bf109' && 
                  !other.destroyed &&
                  Math.sqrt((other.body.getPosition().x - pos.x) ** 2 + 
                           (other.body.getPosition().y - pos.y) ** 2) < 100
                );
              }
              
              // State machine transitions
              switch(enemy.aiState) {
                case 'patrol':
                  // Patrol: Stay with formation, scan for threats
                  if (distanceToPlayer < 150) { // tighter detection range
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                    enemy.target = aircraft;
                    
                    // Coordinate attack if allies nearby
                    if (nearbyAllies.length > 0) {
                      // One attacks from above, one from below
                      const attackFromAbove = nearbyAllies.filter(a => a.aiState !== 'attack').length % 2 === 0;
                      enemy.preferredEngagementRange = attackFromAbove ? 75 : 50;
                      enemy.targetAltitude = playerPos.y + (attackFromAbove ? -50 : 50);
                      console.log(`üéØ ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 engaging (coordinated ${attackFromAbove ? 'high' : 'low'})!`);
                    } else {
                      console.log(`üéØ ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 engaging!`);
                    }
                  }
                  enemy.targetSpeed = 100;
                  enemy.facingDirection = 'left'; // Flying left means showing left-facing sprite
                  break;
                  
                case 'engage':
                  // Engage: Position for attack
                  if (distanceToPlayer > 300) {
                    enemy.aiState = 'patrol';
                    enemy.stateTimer = 0;
                    console.log('‚úàÔ∏è BF-109 disengaging - target too far');
                  } else if (distanceToPlayer < enemy.preferredEngagementRange && enemy.stateTimer > enemy.reactionTime / 1000) {
                    // Check if we have a good attack angle
                    const angleToPlayer = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                const currentAngle = enemy.body.getAngle();
                    let angleDiff = Math.abs(angleToPlayer - currentAngle);
                    while (angleDiff > Math.PI) angleDiff = Math.abs(angleDiff - 2 * Math.PI);
                    
                    // Coordinate timing with allies
                    let shouldAttack = angleDiff < Math.PI / 6; // Within 30 degrees
                    if (shouldAttack && nearbyAllies.length > 0) {
                      // Stagger attacks - don't all attack at once
                      const attackingAllies = nearbyAllies.filter(a => a.aiState === 'attack');
                      if (attackingAllies.length > 0 && enemy.skillLevel !== 'ace') {
                        shouldAttack = false; // Wait for ally to finish unless we're an ace
                      }
                    }
                    
                    if (shouldAttack) {
                      enemy.aiState = 'attack';
                      enemy.stateTimer = 0;
                      enemy.burstShotsRemaining = enemy.burstSize;
                      console.log(`üî´ ${nearbyAllies.length > 0 ? 'ü§ù Coordinated' : ''} BF-109 has firing solution!`);
                    }
                  }
                  
                  // Calculate intercept course with lead
                  const timeToIntercept = distanceToPlayer / 150; // Rough estimate
                  const predictedX = playerPos.x + playerVel.x * timeToIntercept * 0.3; // Partial lead
                  const predictedY = playerPos.y + playerVel.y * timeToIntercept * 0.3;
                  enemy.predictedPlayerPos = { x: predictedX, y: predictedY };
                  
                  const angleToIntercept = Math.atan2(predictedY - pos.y, predictedX - pos.x);
                  const currentAngle = enemy.body.getAngle();
                  let angleDiff = angleToIntercept - currentAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                  // Ace pilots turn faster
                  const turnRate = enemy.skillLevel === 'ace' ? 30000 : 20000;
                  enemy.body.applyTorque(angleDiff * turnRate, true);
                  enemy.facingDirection = Math.cos(angleToIntercept) < 0 ? 'left' : 'right';
                  enemy.targetSpeed = 140;
                  break;
                  
                case 'attack':
                  // Attack: Fire weapons at target
                  if (distanceToPlayer > enemy.preferredEngagementRange * 2 || enemy.burstShotsRemaining <= 0) {
                    // Exit attack, decide next action
                    if (enemy.energyState === 'low' || enemy.consecutiveHits > 2) {
                      enemy.aiState = 'evade';
                      enemy.evasionDirection = Math.random() > 0.5 ? 1 : -1;
                    } else if (enemy.energyState === 'high' && enemy.skillLevel === 'ace') {
                      enemy.aiState = 'boom_zoom';
                    } else {
                      enemy.aiState = 'engage';
                    }
                    enemy.stateTimer = 0;
                    enemy.burstCooldown = enemy.burstCooldownTime;
                  }
                  
                  // Fire weapons during attack
                  if (enemy.burstShotsRemaining > 0 && now - enemy.lastShotTime > enemy.shotInterval && (now - enemy.spawnTime > 2000) && (now > game.spawnShieldUntil)) {
                    fireEnemyWeapon(enemy);
                    enemy.burstShotsRemaining--;
                    enemy.lastShotTime = now;
                  }
                  
                  // Continue tracking target
                  const attackAngle = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                  const currAngle = enemy.body.getAngle();
                  let aDiff = attackAngle - currAngle;
                  while (aDiff > Math.PI) aDiff -= 2 * Math.PI;
                  while (aDiff < -Math.PI) aDiff += 2 * Math.PI;
                  
                  enemy.body.applyTorque(aDiff * 25000, true);
                  enemy.facingDirection = Math.cos(attackAngle) < 0 ? 'left' : 'right';
                  enemy.targetSpeed = 160; // Full speed during attack
                  break;
                  
                case 'evade':
                  // Evade: Defensive maneuvers
                  if (enemy.stateTimer > 2) { // Evade for 2 seconds
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                    enemy.isEvading = false;
                    enemy.consecutiveHits = 0;
                  }
                  
                  // Barrel roll evasion
                  const rollAngle = angle + enemy.evasionDirection * Math.sin(enemy.stateTimer * 10) * 0.5;
                  enemy.body.setAngle(rollAngle);
                  
                  // Dive or climb based on energy state
                  if (enemy.energyState === 'high') {
                    enemy.targetAltitude = pos.y + 50; // Dive
                    enemy.targetSpeed = 180;
              } else {
                    enemy.targetAltitude = pos.y - 30; // Gentle climb
                    enemy.targetSpeed = 90;
                  }
                  break;
                  
                case 'boom_zoom':
                  // Boom and Zoom: High speed attack from altitude
                  if (enemy.stateTimer < 1.5) {
                    // Climb phase
                    enemy.targetAltitude = pos.y - 100;
                    enemy.targetSpeed = 100;
                  } else if (enemy.stateTimer < 3) {
                    // Dive attack phase
                    const diveAngle = Math.atan2(playerPos.y - pos.y, playerPos.x - pos.x);
                    const cAngle = enemy.body.getAngle();
                    let dDiff = diveAngle - cAngle;
                    while (dDiff > Math.PI) dDiff -= 2 * Math.PI;
                    while (dDiff < -Math.PI) dDiff += 2 * Math.PI;
                    
                    enemy.body.applyTorque(dDiff * 30000, true);
                    enemy.targetSpeed = 200; // Maximum speed
                    enemy.targetAltitude = playerPos.y;
                    
                    // Fire if in range
                    if (distanceToPlayer < 75 && Math.abs(dDiff) < Math.PI / 8) {
                      if (now - enemy.lastShotTime > enemy.shotInterval) {
                        fireEnemyWeapon(enemy);
                        enemy.lastShotTime = now;
                      }
                    }
                  } else {
                    // Exit boom and zoom
                    enemy.aiState = 'engage';
                    enemy.stateTimer = 0;
                  }
                  enemy.facingDirection = Math.cos(angle) < 0 ? 'left' : 'right';
                  break;
                  
                case 'disengage':
                  // Disengage: Break off and retreat
                enemy.targetSpeed = 120;
                  enemy.targetAltitude = pos.y - 50; // Climb away
                  const escapeAngle = Math.atan2(pos.y - playerPos.y, pos.x - playerPos.x);
                  enemy.body.setAngle(escapeAngle);
                  enemy.facingDirection = Math.cos(escapeAngle) < 0 ? 'left' : 'right';
                  
                  if (distanceToPlayer > 400 || enemy.stateTimer > 5) {
                    enemy.aiState = 'patrol';
                    enemy.stateTimer = 0;
                  }
                  break;
                  
                default:
                  // Fallback to patrol if unknown state
                  enemy.aiState = 'patrol';
                  break;
              }
              
              // Update burst cooldown
              if (enemy.burstCooldown > 0) {
                enemy.burstCooldown -= dt * 1000;
              }
              
              // Ace pilot bonuses
              if (enemy.skillLevel === 'ace') {
                enemy.targetSpeed *= 1.15; // 15% speed bonus
                // Aces also get better turn rates and reaction times (already implemented above)
              }
            } else if (enemy.type === 'ju88' && enemy.hasGunner && !enemy.destroyed) {
              // Ju-88 bomber defensive gunner behavior (random defensive fire)
              const playerPos = aircraft.getPosition();
              const distanceToPlayer = Math.sqrt((pos.x - playerPos.x) ** 2 + (pos.y - playerPos.y) ** 2);
              const now = performance.now();

              // Stop defensive fire when heavily damaged
              const heavilyDamaged = enemy.onFire || (enemy.health / enemy.maxHealth) <= 0.4 || enemy.liftReduction > 0.5;
              if (heavilyDamaged) {
                enemy.gunnerBurstRemaining = 0;
                return;
              }

              if (distanceToPlayer < enemy.gunnerRange && (now - enemy.spawnTime > 2000) && (now > game.spawnShieldUntil) && !game.debug.enemiesStopFiring) {
                // Fixed 5 rounds per second
                enemy.gunnerShotInterval = 200;
                // Use multiple mounts with random spread
                const mounts = [
                  { offset: { x: 2.0, y: 0 }, arc: Math.PI / 3 },       // Front
                  { offset: { x: -0.5, y: -1.0 }, arc: Math.PI / 2 },   // Top
                  { offset: { x: -2.0, y: 0 }, arc: Math.PI / 2 }       // Rear
                ];

                // Fire one round per interval from a random mount
                if (now - enemy.gunnerLastShotTime > enemy.gunnerShotInterval) {
                  const mount = mounts[Math.floor(Math.random() * mounts.length)];
                  const bomberAngle = enemy.body.getAngle();
                  const gunPos = {
                    x: pos.x + Math.cos(bomberAngle) * mount.offset.x - Math.sin(bomberAngle) * mount.offset.y,
                    y: pos.y + Math.sin(bomberAngle) * mount.offset.x + Math.cos(bomberAngle) * mount.offset.y
                  };
                  // Random firing direction within mount arc
                  const randomRel = (Math.random() - 0.5) * 2 * mount.arc;
                  const firingAngle = bomberAngle + randomRel;

                  // Avoid friendly fire corridor
                  const friendlyNear = game.enemies.some(other => {
                    if (other === enemy || other.destroyed) return false;
                    const o = other.body.getPosition();
                    const along = (o.x - gunPos.x) * Math.cos(firingAngle) + (o.y - gunPos.y) * Math.sin(firingAngle);
                    if (along <= 0 || along > 150) return false;
                    const perp = Math.abs(-(o.x - gunPos.x) * Math.sin(firingAngle) + (o.y - gunPos.y) * Math.cos(firingAngle));
                    return perp < 10;
                  });
                  if (!friendlyNear) {
                    const muzzleVelocity = 350;
                    const bulletVel = {
                      x: vel.x + Math.cos(firingAngle) * muzzleVelocity,
                      y: vel.y + Math.sin(firingAngle) * muzzleVelocity
                    };
                    if (!game.enemyProjectiles) game.enemyProjectiles = [];
                    // 100% tracers
                    const muzzleOffset = 3.0; // Standard offset
                    const spawnX = gunPos.x + Math.cos(firingAngle) * muzzleOffset;
                    const spawnY = gunPos.y + Math.sin(firingAngle) * muzzleOffset;
                    // Create unique ID for tracer-collision projectile pairs
                    const collisionId = Math.random().toString(36).substr(2, 9);
                    
                    game.enemyProjectiles.push({
                      x: spawnX,
                      y: spawnY,
                      vx: bulletVel.x,
                      vy: bulletVel.y,
                      type: 'tracer',
                      life: 3.0,
                      initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y),
                      owner: enemy,
                      collisionId: collisionId
                    });
                    
                    // Create collision projectile for Ju-88 tracers (for physics hitbox collision)
                    if (!game.enemyCollisionProjectiles) game.enemyCollisionProjectiles = [];
                    game.enemyCollisionProjectiles.push({
                      x: spawnX,
                      y: spawnY,
                      vx: bulletVel.x,
                      vy: bulletVel.y,
                      life: 3.0,
                      collisionId: collisionId,
                      owner: enemy,
                      spawnTime: performance.now()
                    });

                    enemy.gunnerLastShotTime = now;
                    if (sounds.gunfire) playSound(sounds.gunfire, 0.1);
                  }
                }
              }
            }
            
            // Use same physics as player aircraft but with AI controls
            
            // Progressive thrust reduction based on damage
            let maxThrust, throttleLevel;
            if (enemy.type === 'bf109') {
              maxThrust = 25000; // Fighter thrust - lighter but more powerful
              throttleLevel = enemy.targetSpeed ? Math.min(1.0, enemy.targetSpeed / 120) : 0.7; // Variable throttle based on target speed
            } else {
              maxThrust = 30000; // Heavy bomber thrust
              throttleLevel = 0.5; // 50% throttle for slower cruise
            }
            
            // Apply progressive damage reduction
            maxThrust *= (1 - enemy.thrustReduction);
              
              // Apply altitude-based thrust reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                maxThrust *= altitudeReduction;
              }
              
            const thrust = throttleLevel * maxThrust;
              const thrustForce = pl.Vec2(Math.cos(angle) * thrust, Math.sin(angle) * thrust);
              enemy.body.applyForceToCenter(thrustForce, true);
            
            // Aerodynamics (enhanced for level flight)
            if (speed > 1) {
              const q = 0.5 * 1.225 * speed * speed; // Dynamic pressure
              
              // Aircraft-specific aerodynamics
              let wingArea, maxLiftCoeff, minLiftForLevelFlight, liftMultiplier;
              if (enemy.type === 'bf109') {
                wingArea = 50; // Fighter wings - smaller but efficient
                maxLiftCoeff = 1.8; // Higher lift coefficient for fighter wings
                minLiftForLevelFlight = 1.0; // Lower minimum - more agile
                liftMultiplier = 0.9; // Slightly less gravity compensation - more realistic
              } else {
                wingArea = 100; // Ju-88s need much more wing area to stay aloft
                maxLiftCoeff = 1.5;
                minLiftForLevelFlight = 1.2; // Higher minimum lift coefficient
                liftMultiplier = 1.0;
              }
              
              // Calculate angle of attack relative to velocity
              const velocityAngle = Math.atan2(vel.y, vel.x);
              const aoa = angle - velocityAngle;
              
              // Enhanced lift coefficient for stable level flight
              let liftCoeff = Math.sin(aoa * 2) * maxLiftCoeff;
              
              // Add minimum lift to counteract gravity for level flight
              if (Math.abs(liftCoeff) < minLiftForLevelFlight) {
                liftCoeff = Math.sign(liftCoeff || 1) * minLiftForLevelFlight;
              }
              
              // Apply altitude-based lift reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                liftCoeff *= altitudeReduction;
              }
              
              // Apply lift with progressive damage reduction
              const lift = q * wingArea * liftCoeff * (1 - enemy.liftReduction);
                const liftAngle = velocityAngle + Math.PI/2;
                const liftForce = pl.Vec2(Math.cos(liftAngle) * lift, Math.sin(liftAngle) * lift);
                enemy.body.applyForceToCenter(liftForce, true);
              
              // Additional upward force to counteract gravity (reduced by damage)
              const gravityCounterForce = enemy.body.getMass() * 9.81 * liftMultiplier * (1 - enemy.liftReduction * 0.5);
              enemy.body.applyForceToCenter(pl.Vec2(0, -gravityCounterForce), true);
              
              // Aircraft-specific drag characteristics
              let baseDrag, inducedScale;
              if (enemy.type === 'bf109') {
                baseDrag = 0.008; // Moderate drag for fighters - more than bombers but reasonable
                inducedScale = 0.006; // Lower induced drag for efficient fighter wings
              } else {
                baseDrag = 0.001; // Very low drag for Ju-88s
                inducedScale = 0.002; // Much lower induced drag for Ju-88s
              }
              
              const dragCoeff = baseDrag + Math.abs(liftCoeff) * inducedScale;
              const drag = q * wingArea * dragCoeff;
              const dragForce = pl.Vec2(-vel.x / speed * drag, -vel.y / speed * drag);
              enemy.body.applyForceToCenter(dragForce, true);
            }
            
            // Enhanced AI: Maintain altitude and heading (unless pitching down to crash)
            if (!enemy.pitchingDown) {
              // Normal flight: Altitude control - maintain level flight
              const altitudeError = pos.y - enemy.targetAltitude;
              
              // Calculate desired pitch based on altitude error
              let desiredPitch = 0.1; // Stronger upward pitch for level flight (5.7 degrees)
              if (Math.abs(altitudeError) > 2.5) { // 5m deadband in visual altitude
                // Pitch up if too low, pitch down if too high
                const pitchCorrection = -Math.sign(altitudeError) * Math.min(Math.abs(altitudeError) * 0.05, 0.25); // Stronger correction
                desiredPitch += pitchCorrection;
              }
              
              // Combine with left-facing heading
              const targetAngle = Math.PI + desiredPitch; // Fly left with pitch adjustment
            const angleDiff = targetAngle - angle;
            
            // Normalize angle difference to [-œÄ, œÄ]
            let normalizedAngleDiff = angleDiff;
            while (normalizedAngleDiff > Math.PI) normalizedAngleDiff -= 2 * Math.PI;
            while (normalizedAngleDiff < -Math.PI) normalizedAngleDiff += 2 * Math.PI;
            
              // Apply correction torque to maintain target angle (heading + altitude)
              // Aircraft-specific control authority and damage handling
              let torqueMultiplier, deadband, allowNormalControl;
              
              if (enemy.type === 'bf109') {
                torqueMultiplier = 20000; // Lower torque for fighters - more stable control
                deadband = 0.03; // Slightly larger deadband to prevent oscillations
                const bf109HeavilyDamaged = enemy.onFire || enemy.liftReduction > 0.5 || enemy.thrustReduction > 0.6;
                allowNormalControl = !bf109HeavilyDamaged;
              } else {
                torqueMultiplier = 40000; // Higher torque for heavy bombers
                deadband = 0.02; // Tighter control for bombers
                const ju88HeavilyDamaged = enemy.onFire || enemy.liftReduction > 0.4 || enemy.thrustReduction > 0.5;
                allowNormalControl = !ju88HeavilyDamaged;
              }
              
              if (Math.abs(normalizedAngleDiff) > deadband && allowNormalControl) {
                const correctionTorque = normalizedAngleDiff * torqueMultiplier;
                enemy.body.applyTorque(correctionTorque, true);
              }

              // Handle heavily damaged aircraft with type-specific logic
              if (!allowNormalControl) {
                if (enemy.type === 'bf109') {
                  // BF-109 heavily damaged: clamp spin and reduce angular velocity
                  if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(10.0);
                  const w = enemy.body.getAngularVelocity();
                  const maxW = 1.0; // rad/s
                  const clamped = Math.max(-maxW, Math.min(maxW, w));
                  enemy.body.setAngularVelocity(clamped * 0.9);
                  // Keep some forward force so it doesn't rotate in place
                  const ang = enemy.body.getAngle();
                  const forward = Math.max(5000, (1 - enemy.thrustReduction) * 15000);
                  enemy.body.applyForceToCenter(pl.Vec2(Math.cos(ang) * forward, Math.sin(ang) * forward), true);
                } else {
                  // JU-88 heavily damaged: maintain some stability but reduced control
                  if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(5.0);
                  const w = enemy.body.getAngularVelocity();
                  const maxW = 1.5; // rad/s - slightly higher for bombers
                  const clamped = Math.max(-maxW, Math.min(maxW, w));
                  enemy.body.setAngularVelocity(clamped * 0.95);
                }
              }
            } else {
              // Crashing aircraft - pitch down to reduce drag and gain speed
              const crashIntensity = Math.min(1.0, (enemy.thrustReduction + enemy.liftReduction) / 1.5);
              
              if (enemy.type !== 'bf109') {
                // JU-88 bombers: Heavy nose-down pitch when damaged
                const crashTorque = 30000 * (0.5 + crashIntensity * 0.5); // Scale with damage
                enemy.body.applyTorque(crashTorque, true);
                
                // Reduce drag significantly when pitching down
                const currentVel = enemy.body.getLinearVelocity();
                const speedBoost = crashIntensity * 8000; // Extra forward force to gain speed
                enemy.body.applyForceToCenter(pl.Vec2(currentVel.x * 0.1 + speedBoost, currentVel.y * 0.1), true);
              } else {
                // BF-109 fighters: More controlled descent but still pitch down
                if (enemy.body.setAngularDamping) enemy.body.setAngularDamping(8.0);
                
                // Apply nose-down torque proportional to damage
                const fighterCrashTorque = 15000 * crashIntensity;
                enemy.body.applyTorque(fighterCrashTorque, true);
                
                // Limit spin while allowing controlled descent
                const w = enemy.body.getAngularVelocity();
                const maxW = 1.2; // Slightly higher for realistic spin in damaged state
                const clamped = Math.max(-maxW, Math.min(maxW, w));
                enemy.body.setAngularVelocity(clamped * 0.85);
                
                // Forward force to maintain airspeed during descent
                const angle = enemy.body.getAngle();
                const descentForce = Math.max(6000, (1 - enemy.thrustReduction) * 18000);
                enemy.body.applyForceToCenter(pl.Vec2(Math.cos(angle) * descentForce, Math.sin(angle) * descentForce), true);
              }
            }
          });
        }
        
        function checkProjectileEnemyCollision(proj, projIndex) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            // Pixel-perfect collision detection
            if (checkPixelCollision(proj.x, proj.y, enemy)) {
              console.log('üéØ Pixel-perfect hit detected!', { projectilePos: { x: proj.x, y: proj.y }, enemyHealth: enemy.health });
              
              // Create small hit explosion effect
              game.explosions.push({
                x: proj.x,
                y: proj.y,
                time: 0,
                duration: 0.3, // Short hit explosion
                size: 3, // Small hit explosion (6m diameter)
                type: 'hit' // Mark as hit explosion for different rendering
              });
              
              // Play hit sound effect
              playSound(sounds.hit, 0.2);
              
              // Damage enemy based on weapon configuration
              const weaponDamage = game.weaponConfig?.damage || 0.015; // Default to .303 damage
              enemy.health -= weaponDamage;
              
              // Remove projectile
              game.projectiles.splice(projIndex, 1);
              
              // Trigger evasive action for intelligent enemies
              if (enemy.type === 'bf109' && !enemy.destroyed) {
                enemy.consecutiveHits++;
                enemy.timeSinceLastHit = 0;
                
                // Immediate evasion if taking fire
                if (enemy.aiState !== 'evade' && enemy.aiState !== 'boom_zoom') {
                  // Higher chance to evade if damaged or ace pilot
                  const evasionChance = enemy.skillLevel === 'ace' ? 0.8 : 0.6;
                  if (Math.random() < evasionChance || enemy.health <= 1) {
                    enemy.previousState = enemy.aiState;
                    enemy.aiState = 'evade';
                    enemy.stateTimer = 0;
                    enemy.evasionDirection = Math.random() > 0.5 ? 1 : -1;
                    enemy.isEvading = true;
                    console.log(`üí® ${enemy.skillLevel === 'ace' ? '‚≠ê Ace' : '‚úàÔ∏è'} BF-109 taking evasive action!`);
                  }
                }
              }
              
              // Progressive damage system with realistic crash physics
              if (enemy.health <= 0 && !enemy.destroyed) {
                enemy.destroyed = true;
                
                if (enemy.type === 'training_dummy') {
                  // Training dummy specific destruction
                  console.log('üéØ Training dummy destroyed!');
                  
                  // Create explosion effect
                  const pos = enemy.body.getPosition();
                  game.explosions.push({
                    x: pos.x,
                    y: pos.y,
                    time: 0,
                    duration: 1.0,
                    size: 15, // Smaller explosion for dummies
                    type: 'training'
                  });
                  
                  // Remove dummy immediately
                  world.destroyBody(enemy.body);
                  const enemyIndex = game.enemies.indexOf(enemy);
                  if (enemyIndex > -1) {
                    game.enemies.splice(enemyIndex, 1);
                  }
                  
                  // Notify mission manager
                  if (window.missionManager && window.campaignMode) {
                    window.missionManager.onEnemyDestroyed('training_dummy');
                  }
                  
                  return; // Skip aircraft-specific destruction logic
                }
                
                enemy.thrustReduction = 1.0; // Complete thrust loss
                enemy.liftReduction = 1.0; // Complete lift loss
                enemy.onFire = true;
                enemy.pitchingDown = true; // Mark for pitch down behavior
                console.log('üí• Enemy critically damaged - pitching down to crash');
                
                // Notify mission manager of enemy destroyed
                if (window.missionManager && window.campaignMode) {
                  const enemyType = enemy.isAce ? 'ace' : 'bf109';
                  window.missionManager.onEnemyDestroyed(enemyType);
                }
                
                // Stop excessive spinning when destroyed
                enemy.body.setAngularVelocity(0);
                // Apply gentle nose-down force (reduced from 50000)
                const crashTorque = 5000; // Much gentler downward pitch to avoid spinning
                enemy.body.applyTorque(crashTorque, true);
              } else {
                              // Progressive damage based on remaining health and aircraft type
              const damageRatio = 1 - (enemy.health / enemy.maxHealth);
              
              if (enemy.type === 'bf109') {
                // BF-109 damage thresholds (lower health)
                if (enemy.health <= 2) {
                  enemy.thrustReduction = Math.min(0.7, damageRatio * 1.0);
                  if (!enemy.smoking) {
                    enemy.smoking = true;
                    console.log('üí® BF-109 engine smoking');
                  }
                }
                
                if (enemy.health <= 1.5) {
                  enemy.liftReduction = Math.min(0.4, damageRatio * 0.5);
                  // Start losing control and pitching down when moderately damaged
                  if (!enemy.pitchingDown && (enemy.thrustReduction > 0.5 || enemy.liftReduction > 0.3)) {
                    enemy.pitchingDown = true;
                    console.log('üí® BF-109 losing control - starting descent');
                  }
                }
                
                if (enemy.health <= 1) {
                  enemy.liftReduction = Math.min(0.6, damageRatio * 0.7);
                  if (!enemy.onFire) {
                    enemy.onFire = true;
                    console.log('üî• BF-109 on fire - losing control');
                  }
                }
              } else {
                // Ju-88 damage thresholds (higher health)
                if (enemy.health <= 3) {
                  enemy.thrustReduction = Math.min(0.8, damageRatio * 1.2);
                  if (!enemy.smoking) {
                    enemy.smoking = true;
                    console.log('üí® Ju-88 engine smoking');
                  }
                }
                
                if (enemy.health <= 2.5) {
                  enemy.liftReduction = Math.min(0.5, damageRatio * 0.6);
                  // JU-88s start pitching down when heavily damaged
                  if (!enemy.pitchingDown && (enemy.thrustReduction > 0.6 || enemy.liftReduction > 0.4)) {
                    enemy.pitchingDown = true;
                    console.log('üí® JU-88 losing control - starting descent');
                  }
                }
                
                if (enemy.health <= 2) {
                  enemy.liftReduction = Math.min(0.7, damageRatio * 0.9);
                  if (!enemy.onFire) {
                    enemy.onFire = true;
                    console.log('üî• Ju-88 on fire - losing lift');
                  }
                }
              }
              }
            }
          });
        }
        
        function destroyEnemy(enemy) {
          // This function is now only called for ground impact destruction
          console.log('üí• Enemy destroyed by ground impact!');
          enemy.destroyed = true;
          
          const pos = enemy.body.getPosition();
          
          // Create destruction explosion effect only for ground impact
          game.explosions.push({
            x: pos.x,
            y: pos.y,
            time: 0,
            duration: 1.0, // 1 second explosion
            size: 20, // 40m explosion diameter
            type: 'destruction' // Mark as destruction explosion
          });
          
          // Play explosion sound effect
          playSound(sounds.explosion, 0.5);
          
          // Remove body from physics world
          world.destroyBody(enemy.body);
        }
        
        function updateExplosions(dt) {
          for (let i = game.explosions.length - 1; i >= 0; i--) {
            const explosion = game.explosions[i];
            explosion.time += dt;
            
            if (explosion.time >= explosion.duration) {
              game.explosions.splice(i, 1);
            }
          }
        }
      
      function checkEnemyProjectilePlayerCollision(proj, projIndex) {
        // Check if enemy bullet hits player
        const now = performance.now();
        if (now < game.spawnShieldUntil) return; // spawn protection
        
        // Tracers no longer interact with player - only visual effect
        if (proj.type === 'tracer') return;
        
        if (checkPlayerPixelCollision(proj.x, proj.y)) {
          console.log(`üí• Player hit by enemy fire! Projectile: ${proj.type || 'unknown'} at (${proj.x.toFixed(1)}, ${proj.y.toFixed(1)})`);
          
          // Create hit explosion effect
          game.explosions.push({
            x: proj.x,
            y: proj.y,
            time: 0,
            duration: 0.2,
            size: 2,
            type: 'hit'
          });
          
          // Play hit sound
          playSound(sounds.hit, 0.3);
          
          // Remove projectile
          game.enemyProjectiles.splice(projIndex, 1);
          
          // Player damage system (check god mode)
          if (!game.debug.godMode) {
            // Use hit points: each hit removes 1 (bullets only, not tracers)
            const damage = 1;
            game.playerHealth = Math.max(0, game.playerHealth - damage);
            if (game.playerHealth <= 0 && !game.crashed) {
              console.log('üíÄ Player destroyed!');
              game.crashed = true;
            }
          } else {
            console.log('üõ°Ô∏è God mode: projectile damage ignored');
          }
        }
      }
      
      function checkCollisionProjectilePhysicsHitbox(collisionProj, collisionIndex) {
        // Check if collision projectile hits the physics debug hitbox
        const playerPos = aircraft.getPosition();
        const playerAngle = aircraft.getAngle();
        
        // Check minimum distance from owner to prevent instant hits when overlapping
        if (collisionProj.owner && collisionProj.owner.body) {
          const ownerPos = collisionProj.owner.body.getPosition();
          const distFromOwner = Math.sqrt(
            (collisionProj.x - ownerPos.x) ** 2 + 
            (collisionProj.y - ownerPos.y) ** 2
          );
          // Skip collision if projectile is still too close to its owner (within 15 meters)
          // This prevents instant hits when player is overlapping with Ju-88
          if (distFromOwner < 15) {
            return false;
          }
        }
        
        // Use SMALL hitbox for collision projectiles - this was your original solution!
        // Small, tight hitbox dimensions (much smaller than pixel collision)
        const hitboxHalfWidth = 1.2;  // Small width in world units  
        const hitboxHalfHeight = 0.4; // Small height in world units
        
        // Simple distance check first
        const distance = Math.sqrt((collisionProj.x - playerPos.x) ** 2 + (collisionProj.y - playerPos.y) ** 2);
        
        // Transform collision projectile position to local player coordinates
        const dx = collisionProj.x - playerPos.x;
        const dy = collisionProj.y - playerPos.y;
        
        // Reverse rotation (rotate by -angle) to get local coordinates
        const cosA = Math.cos(-playerAngle);
        const sinA = Math.sin(-playerAngle);
        const localX = dx * cosA - dy * sinA;
        const localY = dx * sinA + dy * cosA;
        
        // Debug log for close projectiles
        if (distance < 5) {
          console.log(`üîç Collision check: Proj(${collisionProj.x.toFixed(1)}, ${collisionProj.y.toFixed(1)}) Player(${playerPos.x.toFixed(1)}, ${playerPos.y.toFixed(1)}) Local(${localX.toFixed(2)}, ${localY.toFixed(2)}) Small hitbox: ${hitboxHalfWidth*2}x${hitboxHalfHeight*2} Dist: ${distance.toFixed(2)}`);
        }
        
        // Check if within the SMALL collision box
        if (Math.abs(localX) <= hitboxHalfWidth && Math.abs(localY) <= hitboxHalfHeight) {
          console.log(`üéØ Collision projectile hit physics hitbox! Proj: (${collisionProj.x.toFixed(1)}, ${collisionProj.y.toFixed(1)})`);
          
          // Find and remove the corresponding tracer
          for (let i = game.enemyProjectiles.length - 1; i >= 0; i--) {
            const tracer = game.enemyProjectiles[i];
            if (tracer.type === 'tracer' && tracer.collisionId === collisionProj.collisionId) {
              game.enemyProjectiles.splice(i, 1);
              console.log(`‚ú® Removed tracer with ID ${tracer.collisionId}`);
              break;
            }
          }
          
          // Remove collision projectile
          if (!game.enemyCollisionProjectiles) game.enemyCollisionProjectiles = [];
          game.enemyCollisionProjectiles.splice(collisionIndex, 1);
          
          // Create small hit effect
          game.explosions.push({
            x: collisionProj.x,
            y: collisionProj.y,
            time: 0,
            duration: 0.2,
            size: 1.5,
            type: 'hit'
          });
          
          // Play hit sound
          playSound(sounds.hit, 0.3);
          
          // Apply damage (check god mode)
          if (!game.debug.godMode) {
            const damage = 1;
            game.playerHealth = Math.max(0, game.playerHealth - damage);
            if (game.playerHealth <= 0 && !game.crashed) {
              console.log('üíÄ Player destroyed!');
              game.crashed = true;
            }
          } else {
            console.log('üõ°Ô∏è God mode: collision projectile damage ignored');
          }
          
          return true; // Hit detected
        }
        
        return false; // No hit
      }
      
      function trySpawnGuns() {
        console.log('üî´ trySpawnGuns called');
        const now = performance.now();
        console.log('üïí Fire timing:', { now, lastFireTime, interval: fireInterval, canFire: now - lastFireTime >= fireInterval });
        if (now - lastFireTime < fireInterval) {
          console.log('‚è±Ô∏è Fire rate limited, skipping');
          return;
        }
        lastFireTime = now;
        
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const vel = aircraft.getLinearVelocity();
        
        // Center gun position (middle of plane)
        const gunForward = 2.0; // Forward from center to gun muzzle
        
        // Calculate gun position (center of plane)
        const gunPos = {
          x: pos.x + Math.cos(angle) * gunForward,
          y: pos.y + Math.sin(angle) * gunForward
        };
        
        // Muzzle velocity (relative to aircraft)
        const muzzleVelocity = 400; // m/s in physics units (increased from 150)
        const bulletVel = {
          x: vel.x + Math.cos(angle) * muzzleVelocity,
          y: vel.y + Math.sin(angle) * muzzleVelocity
        };
        
        // Increment shot counter and determine tracer pattern
        shotCounter++;
        // Spawn bullets and tracers (every 4th round is a tracer: bullet, bullet, bullet, tracer)
        const isTracer = shotCounter % 4 === 0;
        console.log(`üéØ Shot #${shotCounter}: ${isTracer ? 'TRACER' : 'BULLET'} (pattern: ${shotCounter % 4})`);
        
        // Center gun
        game.projectiles.push({
          x: gunPos.x,
          y: gunPos.y,
          vx: bulletVel.x,
          vy: bulletVel.y,
          type: isTracer ? 'tracer' : 'bullet',
          life: 5.0, // 5 seconds max flight time
          initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y)
        });
        
        // Spawn casing from bottom of aircraft
        const casingPos = {
          x: pos.x - Math.cos(angle) * 0.5, // Slightly behind center
          y: pos.y - Math.sin(angle) * 0.5 + 0.8 // Below aircraft
        };
        
        game.casings.push({
          x: casingPos.x,
          y: casingPos.y,
          vx: vel.x + (Math.random() - 0.5) * 10, // Random sideways velocity
          vy: vel.y + 15 + Math.random() * 10, // Downward with randomness
          rotation: Math.random() * Math.PI * 2,
          angularVel: (Math.random() - 0.5) * 20,
          life: 10.0 // Casings last longer
        });
        
        // Play gunfire sound effect
        playSound(sounds.gunfire, 0.3);
        
        console.log('üî´ Fired guns! Projectiles:', game.projectiles.length, 'Casings:', game.casings.length);
        console.log('üéØ Latest projectile:', game.projectiles[game.projectiles.length - 1]);
        console.log('üéØ Latest casing:', game.casings[game.casings.length - 1]);
      }
      
      function updateProjectiles(dt) {
        // Update player bullets and tracers
        for (let i = game.projectiles.length - 1; i >= 0; i--) {
          const proj = game.projectiles[i];
          
          // Check collision with enemies before updating position
          checkProjectileEnemyCollision(proj, i);
          
          // Apply drag
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const dragCoeff = 0.02; // Air resistance
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            proj.vx -= (proj.vx / speed) * drag * dt;
            proj.vy -= (proj.vy / speed) * drag * dt;
          }
          
          // Update position
          proj.x += proj.vx * dt;
          proj.y += proj.vy * dt;
          
          // Decrease life
          proj.life -= dt;
          
          // Remove if expired
          if (proj.life <= 0) {
            game.projectiles.splice(i, 1);
          }
        }
        
        // Update enemy projectiles
        if (game.enemyProjectiles) {
          for (let i = game.enemyProjectiles.length - 1; i >= 0; i--) {
            const proj = game.enemyProjectiles[i];
            
            // Check collision with player
            checkEnemyProjectilePlayerCollision(proj, i);
            
            // Apply drag
            const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
            const dragCoeff = 0.02;
            const drag = dragCoeff * speed;
            
            if (speed > 0) {
              proj.vx -= (proj.vx / speed) * drag * dt;
              proj.vy -= (proj.vy / speed) * drag * dt;
            }
            
            // Update position
            proj.x += proj.vx * dt;
            proj.y += proj.vy * dt;
            
            // Decrease life
            proj.life -= dt;
            
            // Remove if expired
            if (proj.life <= 0) {
              game.enemyProjectiles.splice(i, 1);
            }
          }
        }
        
        // Update enemy collision projectiles (for tracer collision detection)
        if (game.enemyCollisionProjectiles) {
  
          for (let i = game.enemyCollisionProjectiles.length - 1; i >= 0; i--) {
            const collisionProj = game.enemyCollisionProjectiles[i];
            
            // Check collision with physics debug hitbox
            checkCollisionProjectilePhysicsHitbox(collisionProj, i);
            
            // Apply same physics as regular projectiles
            const speed = Math.sqrt(collisionProj.vx * collisionProj.vx + collisionProj.vy * collisionProj.vy);
            const dragCoeff = 0.02;
            const drag = dragCoeff * speed;
            
            if (speed > 0) {
              collisionProj.vx -= (collisionProj.vx / speed) * drag * dt;
              collisionProj.vy -= (collisionProj.vy / speed) * drag * dt;
            }
            
            // Update position
            collisionProj.x += collisionProj.vx * dt;
            collisionProj.y += collisionProj.vy * dt;
            
            // Decrease life
            collisionProj.life -= dt;
            
            // Remove if expired
            if (collisionProj.life <= 0) {
              // Also remove corresponding tracer if it still exists
              for (let j = game.enemyProjectiles.length - 1; j >= 0; j--) {
                const tracer = game.enemyProjectiles[j];
                if (tracer.type === 'tracer' && tracer.collisionId === collisionProj.collisionId) {
                  game.enemyProjectiles.splice(j, 1);
                  console.log(`‚è∞ Tracer expired with collision projectile ID ${collisionProj.collisionId}`);
                  break;
                }
              }
              game.enemyCollisionProjectiles.splice(i, 1);
            }
          }
        }
        
        // Update casings
        for (let i = game.casings.length - 1; i >= 0; i--) {
          const casing = game.casings[i];
          
          // Apply gravity and drag
          casing.vy += 9.81 * dt; // Gravity
          
          const speed = Math.sqrt(casing.vx * casing.vx + casing.vy * casing.vy);
          const dragCoeff = 0.8; // Extreme drag for casings (was 0.3)
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            casing.vx -= (casing.vx / speed) * drag * dt;
            casing.vy -= (casing.vy / speed) * drag * dt;
          }
          
          // Update position and rotation
          casing.x += casing.vx * dt;
          casing.y += casing.vy * dt;
          casing.rotation += casing.angularVel * dt;
          
          // Decrease life
          casing.life -= dt;
          
          // Remove if expired
          if (casing.life <= 0) {
            game.casings.splice(i, 1);
          }
        }
      }
      
      // Add collision detection for landing/crashing system
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check for aircraft-enemy collision (plane to plane)
        const isAircraftA = bodyA === aircraft;
        const isAircraftB = bodyB === aircraft;
        const enemyDataA = bodyA.getUserData();
        const enemyDataB = bodyB.getUserData();
        const enemyFromA = enemyDataA?.type === 'enemy' ? enemyDataA.enemy : null;
        const enemyFromB = enemyDataB?.type === 'enemy' ? enemyDataB.enemy : null;
        
        if ((isAircraftA && enemyFromB) || (isAircraftB && enemyFromA)) {
          // Spawn shield & short collision grace: ignore mid-air collisions to avoid instant deaths
          const now = performance.now();
          if (now < (game.spawnShieldUntil || 0)) return;
          if (now < (game.playerCollisionCooldownUntil || 0)) return;
          const enemy = enemyFromA || enemyFromB;
          
          if (!enemy.destroyed) {
            console.log('‚úàÔ∏èüí• Mid-air collision with enemy!');
            
            // Special handling for training dummies
            if (enemy.type === 'training_dummy') {
              console.log('üéØ Player crashed into training dummy!');
              
              // Instantly destroy training dummy
              enemy.health = 0;
              enemy.destroyed = true;
              
              // Create explosion effect
              const pos = enemy.body.getPosition();
              game.explosions.push({
                x: pos.x,
                y: pos.y,
                time: 0,
                duration: 1.0,
                size: 15, // Smaller explosion for dummies
                type: 'training'
              });
              
              // Remove dummy immediately
              world.destroyBody(enemy.body);
              const enemyIndex = game.enemies.indexOf(enemy);
              if (enemyIndex > -1) {
                game.enemies.splice(enemyIndex, 1);
              }
              
              // Notify mission manager
              if (window.missionManager && window.campaignMode) {
                window.missionManager.onEnemyDestroyed('training_dummy');
              }
              
              // Player takes minor damage from collision
              if (!game.debug.godMode) {
                game.playerHealth = Math.max(0, game.playerHealth - 1);
                if (game.playerHealth <= 0) {
                  game.crashed = true;
                }
              }
              
              return; // Skip standard aircraft collision handling
            }
            
            // Pixel-perfect verification: only collide if opaque pixels overlap
            if (!checkPlanePlanePixelOverlap(enemy)) {
              // Ignore false positives from broad-phase contact
              return;
            }
            
            // Calculate relative velocity for collision force determination
            const playerVel = aircraft.getLinearVelocity();
            const enemyVel = enemy.body.getLinearVelocity();
            const relativeVel = {
              x: playerVel.x - enemyVel.x,
              y: playerVel.y - enemyVel.y
            };
            const relativeSpeed = Math.sqrt(relativeVel.x * relativeVel.x + relativeVel.y * relativeVel.y) * VISUAL_SCALE;
            
            console.log(`üí• Direct collision with enemy aircraft! Relative speed: ${relativeSpeed.toFixed(1)} m/s`);
            
            if (relativeSpeed < 2.0) {
              // Low speed collision - minor damage, no explosions
              console.log('üí® Low speed collision - minor damage only');
              if (!game.debug.godMode) {
                game.playerHealth = Math.max(0, game.playerHealth - 1);
                if (game.playerHealth <= 0) {
                  game.crashed = true;
                }
              }
              enemy.health = Math.max(0, enemy.health - 1);
            } else {
              // High speed collision - both aircraft destroyed
              console.log('üí• High speed collision - mutual destruction!');
              
              // Player aircraft explodes
              if (!game.debug.godMode) {
                game.playerHealth = 0;
                game.crashed = true;
                
                // Create player explosion
                const playerPos = aircraft.getPosition();
                game.explosions.push({
                  x: playerPos.x,
                  y: playerPos.y,
                  time: 0,
                  duration: 1.5,
                  size: 25,
                  type: 'destruction'
                });
              }
              
              // Enemy aircraft explodes
              enemy.health = 0;
              enemy.destroyed = true;
              enemy.thrustReduction = 1.0;
              enemy.liftReduction = 1.0;
              enemy.onFire = true;
              enemy.pitchingDown = true;
              
              // Create enemy explosion
              const enemyPos = enemy.body.getPosition();
              game.explosions.push({
                x: enemyPos.x,
                y: enemyPos.y,
                time: 0,
                duration: 1.5,
                size: 20,
                type: 'destruction'
              });
              
              // Notify mission manager of enemy destroyed
              if (window.missionManager && window.campaignMode) {
                const enemyType = enemy.isAce ? 'ace' : enemy.type;
                window.missionManager.onEnemyDestroyed(enemyType);
              }
            }
            
            // Destroy enemy if killed
            if (enemy.health <= 0 && !enemy.destroyed) {
              destroyEnemy(enemy);
            }
            
            // Apply collision forces to separate aircraft (only if both aircraft still exist)
            if (!game.crashed && !enemy.destroyed) {
              // Bounce apart
              aircraft.setLinearVelocity(pl.Vec2(playerVel.x * -0.5, playerVel.y * 0.3));
              enemy.body.setLinearVelocity(pl.Vec2(enemyVel.x * -0.5, enemyVel.y * 0.3));
              
              // Add spin from collision
              aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 10);
              enemy.body.setAngularVelocity(enemy.body.getAngularVelocity() + (Math.random() - 0.5) * 10);
            }
          } // Close: if (!enemy.destroyed)
          
          return; // Skip ground check if we hit an enemy
        } // Close: if ((isAircraftA && enemyFromB) || (isAircraftB && enemyFromA))
        
        // Enhanced ground collision for realistic landing/takeoff
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const verticalSpeed = Math.abs(vel.y);
          const horizontalSpeed = Math.abs(vel.x);
          const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          game.onGround = true;
          game.groundSpeed = horizontalSpeed;
          
          console.log(`üõ¨ Ground contact - Vertical: ${verticalSpeed.toFixed(1)} m/s, Horizontal: ${horizontalSpeed.toFixed(1)} m/s, Gear: ${game.gearDown ? 'DOWN' : 'UP'}`);
          
          // Improved landing physics
          const crashThreshold = game.gearDown ? 10.0 : 6.0; // Higher tolerance with gear
          const hardLandingThreshold = game.gearDown ? 6.0 : 3.0;
          
          if (verticalSpeed > crashThreshold) {
            // High vertical speed = crash
            game.crashed = true;
            console.log('üí• CRASHED! Vertical speed too high:', verticalSpeed.toFixed(1), 'm/s');
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else if (verticalSpeed > hardLandingThreshold) {
            // Hard landing
            const gearProtection = game.gearDown ? 0.7 : 0.3; // Gear absorbs impact
            console.log(game.gearDown ? '‚ö†Ô∏è Hard landing with gear!' : '‚ö†Ô∏è Hard landing without gear!');
            
            // Apply ground friction and impact absorption
            const frictionCoeff = game.gearDown ? 0.95 : 0.85; // Gear has better braking
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * frictionCoeff * gearProtection,
              Math.min(vel.y * 0.1, 0) // Absorb vertical impact
            ));
            
            // Add instability for gear-up landings
            if (!game.gearDown) {
              aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 3);
            }
          } else {
            // Smooth landing
            const friction = game.gearDown ? 0.98 : 0.92; // Gear provides better control
            console.log(game.gearDown ? '‚úÖ Smooth landing with gear!' : 'üü° Belly landing');
            
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * friction,
              Math.min(vel.y * 0.05, 0) // Gentle touchdown
            ));
          }
        }
        
        // Check if enemy aircraft hit ground
        const enemyBodyA = bodyA.getUserData()?.type === 'enemy' ? bodyA : null;
        const enemyBodyB = bodyB.getUserData()?.type === 'enemy' ? bodyB : null;
        
        if (enemyBodyA || enemyBodyB) {
          const enemyBody = enemyBodyA || enemyBodyB;
          const enemy = enemyBody.getUserData().enemy;
          
          if (enemy && !enemy.destroyed) {
            const vel = enemyBody.getLinearVelocity();
            const verticalSpeed = Math.abs(vel.y);
            const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
            
            console.log(`üí• Enemy ground collision! Vertical: ${verticalSpeed.toFixed(1)} m/s, Total: ${totalSpeed.toFixed(1)} m/s`);
            
            // Enemy takes damage based on impact speed and current damage state
            let damage = 0;
            const isJu88 = enemy.type === 'ju88';
            
            // Check if aircraft is already damaged/compromised
            const isDamaged = enemy.onFire || enemy.smoking || 
                            enemy.thrustReduction > 0.3 || enemy.liftReduction > 0.2 || 
                            enemy.pitchingDown || enemy.health < enemy.maxHealth * 0.7;
            
            // Damaged aircraft explode much easier on ground impact
            const damagePenalty = isDamaged ? 0.3 : 1.0; // 70% reduction in impact tolerance
            
            if (isJu88) {
              // Ju-88s are much more fragile on ground impact
              const explosiveThreshold = 8 * damagePenalty; // 2.4 m/s for damaged aircraft
              const majorThreshold = 4 * damagePenalty; // 1.2 m/s for damaged aircraft
              const minorThreshold = 2 * damagePenalty; // 0.6 m/s for damaged aircraft
              
              if (verticalSpeed > explosiveThreshold) {
                damage = 10; // High speed impact - explosive damage for Ju-88s
                console.log(`üí• Ju-88 ${isDamaged ? '(damaged)' : ''} heavy ground impact - explosive damage!`);
              } else if (verticalSpeed > majorThreshold) {
                damage = 6; // Medium speed impact - major damage for Ju-88s
                console.log(`üí• Ju-88 ${isDamaged ? '(damaged)' : ''} moderate ground impact - major damage!`);
              } else if (verticalSpeed > minorThreshold) {
                damage = 3; // Low speed impact - still significant damage for Ju-88s
                console.log(`üí• Ju-88 ${isDamaged ? '(damaged)' : ''} light ground impact - damage taken!`);
              }
            } else {
              // BF-109s are more resilient but still fragile when damaged
              const explosiveThreshold = 15 * damagePenalty; // 4.5 m/s for damaged aircraft
              const majorThreshold = 8 * damagePenalty; // 2.4 m/s for damaged aircraft  
              const minorThreshold = 3 * damagePenalty; // 0.9 m/s for damaged aircraft
              
              if (verticalSpeed > explosiveThreshold) {
                damage = 5; // High speed impact - major damage
                console.log(`üí• BF-109 ${isDamaged ? '(damaged)' : ''} heavy ground impact - major damage!`);
              } else if (verticalSpeed > majorThreshold) {
                damage = 3; // Medium speed impact - moderate damage
                console.log(`üí• BF-109 ${isDamaged ? '(damaged)' : ''} moderate ground impact - damage taken!`);
              } else if (verticalSpeed > minorThreshold) {
                damage = 1; // Low speed impact - minor damage
                console.log(`üí• BF-109 ${isDamaged ? '(damaged)' : ''} light ground contact - minor damage!`);
              }
            }
            
            // Damaged aircraft take extra impact damage
            if (isDamaged && damage > 0) {
              damage += 1; // Extra damage for already compromised aircraft
              console.log(`üî• Extra damage applied to compromised aircraft!`);
            }
            
            if (damage > 0) {
              enemy.health -= damage;
              console.log(`‚ö†Ô∏è Enemy health: ${enemy.health}/${enemy.maxHealth}`);
              
              // Check if enemy is destroyed
              if (enemy.health <= 0 && !enemy.destroyed) {
                destroyEnemy(enemy);
              } else {
                // Reduce enemy speed on ground impact
                enemyBody.setLinearVelocity(pl.Vec2(vel.x * 0.4, vel.y * 0.1));
                // Add some spin from the impact
                enemyBody.setAngularVelocity(enemyBody.getAngularVelocity() + (Math.random() - 0.5) * 4);
              }
            }
          }
        }
      });
      
      // Add ground contact end detection for takeoff
      world.on('end-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft left ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          // Small delay to ensure we're actually airborne
          setTimeout(() => {
            const pos = aircraft.getPosition();
            const groundClearance = -pos.y; // Distance above ground
            if (groundClearance > 2) { // 4m clearance before considering truly airborne
              game.onGround = false;
              game.groundSpeed = 0;
              console.log('üõ´ Aircraft airborne');
            }
          }, 100);
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUpFast = game.keys.has('a');      // A = Fast pitch up
        const pitchDownFast = game.keys.has('d');    // D = Fast pitch down
        const pitchUpSlow = game.keys.has('q');      // Q = Slow pitch up (was zoom out)
        const pitchDownSlow = game.keys.has('e');    // E = Slow pitch down (was zoom in)
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, -300), 0); // Reset to safe altitude above ground (scaled)
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          game.playerHealth = game.playerMaxHealth; // Restore full health on respawn
          game.spawnShieldUntil = performance.now() + 4000; // Reset spawn protection
          console.log('üîÑ Player respawned with full health');
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom is now handled by mouse wheel only (Q/E now used for slow pitch)
        
        // Calculate speed once for use in both controls and aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        // Flight controls - Hybrid approach (force + torque for reliability)
        const controlEffectiveness = Math.min(speed * 0.1, 1.0); // Controls more effective at higher speeds
        const controlTorque = 20000 * controlEffectiveness; // Moderate torque for reliable control
        
        // Pitch controls - immediate stop when no input
        const anyPitchInput = pitchUpFast || pitchDownFast || pitchUpSlow || pitchDownSlow;
        
        if (!anyPitchInput) {
          // Immediate stop - apply counter-torque to stop rotation
          const currentAngularVel = aircraft.getAngularVelocity();
          const stopTorque = -currentAngularVel * 800; // Strong damping for instant stop
          aircraft.applyTorque(stopTorque, true);
        } else {
          // Apply pitch input
          if (pitchUpFast) {
            aircraft.applyTorque(-controlTorque, true); // Full speed up
          }
          if (pitchDownFast) {
            aircraft.applyTorque(controlTorque, true);  // Full speed down
          }
          if (pitchUpSlow) {
            aircraft.applyTorque(-controlTorque * 0.3, true); // 30% speed up
          }
          if (pitchDownSlow) {
            aircraft.applyTorque(controlTorque * 0.3, true);  // 30% speed down
          }
        }
        
        // Debug control inputs
        if (Math.random() < 0.02) { // Occasional debug logging
          console.log('üéÆ Controls:', { fastUp: pitchUpFast, fastDown: pitchDownFast, slowUp: pitchUpSlow, slowDown: pitchDownSlow, effectiveness: controlEffectiveness.toFixed(2) });
        }
        if (rollLeft) {
          aircraft.applyTorque(-controlTorque * 0.6, true);
        }
        if (rollRight) {
          aircraft.applyTorque(controlTorque * 0.6, true);
        }
        
        // Continuous firing while holding space
        const firing = game.keys.has(' ');
        if (firing) {
          trySpawnGuns();
        }
        
        // Enhanced thrust system with ground effects
        let maxThrust = 300000; // Base thrust
        
        // Ground effect: slightly reduced thrust efficiency on ground
        if (game.onGround) {
          maxThrust *= 0.95; // 5% reduction on ground due to prop wash
        }
        
        // Gear drag: landing gear creates extra drag
        if (game.gearDown) {
          maxThrust *= 0.9; // 10% thrust reduction with gear down
        }
        
        // Altitude-based thrust reduction (same as lift)
        const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
        if (visualAltitude > 5000) {
          if (visualAltitude >= 5250) {
            maxThrust = 0; // No thrust above 5250m (engine failure)
          } else {
            // Linear reduction from 5000m to 5250m
            const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
            maxThrust *= reductionFactor;
          }
        }
        
        // Ground roll physics for takeoff
        if (game.onGround && game.groundSpeed < 25) { // Below takeoff speed
          maxThrust *= 1.1; // Extra thrust for ground roll
        }
        
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // CRITICAL FIX: Manually override Box2D's velocity cap
        // Box2D caps at ~120 m/s physics (240 m/s visual), we need to break through
        const currentSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        const targetSpeed = game.throttle * 250; // Target speed based on throttle (up to 250 m/s physics = 500 m/s visual)
        
        // If we're near the 120 m/s cap and should be going faster, boost manually
        if (game.throttle > 0.5 && currentSpeed > 115 && currentSpeed < 125 && targetSpeed > currentSpeed) {
          const velocityDirection = Math.atan2(vel.y, vel.x);
          const newVelX = Math.cos(velocityDirection) * targetSpeed;
          const newVelY = Math.sin(velocityDirection) * targetSpeed;
          aircraft.setLinearVelocity(pl.Vec2(newVelX, newVelY));
          console.log(`‚ö° Breaking speed cap: ${(currentSpeed * VISUAL_SCALE).toFixed(0)} ‚Üí ${(targetSpeed * VISUAL_SCALE).toFixed(0)} m/s`);
        }
        
        // Enhanced aerodynamics with ground effects and gear effects
        if (speed > 1) {
          const airDensity = 1.225;
          let wingArea = 20;
          
          // Ground effect: increased lift near ground
          if (game.onGround || -pos.y < 5) { // Within 10m of ground
            wingArea *= 1.15; // 15% more effective wing area in ground effect
          }
          
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified) with altitude-based reduction
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          let liftCoeff = Math.sin(aoa * 2) * 1.5;
          
          // Gear effects on lift
          if (game.gearDown) {
            liftCoeff *= 0.9; // Gear creates some disruption to airflow
          }
          
          // Altitude-based lift reduction (physics units, converted to visual for calculation)
          const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
          if (visualAltitude > 5000) {
            if (visualAltitude >= 5250) {
              liftCoeff = 0; // No lift above 5250m
            } else {
              // Linear reduction from 5000m to 5250m
              const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
              liftCoeff *= reductionFactor;
            }
          }
          
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag - Minimized for very high top speeds
          const dragCoeff = 0.005 + Math.abs(liftCoeff) * 0.005; // Even lower drag to break 240 m/s barrier
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background - main map in center, tileable on sides
        const groundLevel = 0; // physical ground reference
        const mapHeight = WORLD_HEIGHT;
        
        if (assets.loaded.map && assets.map && assets.loaded.tileableMap && assets.tileableMap) {
          // Calculate main map dimensions and position
          const mainMapWidth = WORLD_WIDTH; // 4000m wide
          const mainMapPixelWidth = mainMapWidth * SCALE * game.camera.zoom;
          const mainMapPixelHeight = mapHeight * SCALE * game.camera.zoom;
          // Draw main map in center such that its bottom sits at MAP_BOTTOM_ALTITUDE
          // So the draw origin (top-left) is at y = (MAP_BOTTOM_ALTITUDE - mapHeight)
          const mainMapPos = worldToScreen(-mainMapWidth/2, MAP_BOTTOM_ALTITUDE - mapHeight);
          ctx.drawImage(assets.map, mainMapPos.x, mainMapPos.y, mainMapPixelWidth, mainMapPixelHeight);
          
          // Calculate tileable map dimensions
          const tileableMapNaturalRatio = assets.tileableMap.naturalWidth / assets.tileableMap.naturalHeight;
          const tileableMapPixelHeight = mainMapPixelHeight; // Same height as main map
          const tileableMapPixelWidth = tileableMapPixelHeight * tileableMapNaturalRatio;
          const tileableMapWorldWidth = tileableMapPixelWidth / (SCALE * game.camera.zoom);
          
          // Draw tileable maps on the left side
          const leftStartX = -mainMapWidth/2;
          const visibleLeftStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - leftStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + leftStartX;
          for (let x = visibleLeftStart; x > game.camera.x - canvasWidth/(SCALE*game.camera.zoom); x -= tileableMapWorldWidth) {
            const tilePos = worldToScreen(x - tileableMapWorldWidth, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
          // Draw tileable maps on the right side
          const rightStartX = mainMapWidth/2;
          const visibleRightStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - rightStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + rightStartX;
          for (let x = visibleRightStart; x < game.camera.x + canvasWidth/(SCALE*game.camera.zoom); x += tileableMapWorldWidth) {
            const tilePos = worldToScreen(x, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map || !assets.loaded.tileableMap) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading maps...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        // Debug: Log aircraft state periodically
        if (Math.random() < 0.02) { // 2% chance per frame for debugging
          console.log('‚úàÔ∏è Aircraft state:', {
            angle: (angle * 180 / Math.PI).toFixed(1) + '¬∞',
            inverted: game.inverted,
            gearDown: game.gearDown,
            position: { x: pos.x.toFixed(1), y: pos.y.toFixed(1) },
            expectedSprite: game.inverted && game.gearDown ? 'inverted+gear' : 
                          game.inverted && !game.gearDown ? 'inverted' :
                          !game.inverted && game.gearDown ? 'normal+gear' : 'normal'
          });
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        // Choose sprite based on inverted mode and gear state
        let currentSprite, spriteLoaded, spriteDescription;
        
        if (game.inverted && game.gearDown) {
          currentSprite = assets.spitfireInvertedGear;
          spriteLoaded = assets.loaded.spitfireInvertedGear;
          spriteDescription = "inverted with gear";
        } else if (game.inverted && !game.gearDown) {
          currentSprite = assets.spitfireInverted;
          spriteLoaded = assets.loaded.spitfireInverted;
          spriteDescription = "inverted no gear";
        } else if (!game.inverted && game.gearDown) {
          currentSprite = assets.spitfireGear;
          spriteLoaded = assets.loaded.spitfireGear;
          spriteDescription = "normal with gear";
        } else {
          currentSprite = assets.spitfire;
          spriteLoaded = assets.loaded.spitfire;
          spriteDescription = "normal no gear";
        }
        
        // Debug: Log sprite selection when gear changes
        if (game.keys.has('g') && Math.random() < 0.1) { // 10% chance when G is held
          console.log('üé® Sprite selection:', {
            description: spriteDescription,
            spriteLoaded: spriteLoaded,
            hasSprite: !!currentSprite,
            allLoadStates: assets.loaded
          });
        }
        
        if (spriteLoaded && currentSprite) {
          const scale = 0.4 * game.camera.zoom;
          const w = currentSprite.naturalWidth * scale;
          const h = currentSprite.naturalHeight * scale;
          ctx.drawImage(currentSprite, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          let fillColor = '#4169E1'; // Default blue
          if (game.inverted && game.gearDown) fillColor = '#800080'; // Purple for inverted with gear
          else if (game.inverted) fillColor = '#E14169'; // Red for inverted
          else if (game.gearDown) fillColor = '#228B22'; // Green for gear down
          
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = game.inverted ? '#801080' : '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
          
          // Draw gear indicator
          if (game.gearDown) {
            ctx.fillStyle = '#FFD700'; // Gold for gear
            ctx.fillRect(-size*0.3, size*0.3, size*0.6, size*0.2);
          }
        }
        
        ctx.restore();
        
        // Render projectiles (bullets and tracers)
        if (game.projectiles.length > 0) {
          console.log('üé® Rendering', game.projectiles.length, 'projectiles');
        }
        game.projectiles.forEach(proj => {
          const screenPos = worldToScreen(proj.x, proj.y);
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const angle = Math.atan2(proj.vy, proj.vx);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(angle);
          
          if (proj.type === 'tracer') {
            // Tracer gets smaller as it slows down, but maintains world scale
            const speedRatio = speed / proj.initialSpeed;
            const sizeMultiplier = 1.3; // 1.3x size increase as requested
            const tracerLength = TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom * sizeMultiplier;
            const tracerWidth = TRACER_WIDTH * speedRatio * SCALE * game.camera.zoom * sizeMultiplier;
            
            // Bright yellow tracer with glow effect
            ctx.shadowColor = '#FFFF00';
            ctx.shadowBlur = 8 * game.camera.zoom;
            
            if (assets.loaded.tracer && assets.tracer) {
              // Apply yellow tint to sprite
              ctx.globalCompositeOperation = 'screen';
              ctx.fillStyle = '#FFFF00';
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              ctx.globalCompositeOperation = 'source-over';
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else {
              // Fallback tracer - bright yellow with gradient
              const gradient = ctx.createLinearGradient(-tracerLength/2, 0, tracerLength/2, 0);
              gradient.addColorStop(0, `rgba(255, 255, 100, ${Math.max(0.4, 0.6 * speedRatio)})`);
              gradient.addColorStop(0.5, `rgba(255, 255, 0, ${Math.max(0.8, 1.0 * speedRatio)})`);
              gradient.addColorStop(1, `rgba(255, 255, 200, ${Math.max(0.4, 0.6 * speedRatio)})`);
              ctx.fillStyle = gradient;
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              
              // Add bright core
              ctx.fillStyle = `rgba(255, 255, 255, ${Math.max(0.6, 0.9 * speedRatio)})`;
              ctx.fillRect(-tracerLength/4, -tracerWidth/4, tracerLength/2, tracerWidth/2);
            }
            
            // Reset shadow
            ctx.shadowBlur = 0;
          } else {
            // Regular bullet - world scale
            const bulletSize = BULLET_SIZE * SCALE * game.camera.zoom;
            
            if (assets.loaded.bullet && assets.bullet) {
              const scale = bulletSize / Math.max(assets.bullet.naturalWidth, assets.bullet.naturalHeight);
              const w = assets.bullet.naturalWidth * scale;
              const h = assets.bullet.naturalHeight * scale;
              ctx.drawImage(assets.bullet, -w/2, -h/2, w, h);
            } else {
              // Fallback bullet - bright gold/yellow
              ctx.fillStyle = '#FFD700';
              ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
            }
          }
          
          ctx.restore();
        });
        
        // Render casings
        game.casings.forEach(casing => {
          const screenPos = worldToScreen(casing.x, casing.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(casing.rotation);
          
          const casingSize = CASING_SIZE * SCALE * game.camera.zoom;
          
          if (assets.loaded.casing && assets.casing) {
            const scale = casingSize / Math.max(assets.casing.naturalWidth, assets.casing.naturalHeight);
            const w = assets.casing.naturalWidth * scale;
            const h = assets.casing.naturalHeight * scale;
            ctx.drawImage(assets.casing, -w/2, -h/2, w, h);
          } else {
            // Fallback casing - brass colored
            ctx.fillStyle = '#DAA520'; // Dark golden rod (brass color)
            ctx.fillRect(-casingSize/2, -casingSize/3, casingSize, casingSize*2/3);
          }
          
          ctx.restore();
        });
        
        // Render enemies
        game.enemies.forEach(enemy => {
          if (enemy.destroyed && !enemy.pitchingDown) return;
          
          const pos = enemy.body.getPosition();
          const angle = enemy.body.getAngle();
          const screenPos = worldToScreen(pos.x, pos.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          
          if (enemy.type === 'training_dummy') {
            // Training dummy rendering - yellow sphere
            const radius = 3 * SCALE * game.camera.zoom; // 6m diameter sphere
            
            // Draw shadow first
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(radius * 0.3, radius * 0.3, radius * 0.8, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            
            // Draw main sphere with gradient
            const gradient = ctx.createRadialGradient(-radius * 0.3, -radius * 0.3, 0, 0, 0, radius);
            gradient.addColorStop(0, '#FFFF99'); // Light yellow
            gradient.addColorStop(0.6, '#FFD700'); // Golden yellow
            gradient.addColorStop(1, '#B8860B'); // Dark golden rod
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add outline
            ctx.strokeStyle = '#FF8C00'; // Dark orange
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Add health indicator
            if (enemy.health < enemy.maxHealth) {
              const healthPercent = enemy.health / enemy.maxHealth;
              const barWidth = radius * 2;
              const barHeight = 4;
              const barY = -radius - 10;
              
              // Background
              ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
              ctx.fillRect(-barWidth/2, barY, barWidth, barHeight);
              
              // Health bar
              ctx.fillStyle = 'rgba(0, 255, 0, 0.9)';
              ctx.fillRect(-barWidth/2, barY, barWidth * healthPercent, barHeight);
              
              // Border
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 1;
              ctx.strokeRect(-barWidth/2, barY, barWidth, barHeight);
            }
            
          } else if (enemy.type === 'bf109') {
            // BF-109 rendering
            ctx.rotate(angle);
            
            const baseSize = 16 * SCALE * game.camera.zoom; // Doubled fighter size
            let sprite = null;
            let spriteLoaded = false;
            
            // Always use bf109Left sprite (only one available) and flip if needed
            sprite = assets.bf109Left;
            spriteLoaded = assets.loaded.bf109Left;
            
            if (spriteLoaded && sprite) {
              const aspectRatio = sprite.naturalWidth / sprite.naturalHeight;
              const width = baseSize * aspectRatio;
              const height = baseSize;
              
              // Add golden glow for ace pilots
              if (enemy.skillLevel === 'ace' && !enemy.destroyed) {
                ctx.shadowColor = '#FFD700';
                ctx.shadowBlur = 10 * game.camera.zoom;
                ctx.globalAlpha = 0.9;
              }
              
              // Flip based on facing direction
              if (enemy.facingDirection === 'right') {
                // Flip horizontally and vertically for right-facing
                ctx.scale(-1, -1);
              } else {
                // Just flip vertically for left-facing
                ctx.scale(1, -1);
              }
              ctx.drawImage(sprite, -width/2, -height/2, width, height);
              ctx.scale(1, 1); // Reset to normal
              
              // Reset shadow and alpha
              ctx.shadowBlur = 0;
              ctx.globalAlpha = 1.0;
            } else {
              // Improved fallback BF-109 - try opposite sprite or draw aircraft shape
              let alternateSprite = null;
              let alternateLoaded = false;
              
              // Always use bf109Left as fallback (only sprite available)
              alternateSprite = assets.bf109Left;
              alternateLoaded = assets.loaded.bf109Left;
              
              if (alternateLoaded && alternateSprite) {
                // Use the alternate sprite (might be backwards but better than rectangle)
                const aspectRatio = alternateSprite.naturalWidth / alternateSprite.naturalHeight;
                const width = baseSize * aspectRatio;
                const height = baseSize;
                
                // Add golden glow for ace pilots
                if (enemy.skillLevel === 'ace' && !enemy.destroyed) {
                  ctx.shadowColor = '#FFD700';
                  ctx.shadowBlur = 10 * game.camera.zoom;
                  ctx.globalAlpha = 0.9;
                }
                
                ctx.scale(1, -1);
                ctx.drawImage(alternateSprite, -width/2, -height/2, width, height);
                ctx.scale(1, -1);
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;
              } else {
                // Final fallback - draw aircraft-shaped polygon instead of rectangle
                const width = baseSize * 1.5;
                const height = baseSize;
                
                // Choose color based on state
                let baseColor = '#666666';
                if (enemy.onFire) baseColor = '#8B0000';
                else if (enemy.smoking) baseColor = '#808080';
                else if (enemy.skillLevel === 'ace') baseColor = '#444499';
                
                ctx.fillStyle = baseColor;
                
                // Draw aircraft shape (simple triangle with wings)
                ctx.beginPath();
                ctx.moveTo(width/2, 0); // Nose
                ctx.lineTo(-width/2, -height/3); // Left wing
                ctx.lineTo(-width/3, 0); // Fuselage back left
                ctx.lineTo(-width/2, height/3); // Right wing
                ctx.lineTo(width/2, 0); // Back to nose
                ctx.closePath();
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = enemy.skillLevel === 'ace' ? '#FFD700' : '#333333';
                ctx.lineWidth = enemy.skillLevel === 'ace' ? 2 : 1;
                ctx.stroke();
              }
            }
            
            // Add ace indicator star
            if (enemy.skillLevel === 'ace' && !enemy.destroyed) {
              ctx.fillStyle = '#FFD700';
              ctx.font = `${8 * game.camera.zoom}px Arial`;
              ctx.textAlign = 'center';
              ctx.fillText('‚≠ê', 0, -baseSize);
            }
          } else {
            // Ju-88 rendering (existing code)
            ctx.rotate(angle);
            
            const originalAspectRatio = assets.loaded.ju88 && assets.ju88 ? assets.ju88.naturalWidth / assets.ju88.naturalHeight : 1.5;
            const baseEnemySize = 24 * SCALE * game.camera.zoom;
            const enemyWidth = baseEnemySize * originalAspectRatio;
            const enemyHeight = baseEnemySize;
            
            if (assets.loaded.ju88 && assets.ju88) {
              ctx.scale(-1, -1); // Flip for ju-88
              ctx.drawImage(assets.ju88, -enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
            } else {
              // Fallback bomber
              let baseColor = '#444444';
              if (enemy.onFire) baseColor = '#8B0000';
              else if (enemy.smoking) baseColor = '#696969';
              
              ctx.fillStyle = baseColor;
              ctx.fillRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
              
              ctx.strokeStyle = '#222222';
              ctx.lineWidth = 2;
              ctx.strokeRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
            }
          }
          
          // Add visual damage effects
          if (enemy.smoking || enemy.onFire) {
            // Determine effect size based on aircraft type
            let effectSize;
            if (enemy.type === 'bf109') {
              effectSize = 8 * SCALE * game.camera.zoom * 0.3; // Smaller effects for fighters
            } else {
              effectSize = (24 * SCALE * game.camera.zoom * (assets.loaded.ju88 ? assets.ju88.naturalWidth / assets.ju88.naturalHeight : 1.5)) * 0.3;
            }
            
            const effectX = Math.random() * effectSize * 0.8 - effectSize * 0.4;
            const effectY = -effectSize * 0.3 + Math.random() * effectSize * 0.2;
            
            if (enemy.onFire) {
              // Fire effect - orange/red particles
              const numParticles = enemy.type === 'bf109' ? 2 : 3;
              for (let i = 0; i < numParticles; i++) {
                const fireX = effectX + (Math.random() - 0.5) * effectSize;
                const fireY = effectY + (Math.random() - 0.5) * effectSize * 0.5;
                const fireSize = effectSize * 0.2 * Math.random();
                
                ctx.fillStyle = i % 2 === 0 ? '#FF4500' : '#FF8C00';
                ctx.beginPath();
                ctx.arc(fireX, fireY, fireSize, 0, Math.PI * 2);
                ctx.fill();
              }
            } else if (enemy.smoking) {
              // Smoke effect - grey particles
              const numParticles = enemy.type === 'bf109' ? 1 : 2;
              for (let i = 0; i < numParticles; i++) {
                const smokeX = effectX + (Math.random() - 0.5) * effectSize;
                const smokeY = effectY + (Math.random() - 0.5) * effectSize * 0.5;
                const smokeSize = effectSize * 0.15 * Math.random();
                
                ctx.fillStyle = `rgba(105, 105, 105, ${0.4 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }
          
          // Health bar removed - keeping invisible as requested
          // const barWidth = enemyWidth;
          // const barHeight = 4;
          // const barY = -enemyHeight/2 - 10;
          // 
          // // Background
          // ctx.fillStyle = '#FF0000';
          // ctx.fillRect(-barWidth/2, barY, barWidth, barHeight);
          // 
          // // Health
          // const healthRatio = enemy.health / enemy.maxHealth;
          // ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.25 ? '#FFFF00' : '#FF0000');
          // ctx.fillRect(-barWidth/2, barY, barWidth * healthRatio, barHeight);
          
          ctx.restore();
        });
        
        // Render enemy projectiles
        if (game.enemyProjectiles) {
          game.enemyProjectiles.forEach(proj => {
            const screenPos = worldToScreen(proj.x, proj.y);
            const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
            const angle = Math.atan2(proj.vy, proj.vx);
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(angle);
            
            if (proj.type === 'tracer' && assets.loaded.tracer && assets.tracer) {
              // Scale tracer sprite by speed (longer/fatter at higher speed)
              const speedRatio = Math.max(0.2, Math.min(1.0, speed / (proj.initialSpeed || speed || 1)));
              const tracerLength = Math.max(8, TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom);
              const tracerWidth = Math.max(3, TRACER_WIDTH * (0.6 + 0.4 * speedRatio) * SCALE * game.camera.zoom);
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else if (proj.type === 'bullet' && assets.loaded.bullet && assets.bullet) {
              const size = BULLET_SIZE * SCALE * game.camera.zoom;
              ctx.drawImage(assets.bullet, -size/2, -size/2, size, size);
            } else {
              // Fallback
              if (proj.type === 'tracer') {
                const speedRatio = Math.max(0.2, Math.min(1.0, speed / (proj.initialSpeed || speed || 1)));
                const tracerLength = Math.max(8, TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom);
                const tracerWidth = Math.max(3, TRACER_WIDTH * (0.6 + 0.4 * speedRatio) * SCALE * game.camera.zoom);
                ctx.fillStyle = '#FFFF66';
                ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
              } else {
                const bulletSize = Math.max(3, BULLET_SIZE * SCALE * game.camera.zoom);
                ctx.fillStyle = '#FF4444';
                ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
              }
            }
            
            ctx.restore();
          });
        }
        
        // Render explosions
        game.explosions.forEach(explosion => {
          const screenPos = worldToScreen(explosion.x, explosion.y);
          const progress = explosion.time / explosion.duration;
          const isHitExplosion = explosion.type === 'hit';
          
          let size;
          if (isHitExplosion) {
            // Hit explosions stay small and flash bright
            size = explosion.size * SCALE * game.camera.zoom * (1 + progress * 0.5);
          } else {
            // Destruction explosions expand dramatically
            size = explosion.size * SCALE * game.camera.zoom * (1 + progress * 2);
          }
          
          const alpha = 1 - progress; // Fade out
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          
          if (assets.loaded.explosion && assets.explosion && !isHitExplosion) {
            // Use explosion sprite only for large explosions
            ctx.globalAlpha = alpha;
            ctx.drawImage(assets.explosion, -size/2, -size/2, size, size);
          } else {
            // Fallback explosion or hit explosion
            ctx.globalAlpha = alpha;
            
            if (isHitExplosion) {
              // Small bright flash for hits
              const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
              gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`); // Bright white center
              gradient.addColorStop(0.3, `rgba(255, 255, 0, ${alpha})`); // Yellow
              gradient.addColorStop(0.6, `rgba(255, 150, 0, ${alpha})`); // Orange
              gradient.addColorStop(1, `rgba(255, 0, 0, 0)`); // Transparent edge
              
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(0, 0, size/2, 0, Math.PI * 2);
              ctx.fill();
            } else {
              // Large fireball for destruction
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
            gradient.addColorStop(0, `rgba(255, 255, 0, ${alpha})`); // Yellow center
            gradient.addColorStop(0.3, `rgba(255, 100, 0, ${alpha})`); // Orange
            gradient.addColorStop(0.7, `rgba(255, 0, 0, ${alpha})`); // Red
            gradient.addColorStop(1, `rgba(50, 0, 0, 0)`); // Transparent edge
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI * 2);
            ctx.fill();
            }
          }
          
          ctx.restore();
        });
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          // Draw player's SMALL collision hitbox for projectile damage (tracer collision detection)
          ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)'; // Yellow for player collision
          ctx.lineWidth = 3;
          const playerPos = aircraft.getPosition();
          const playerAngle = aircraft.getAngle();
          const playerScreenPos = worldToScreen(playerPos.x, playerPos.y);
          
          ctx.save();
          ctx.translate(playerScreenPos.x, playerScreenPos.y);
          ctx.rotate(playerAngle);
          
          // Use the SMALL hitbox dimensions that collision projectiles actually check against
          const hitboxHalfWidth = 1.2;  // Same as collision detection
          const hitboxHalfHeight = 0.4; // Same as collision detection
          
          const boxWidth = hitboxHalfWidth * 2 * game.camera.zoom;
          const boxHeight = hitboxHalfHeight * 2 * game.camera.zoom;
          ctx.strokeRect(-boxWidth/2, -boxHeight/2, boxWidth, boxHeight);
          
          ctx.restore();
          
          // Draw collision projectiles (small red dots)
          if (game.enemyCollisionProjectiles) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // Red for collision projectiles
            game.enemyCollisionProjectiles.forEach(collisionProj => {
              const screenPos = worldToScreen(collisionProj.x, collisionProj.y);
              ctx.fillRect(screenPos.x - 1, screenPos.y - 1, 2, 2); // Small 2x2 pixel dot
            });
          }
          
          ctx.restore();
        }
        
        // Debug: Draw pixel collision outlines (press 'V' to toggle)
        if (game.showPixelCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
          ctx.lineWidth = 1;
          
          // Draw player aircraft pixel bounds
          const playerPos = aircraft.getPosition();
          const playerAngle = aircraft.getAngle();
          const playerScreenPos = worldToScreen(playerPos.x, playerPos.y);
          
          let playerSprite;
          if (game.inverted && game.gearDown) {
            playerSprite = assets.spitfireInvertedGear;
          } else if (game.inverted && !game.gearDown) {
            playerSprite = assets.spitfireInverted;
          } else if (!game.inverted && game.gearDown) {
            playerSprite = assets.spitfireGear;
          } else {
            playerSprite = assets.spitfire;
          }
          
          if (playerSprite) {
            // Get the appropriate sprite name for colored bounds
            let spriteName;
            if (game.inverted && game.gearDown) {
              spriteName = 'spitfireInvertedGear';
            } else if (game.inverted && !game.gearDown) {
              spriteName = 'spitfireInverted';
            } else if (!game.inverted && game.gearDown) {
              spriteName = 'spitfireGear';
            } else {
              spriteName = 'spitfire';
            }
            
            const coloredBounds = spriteColoredBounds.get(spriteName);
            const scale = 0.4 * game.camera.zoom; // Use actual rendering scale
            
            ctx.translate(playerScreenPos.x, playerScreenPos.y);
            ctx.rotate(playerAngle);
            
            if (coloredBounds) {
              // Draw only the colored bounds, not the full sprite
              const w = coloredBounds.width * scale;
              const h = coloredBounds.height * scale;
              
              // Calculate offset from sprite center to colored bounds center
              const coloredCenterX = (coloredBounds.left + coloredBounds.right) / 2;
              const coloredCenterY = (coloredBounds.top + coloredBounds.bottom) / 2;
              const spriteCenterX = playerSprite.naturalWidth / 2;
              const spriteCenterY = playerSprite.naturalHeight / 2;
              
              const offsetX = (coloredCenterX - spriteCenterX) * scale;
              const offsetY = (coloredCenterY - spriteCenterY) * scale;
              
              ctx.strokeRect(-w/2 + offsetX, -h/2 + offsetY, w, h);
            } else {
              // Fallback to full sprite
              const w = playerSprite.naturalWidth * scale;
              const h = playerSprite.naturalHeight * scale;
              ctx.strokeRect(-w/2, -h/2, w, h);
            }
            
            ctx.resetTransform();
          }
          
          // Draw enemy aircraft pixel bounds
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            const pos = enemy.body.getPosition();
            const angle = enemy.body.getAngle();
            const screenPos = worldToScreen(pos.x, pos.y);
            
            if (assets.loaded.ju88 && assets.ju88) {
              const originalAspectRatio = assets.ju88.naturalWidth / assets.ju88.naturalHeight;
              const baseEnemySize = 24 * SCALE * game.camera.zoom;
              const enemyWidth = baseEnemySize * originalAspectRatio;
              const enemyHeight = baseEnemySize;
              
              ctx.translate(screenPos.x, screenPos.y);
              ctx.rotate(angle);
              ctx.strokeRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
              ctx.resetTransform();
            }
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed * VISUAL_SCALE); // Convert to visual speed
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        // Altitude: distance above ground (converted to visual altitude)
        document.getElementById('altitude').textContent = Math.max(0, Math.round(-pos.y * VISUAL_SCALE));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Add landing gear and ground status indicators
        const gearStatus = document.querySelector('.gear-status') || (() => {
          const div = document.createElement('div');
          div.className = 'gear-status';
          div.style.cssText = 'position:fixed;top:120px;left:20px;color:#fff;font-size:14px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);';
          document.body.appendChild(div);
          return div;
        })();
        
        let statusText = `Gear: ${game.gearDown ? 'DOWN' : 'UP'}`;
        if (game.onGround) {
          statusText += ` | On Ground (${Math.round(game.groundSpeed * VISUAL_SCALE)} m/s)`;
        }
        gearStatus.textContent = statusText;
        
        // Display mission objectives
        if (window.campaignMode && window.missionManager && window.missionManager.isActive()) {
          const objectiveDiv = document.querySelector('.mission-objective') || (() => {
            const div = document.createElement('div');
            div.className = 'mission-objective';
            div.style.cssText = 'position:fixed;top:20px;right:20px;color:#fff;font-size:16px;text-shadow:2px 2px 4px rgba(0,0,0,0.8);text-align:right;max-width:300px;';
            document.body.appendChild(div);
            return div;
          })();
          
          const objective = window.missionManager.getCurrentObjective();
          const missionTime = window.missionManager.getMissionTime();
          
          if (objective) {
            let objText = `<div style="color:#f39c12;margin-bottom:5px;">OBJECTIVE</div>`;
            objText += `<div>${objective.description}</div>`;
            
            if (objective.type === 'survive' || objective.type === 'protect') {
              objText += `<div style="margin-top:5px;">Time: ${objective.current}/${objective.target || objective.timeTarget}s</div>`;
            } else if (objective.type === 'destroy_count' || objective.type === 'destroy_bombers' || objective.type === 'destroy_targets') {
              objText += `<div style="margin-top:5px;">Destroyed: ${objective.current}/${objective.target}</div>`;
            }
            
            objText += `<div style="margin-top:10px;font-size:14px;opacity:0.8;">Mission Time: ${missionTime}s</div>`;
            
            objectiveDiv.innerHTML = objText;
          }
        }
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'üí• CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
        
        // Debug menu overlay
        if (game.debug.showMenu) {
          const debugDiv = document.querySelector('.debug-menu') || (() => {
            const div = document.createElement('div');
            div.className = 'debug-menu';
            div.style.cssText = `
              position: fixed;
              top: 10px;
              right: 10px;
              background: rgba(0, 0, 0, 0.8);
              color: lime;
              padding: 15px;
              font-family: monospace;
              font-size: 14px;
              border: 2px solid lime;
              border-radius: 5px;
              min-width: 300px;
              z-index: 1000;
            `;
            document.body.appendChild(div);
            return div;
          })();
          
          debugDiv.innerHTML = `
            <div style="color: yellow; font-weight: bold; margin-bottom: 10px;">üõ†Ô∏è DEBUG MENU (H to toggle)</div>
            <div>1. God Mode: <span style="color: ${game.debug.godMode ? 'lime' : 'red'}">${game.debug.godMode ? 'ON' : 'OFF'}</span></div>
            <div>2. Stop Enemy Firing: <span style="color: ${game.debug.enemiesStopFiring ? 'lime' : 'red'}">${game.debug.enemiesStopFiring ? 'ON' : 'OFF'}</span></div>
            <div>3. Show FPS: <span style="color: ${game.debug.showFPS ? 'lime' : 'red'}">${game.debug.showFPS ? 'ON' : 'OFF'}</span></div>
            <div>4. Physics Info: <span style="color: ${game.debug.showPhysicsInfo ? 'lime' : 'red'}">${game.debug.showPhysicsInfo ? 'ON' : 'OFF'}</span></div>
            <div>5. Unlimited Ammo: <span style="color: ${game.debug.unlimitedAmmo ? 'lime' : 'red'}">${game.debug.unlimitedAmmo ? 'ON' : 'OFF'}</span></div>
            <div>6. No Recoil: <span style="color: ${game.debug.noRecoil ? 'lime' : 'red'}">${game.debug.noRecoil ? 'ON' : 'OFF'}</span></div>
            <div>7. Stop Enemy Movement: <span style="color: ${game.debug.enemiesStopMoving ? 'lime' : 'red'}">${game.debug.enemiesStopMoving ? 'ON' : 'OFF'}</span></div>
            <div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 10px;">
              <div>8. Spawn Enemies</div>
              <div>9. Clear All Enemies</div>
              <div>0. Heal Player</div>
              <div>+/= Increase Max Health (${game.playerMaxHealth})</div>
              <div>- Decrease Max Health</div>
            </div>
            <div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 10px; color: yellow;">
              <div>C. Console: <span style="color: ${game.debug.showConsole ? 'lime' : 'red'}">${game.debug.showConsole ? 'ON' : 'OFF'}</span></div>
              <div>P. Pause: <span style="color: ${game.debug.isPaused ? 'red' : 'lime'}">${game.debug.isPaused ? 'PAUSED' : 'RUNNING'}</span></div>
              <div>M. Mouse Inspect: <span style="color: ${game.debug.mouseInspect ? 'lime' : 'red'}">${game.debug.mouseInspect ? 'ON' : 'OFF'}</span></div>
              <div>B. Sprite Bounds: <span style="color: ${game.debug.showSpriteBounds ? 'lime' : 'red'}">${game.debug.showSpriteBounds ? 'ON' : 'OFF'}</span></div>
              <div>N. Player Hitbox: <span style="color: ${game.debug.showPlayerHitbox ? 'lime' : 'red'}">${game.debug.showPlayerHitbox ? 'ON' : 'OFF'}</span></div>
            </div>
            <div style="margin-top: 10px; color: #ccc; font-size: 12px;">
              Press number keys to toggle options<br/>
              Current Health: ${game.playerHealth}/${game.playerMaxHealth}
            </div>
          `;
        } else {
          const debugDiv = document.querySelector('.debug-menu');
          if (debugDiv) debugDiv.remove();
        }
        
        // FPS display
        if (game.debug.showFPS) {
          const fpsDiv = document.querySelector('.fps-display') || (() => {
            const div = document.createElement('div');
            div.className = 'fps-display';
            div.style.cssText = `
              position: fixed;
              top: 10px;
              left: 10px;
              background: rgba(0, 0, 0, 0.7);
              color: lime;
              padding: 5px 10px;
              font-family: monospace;
              font-size: 16px;
              border-radius: 3px;
              z-index: 1000;
            `;
            document.body.appendChild(div);
            return div;
          })();
          fpsDiv.textContent = `FPS: ${currentFPS}`;
        } else {
          const fpsDiv = document.querySelector('.fps-display');
          if (fpsDiv) fpsDiv.remove();
        }
        
        // Physics info display
        if (game.debug.showPhysicsInfo) {
          const physicsDiv = document.querySelector('.physics-display') || (() => {
            const div = document.createElement('div');
            div.className = 'physics-display';
            div.style.cssText = `
              position: fixed;
              bottom: 10px;
              left: 10px;
              background: rgba(0, 0, 0, 0.7);
              color: cyan;
              padding: 10px;
              font-family: monospace;
              font-size: 12px;
              border-radius: 3px;
              z-index: 1000;
              max-width: 300px;
            `;
            document.body.appendChild(div);
            return div;
          })();
          
          const pos = aircraft.getPosition();
          const vel = aircraft.getLinearVelocity();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          const angVel = aircraft.getAngularVelocity();
          
          physicsDiv.innerHTML = `
            <div><strong>PHYSICS DEBUG</strong></div>
            <div>Position: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})</div>
            <div>Velocity: (${vel.x.toFixed(1)}, ${vel.y.toFixed(1)})</div>
            <div>Speed: ${(speed * VISUAL_SCALE).toFixed(1)} m/s</div>
            <div>Angular Vel: ${angVel.toFixed(2)} rad/s</div>
            <div>Enemies: ${game.enemies.length}</div>
            <div>Projectiles: ${game.projectiles.length}</div>
            <div>Enemy Projectiles: ${game.enemyProjectiles.length}</div>
            <div>Casings: ${game.casings.length}</div>
          `;
        } else {
          const physicsDiv = document.querySelector('.physics-display');
          if (physicsDiv) physicsDiv.remove();
        }
        
        // Health bar display (always visible)
        const healthBarDiv = document.querySelector('.health-bar') || (() => {
          const div = document.createElement('div');
          div.className = 'health-bar';
          div.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 14px;
            color: white;
            z-index: 1000;
            min-width: 200px;
            text-align: center;
          `;
          document.body.appendChild(div);
          return div;
        })();
        
        // Calculate health percentage
        const healthPercent = (game.playerHealth / game.playerMaxHealth) * 100;
        const healthColor = healthPercent > 60 ? '#00ff00' : healthPercent > 30 ? '#ffff00' : '#ff0000';
        
        healthBarDiv.innerHTML = `
          <div style="margin-bottom: 4px; font-size: 12px;">HEALTH</div>
          <div style="background: #333; border-radius: 5px; height: 8px; position: relative; overflow: hidden;">
            <div style="
              background: linear-gradient(90deg, ${healthColor}, ${healthColor}dd);
              height: 100%;
              width: ${healthPercent}%;
              border-radius: 5px;
              transition: width 0.3s ease, background 0.3s ease;
            "></div>
          </div>
          <div style="margin-top: 4px; font-size: 12px;">
            ${game.playerHealth}/${game.playerMaxHealth} HP
            ${game.crashed ? ' - CRASHED' : ''}
            ${game.debug.godMode ? ' - GOD MODE' : ''}
          </div>
        `;
        
        // Debug console display
        if (game.debug.showConsole) {
          const consoleDiv = document.querySelector('.debug-console') || (() => {
            const div = document.createElement('div');
            div.className = 'debug-console';
            div.style.cssText = `
              position: fixed;
              bottom: 10px;
              left: 10px;
              right: 10px;
              height: 200px;
              background: rgba(0, 0, 0, 0.9);
              color: lime;
              font-family: monospace;
              font-size: 12px;
              border: 1px solid #333;
              border-radius: 5px;
              padding: 10px;
              overflow-y: auto;
              z-index: 1000;
            `;
            document.body.appendChild(div);
            return div;
          })();
          
          // Update console content
          const messages = game.debugConsole.messages.slice(-20); // Show last 20 messages
          consoleDiv.innerHTML = `
            <div style="color: yellow; font-weight: bold; margin-bottom: 5px;">üñ•Ô∏è DEBUG CONSOLE (C to toggle)</div>
            ${messages.map(msg => `
              <div style="margin-bottom: 2px;">
                <span style="color: #666;">[${msg.time}]</span> 
                <span style="color: lime;">${msg.content}</span>
              </div>
            `).join('')}
          `;
          
          // Auto-scroll to bottom
          consoleDiv.scrollTop = consoleDiv.scrollHeight;
        } else {
          const consoleDiv = document.querySelector('.debug-console');
          if (consoleDiv) consoleDiv.remove();
        }
        
        // Mouse hover inspection display
        if (game.debug.mouseInspect && game.debug.hoverData) {
          const hoverDiv = document.querySelector('.hover-inspect') || (() => {
            const div = document.createElement('div');
            div.className = 'hover-inspect';
            div.style.cssText = `
              position: fixed;
              background: rgba(0, 0, 0, 0.9);
              color: cyan;
              font-family: monospace;
              font-size: 12px;
              border: 1px solid cyan;
              border-radius: 3px;
              padding: 8px;
              pointer-events: none;
              z-index: 1001;
              max-width: 300px;
            `;
            document.body.appendChild(div);
            return div;
          })();
          
          // Position near mouse
          hoverDiv.style.left = (game.debug.hoverData.screenX + 15) + 'px';
          hoverDiv.style.top = (game.debug.hoverData.screenY - 10) + 'px';
          
          const { worldX, worldY, object } = game.debug.hoverData;
          
          if (object) {
            hoverDiv.innerHTML = `
              <div style="color: yellow; font-weight: bold;">${object.type.toUpperCase()}${object.enemyType ? ` (${object.enemyType})` : ''}</div>
              <div>Position: (${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)})</div>
              <div>Velocity: (${object.velocity.x.toFixed(1)}, ${object.velocity.y.toFixed(1)})</div>
              <div>Speed: ${(object.speed * VISUAL_SCALE).toFixed(1)} m/s</div>
              <div>Angle: ${(object.angle * 180 / Math.PI).toFixed(1)}¬∞</div>
              <div>Health: ${object.health}${object.type === 'enemy' ? `/${object.maxHealth || '?'}` : `/${game.playerMaxHealth}`}</div>
              ${object.aiState ? `<div>AI State: ${object.aiState}</div>` : ''}
            `;
          } else {
            hoverDiv.innerHTML = `
              <div style="color: yellow; font-weight: bold;">WORLD COORDINATES</div>
              <div>X: ${worldX.toFixed(1)}</div>
              <div>Y: ${worldY.toFixed(1)}</div>
              <div>Alt: ${(-worldY * VISUAL_SCALE).toFixed(0)}m</div>
            `;
          }
        } else {
          const hoverDiv = document.querySelector('.hover-inspect');
          if (hoverDiv) hoverDiv.remove();
        }
        
        // Pause indicator
        if (game.debug.isPaused) {
          const pauseDiv = document.querySelector('.pause-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'pause-indicator';
            div.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: rgba(255, 0, 0, 0.8);
              color: white;
              font-size: 32px;
              font-weight: bold;
              padding: 20px;
              border-radius: 10px;
              z-index: 1002;
            `;
            document.body.appendChild(div);
            return div;
          })();
          pauseDiv.textContent = '‚è∏Ô∏è PAUSED (P to resume)';
        } else {
          const pauseDiv = document.querySelector('.pause-indicator');
          if (pauseDiv) pauseDiv.remove();
        }
        
        // Debug: Draw sprite bounds (press 'B' to toggle) - shows actual PNG dimensions
        if (game.debug.showSpriteBounds) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)'; // Magenta for sprite bounds
          ctx.lineWidth = 1;
          
          // Draw player sprite bounds (actual PNG size)
          const playerPos = aircraft.getPosition();
          const playerAngle = aircraft.getAngle();
          const playerScreenPos = worldToScreen(playerPos.x, playerPos.y);
          
          let playerSprite;
          if (game.inverted && game.gearDown) {
            playerSprite = assets.spitfireInvertedGear;
          } else if (game.inverted && !game.gearDown) {
            playerSprite = assets.spitfireInverted;
          } else if (!game.inverted && game.gearDown) {
            playerSprite = assets.spitfireGear;
          } else {
            playerSprite = assets.spitfire;
          }
          
          if (playerSprite) {
            ctx.save();
            ctx.translate(playerScreenPos.x, playerScreenPos.y);
            ctx.rotate(playerAngle);
            
            // Show actual sprite rendering size (0.4 scale for rendering)
            const renderScale = 0.4 * game.camera.zoom;
            const spriteWidth = playerSprite.naturalWidth * renderScale;
            const spriteHeight = playerSprite.naturalHeight * renderScale;
            ctx.strokeRect(-spriteWidth/2, -spriteHeight/2, spriteWidth, spriteHeight);
            
            // Add label
            ctx.fillStyle = 'magenta';
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`PNG: ${playerSprite.naturalWidth}x${playerSprite.naturalHeight}`, 0, spriteHeight/2 + 15);
            
            ctx.restore();
          }
          
          ctx.restore();
        }
        
        // Debug: Draw player collision area as calculated by checkPlayerPixelCollision (press 'N' to toggle)
        if (game.debug.showPlayerHitbox) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 165, 0, 1.0)'; // Orange for actual hitbox
          ctx.lineWidth = 3;
          
          const playerPos = aircraft.getPosition();
          const playerAngle = aircraft.getAngle();
          const playerScreenPos = worldToScreen(playerPos.x, playerPos.y);
          
          // Get the same sprite and bounds as collision detection uses
          let spriteName;
          if (game.inverted && game.gearDown) {
            spriteName = 'spitfireInvertedGear';
          } else if (game.inverted && !game.gearDown) {
            spriteName = 'spitfireInverted';
          } else if (!game.inverted && game.gearDown) {
            spriteName = 'spitfireGear';
          } else {
            spriteName = 'spitfire';
          }
          
          const coloredBounds = spriteColoredBounds.get(spriteName);
          let sprite;
          if (spriteName === 'spitfireInvertedGear') {
            sprite = assets.spitfireInvertedGear;
          } else if (spriteName === 'spitfireInverted') {
            sprite = assets.spitfireInverted;
          } else if (spriteName === 'spitfireGear') {
            sprite = assets.spitfireGear;
          } else {
            sprite = assets.spitfire;
          }
          
          if (coloredBounds && sprite) {
            const basePlayerSize = 0.4;
            const playerWidth = coloredBounds.width * basePlayerSize;
            const playerHeight = coloredBounds.height * basePlayerSize;
            
            // Calculate offset from sprite center to colored bounds center (same as collision detection)
            const coloredCenterX = (coloredBounds.left + coloredBounds.right) / 2;
            const coloredCenterY = (coloredBounds.top + coloredBounds.bottom) / 2;
            const spriteCenterX = sprite.naturalWidth / 2;
            const spriteCenterY = sprite.naturalHeight / 2;
            
            const boundsOffsetX = (coloredCenterX - spriteCenterX) * basePlayerSize;
            const boundsOffsetY = (coloredCenterY - spriteCenterY) * basePlayerSize;
            
            ctx.translate(playerScreenPos.x, playerScreenPos.y);
            ctx.rotate(playerAngle);
            
            // Draw the actual collision hitbox
            const w = playerWidth * game.camera.zoom;
            const h = playerHeight * game.camera.zoom;
            const offsetX = boundsOffsetX * game.camera.zoom;
            const offsetY = boundsOffsetY * game.camera.zoom;
            
            ctx.strokeRect(-w/2 + offsetX, -h/2 + offsetY, w, h);
            
            // Add label
            ctx.fillStyle = 'orange';
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`HITBOX: ${coloredBounds.width}x${coloredBounds.height} px`, offsetX, h/2 + offsetY + 20);
            
            ctx.restore();
          }
          
          ctx.restore();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      // FPS tracking
      let frameCount = 0;
      let fpsLastTime = performance.now();
      let currentFPS = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        // FPS calculation
        frameCount++;
        if (time - fpsLastTime >= 1000) {
          currentFPS = Math.round(frameCount * 1000 / (time - fpsLastTime));
          frameCount = 0;
          fpsLastTime = time;
        }
        
        // Skip physics updates if paused
        if (!game.debug.isPaused) {
          while (accumulator >= timeStep) {
            updatePhysics(timeStep);
            world.step(timeStep); // Move world.step BEFORE projectile updates
            updateProjectiles(timeStep);
            updateEnemies(timeStep);
            updateEnemySpawning(); // Handle continuous spawning and cleanup
            updateExplosions(timeStep);
            
            // Update mission manager if in campaign mode
            if (window.campaignMode && window.missionManager) {
              window.missionManager.update(timeStep);
            }
            
            accumulator -= timeStep;
          }
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Add mission system integration functions
      window.game = game;
      game.player = aircraft;
      
      // Mission system enemy spawning functions
      game.spawnEnemies = function(spawnData) {
        console.log('üéØ Spawning enemies from mission:', spawnData);
        
        // Determine spawn position based on direction
        const playerPos = aircraft.getPosition();
        const spawnDistance = 200; // Distance from player (400m in visual scale)
        let spawnAngle = 0;
        
        switch(spawnData.from) {
          case 'N': spawnAngle = -Math.PI/2; break;
          case 'NE': spawnAngle = -Math.PI/4; break;
          case 'E': spawnAngle = 0; break;
          case 'SE': spawnAngle = Math.PI/4; break;
          case 'S': spawnAngle = Math.PI/2; break;
          case 'SW': spawnAngle = 3*Math.PI/4; break;
          case 'W': spawnAngle = Math.PI; break;
          case 'NW': spawnAngle = -3*Math.PI/4; break;
        }
        
        const spawnX = playerPos.x + Math.cos(spawnAngle) * spawnDistance;
        
        // Determine spawn altitude based on type
        let spawnY = -250; // Default altitude (500m in visual scale)
        switch(spawnData.altitude || spawnData.alt) {
          case 'low': spawnY = -100; break;  // 200m
          case 'mid': spawnY = -250; break;  // 500m
          case 'high': spawnY = -500; break; // 1000m
          default: spawnY = playerPos.y - 50; // Slightly above player
        }
        
        // Spawn the enemies based on type
        for (let i = 0; i < spawnData.count; i++) {
          let offsetX, offsetY;
          
          if (spawnData.type === 'training_dummy') {
            // Special formation for training dummies - spread them out more
            offsetX = (i - 1) * 50; // 100m spacing between dummies
            offsetY = 0;
          } else {
            // Standard formation spacing for aircraft
            if (spawnData.formation === 'V' || spawnData.type === 'ju88') {
              // V formation for bombers - wider spacing
              if (i === 0) {
                offsetX = 0; offsetY = 0; // Lead aircraft
              } else if (i === 1) {
                offsetX = -80; offsetY = -40; // Left wing
              } else if (i === 2) {
                offsetX = -80; offsetY = 40; // Right wing
              } else {
                offsetX = (i - 2) * -100; offsetY = ((i % 2) * 2 - 1) * 60; // Additional aircraft
              }
            } else {
              // Line formation for fighters - moderate spacing
              offsetX = (i - spawnData.count/2) * 60; // 120m spacing between aircraft
              offsetY = 0;
            }
          }
          
          const enemy = window.spawnEnemy(spawnX + offsetX, spawnY + offsetY, spawnData.type);
          if (enemy) {
            enemy.behavior = spawnData.behavior || 'default';
            enemy.target = spawnData.target;
          }
        }
      };
      
      game.spawnAce = function(spawnData) {
        console.log('‚≠ê Spawning ace enemy:', spawnData);
        
        const playerPos = aircraft.getPosition();
        const spawnDistance = 250; // Slightly further for aces
        let spawnAngle = 0;
        
        switch(spawnData.from) {
          case 'N': spawnAngle = -Math.PI/2; break;
          case 'NE': spawnAngle = -Math.PI/4; break;
          case 'E': spawnAngle = 0; break;
          case 'SE': spawnAngle = Math.PI/4; break;
          case 'S': spawnAngle = Math.PI/2; break;
          case 'SW': spawnAngle = 3*Math.PI/4; break;
          case 'W': spawnAngle = Math.PI; break;
          case 'NW': spawnAngle = -3*Math.PI/4; break;
        }
        
        const spawnX = playerPos.x + Math.cos(spawnAngle) * spawnDistance;
        
        // Aces typically come from above
        let spawnY = -400; // Default high altitude for aces
        switch(spawnData.altitude || spawnData.alt) {
          case 'low': spawnY = -150; break;
          case 'mid': spawnY = -300; break;
          case 'high': spawnY = -500; break;
          default: spawnY = playerPos.y - 100; // Above player
        }
        
        const ace = window.spawnEnemy(spawnX, spawnY, spawnData.aceType || 'bf109');
        if (ace && spawnData.buffs) {
          // Apply ace buffs
          ace.targetSpeed *= spawnData.buffs.speed || 1;
          ace.skillLevel = 'ace';
          ace.aggressiveness = Math.min(1.0, (ace.aggressiveness || 0.7) * (spawnData.buffs.turnRate || 1));
          ace.health *= spawnData.buffs.health || 1;
          ace.maxHealth *= spawnData.buffs.health || 1;
          ace.isAce = true;
          ace.name = spawnData.name;
          ace.burstSize = Math.floor(ace.burstSize * (spawnData.buffs.accuracy || 1));
        }
      };
      
      game.showDialogue = function(text) {
        if (window.uiScreens) {
          window.uiScreens.showDialogue(text);
        }
      };
      
      game.showDebrief = function(data) {
        if (window.uiScreens) {
          window.uiScreens.showDebrief(data);
        }
      };
      
      // Start the game loop at the end of initializeGame
      console.log('Starting flight simulator...');
      requestAnimationFrame(gameLoop);
      }

      // =============================================================================
      // DEBUG MODE INITIALIZATION
      // =============================================================================
      
      function initializeDebugMode() {
        console.log('üõ†Ô∏è Initializing debug mode...');
        
        // Set up basic canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas setup for debug mode
        let canvasWidth = 0;
        let canvasHeight = 0;
        
        function setupDebugCanvas() {
          const dpr = window.devicePixelRatio || 1;
          canvas.width = window.innerWidth * dpr;
          canvas.height = window.innerHeight * dpr;
          canvas.style.width = window.innerWidth + 'px';
          canvas.style.height = window.innerHeight + 'px';
          ctx.scale(dpr, dpr);
          canvasWidth = window.innerWidth;
          canvasHeight = window.innerHeight;
        }
        
        window.addEventListener('resize', setupDebugCanvas);
        setupDebugCanvas();
        
        // Debug mode state
        const debugState = {
          sprites: [], // Array of placed debug sprites
          selectedSpriteType: 'player', // Current sprite type to spawn
          showHitboxes: true,
          isPlacing: false,
          player: null, // Single player sprite for shooting
          projectiles: [],
          casings: [],
          mousePos: { x: 0, y: 0 },
          worldMousePos: { x: 0, y: 0 }
        };
        
        // Available sprite types for debugging
        const spriteTypes = {
          player: { 
            name: 'Spitfire', 
            sprites: ['spitfire', 'spitfireGear', 'spitfireInverted', 'spitfireInvertedGear'],
            hitboxSize: { width: 20, height: 8 },
            maxHealth: 3
          },
          enemy_bf109: { 
            name: 'BF-109', 
            sprites: ['bf109Left'],
            hitboxSize: { width: 18, height: 7 },
            maxHealth: 3
          },
          enemy_ju88: { 
            name: 'Ju-88', 
            sprites: ['ju88'],
            hitboxSize: { width: 30, height: 12 },
            maxHealth: 5
          }
        };
        
        // Camera system for debug mode
        const debugCamera = {
          x: 0,
          y: 0,
          zoom: 0.3,  // Start more zoomed out
          moveSpeed: 200
        };
        
        // Initialize projectiles system
        if (typeof initProjectiles === 'function') {
          initProjectiles();
        }
        
        // Create a simple player sprite for shooting
        debugState.player = {
          x: 0,
          y: 0,
          angle: 0,
          type: 'player'
        };
        
        // =============================================================================
        // DEBUG MODE INPUT HANDLING
        // =============================================================================
        
        const debugKeys = {};
        
        function handleDebugKeyDown(e) {
          debugKeys[e.key.toLowerCase()] = true;
          
          // Sprite type selection
          if (e.key === '1') debugState.selectedSpriteType = 'player';
          if (e.key === '2') debugState.selectedSpriteType = 'enemy_bf109';
          if (e.key === '3') debugState.selectedSpriteType = 'enemy_ju88';
          
          // Toggle hitboxes
          if (e.key.toLowerCase() === 'h') {
            debugState.showHitboxes = !debugState.showHitboxes;
            console.log('üîç Hitboxes:', debugState.showHitboxes ? 'ON' : 'OFF');
          }
          
          // Clear all sprites
          if (e.key.toLowerCase() === 'c') {
            debugState.sprites = [];
            console.log('üóëÔ∏è Cleared all debug sprites');
          }
          
          // Restore all sprites to full health
          if (e.key.toLowerCase() === 'r') {
            debugState.sprites.forEach(sprite => {
              sprite.health = sprite.maxHealth;
              sprite.destroyed = false;
              sprite.damageNumbers = [];
            });
            console.log('‚ù§Ô∏è Restored all sprites to full health');
          }
          
          // Shooting
          if (e.key === ' ') {
            e.preventDefault();
            if (typeof trySpawnGuns === 'function') {
              // Set up temporary aircraft object for shooting
              window.aircraft = {
                getPosition: () => ({ x: debugState.player.x, y: debugState.player.y }),
                getAngle: () => debugState.player.angle,
                getLinearVelocity: () => ({ x: 0, y: 0 })
              };
              
              // Initialize game object if needed
              if (!window.game) window.game = {};
              if (!window.game.projectiles) window.game.projectiles = [];
              if (!window.game.casings) window.game.casings = [];
              
              trySpawnGuns();
            }
          }
        }
        
        function handleDebugKeyUp(e) {
          debugKeys[e.key.toLowerCase()] = false;
        }
        
        function handleDebugMouseMove(e) {
          const rect = canvas.getBoundingClientRect();
          debugState.mousePos.x = e.clientX - rect.left;
          debugState.mousePos.y = e.clientY - rect.top;
          
          // Convert to world coordinates
          debugState.worldMousePos.x = (debugState.mousePos.x - canvasWidth/2) / (20 * debugCamera.zoom) + debugCamera.x;
          debugState.worldMousePos.y = (debugState.mousePos.y - canvasHeight/2) / (20 * debugCamera.zoom) + debugCamera.y;
        }
        
        function handleDebugMouseClick(e) {
          if (e.button === 0) { // Left click - place sprite
            const spriteType = spriteTypes[debugState.selectedSpriteType];
            if (spriteType) {
              const newSprite = {
                x: debugState.worldMousePos.x,
                y: debugState.worldMousePos.y,
                type: debugState.selectedSpriteType,
                hitbox: spriteType.hitboxSize,
                angle: 0,
                id: Math.random(),
                // Game-like properties
                health: spriteType.maxHealth || 5,
                maxHealth: spriteType.maxHealth || 5,
                destroyed: false,
                facingDirection: 'left', // For enemy sprites
                lastHitTime: 0,
                damageNumbers: [] // For floating damage numbers
              };
              debugState.sprites.push(newSprite);
              console.log(`üéØ Placed ${spriteType.name} with ${newSprite.health} HP at (${newSprite.x.toFixed(1)}, ${newSprite.y.toFixed(1)})`);
            }
          } else if (e.button === 2) { // Right click - remove sprite
            e.preventDefault();
            // Find sprite under mouse and remove it
            for (let i = debugState.sprites.length - 1; i >= 0; i--) {
              const sprite = debugState.sprites[i];
              if (sprite.destroyed) continue;
              
              const dx = sprite.x - debugState.worldMousePos.x;
              const dy = sprite.y - debugState.worldMousePos.y;
              const distance = Math.sqrt(dx*dx + dy*dy);
              
              if (distance < Math.max(sprite.hitbox.width, sprite.hitbox.height) / 2) {
                debugState.sprites.splice(i, 1);
                console.log(`üóëÔ∏è Removed ${spriteTypes[sprite.type].name}`);
                break;
              }
            }
          }
        }
        
        // Add event listeners
        document.addEventListener('keydown', handleDebugKeyDown);
        document.addEventListener('keyup', handleDebugKeyUp);
        canvas.addEventListener('mousemove', handleDebugMouseMove);
        canvas.addEventListener('click', handleDebugMouseClick);
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // =============================================================================
        // DEBUG MODE UPDATE AND RENDER
        // =============================================================================
        
        function updateDebugMode(dt) {
          // Camera movement
          if (debugKeys['arrowleft'] || debugKeys['a']) debugCamera.x -= debugCamera.moveSpeed * dt;
          if (debugKeys['arrowright'] || debugKeys['d']) debugCamera.x += debugCamera.moveSpeed * dt;
          if (debugKeys['arrowup'] || debugKeys['w']) debugCamera.y -= debugCamera.moveSpeed * dt;
          if (debugKeys['arrowdown'] || debugKeys['s']) debugCamera.y += debugCamera.moveSpeed * dt;
          
          // Zoom
          if (debugKeys['='] || debugKeys['+']) debugCamera.zoom = Math.min(debugCamera.zoom * 1.01, 3.0);
          if (debugKeys['-']) debugCamera.zoom = Math.max(debugCamera.zoom * 0.99, 0.1);
          
          // Update player angle to face mouse
          const dx = debugState.worldMousePos.x - debugState.player.x;
          const dy = debugState.worldMousePos.y - debugState.player.y;
          debugState.player.angle = Math.atan2(dy, dx);
          
          // Update projectiles
          if (typeof updateProjectiles === 'function') {
            updateProjectiles(dt);
          }
          
          // Check projectile collisions with debug sprites
          if (window.game && window.game.projectiles) {
            for (let projIndex = window.game.projectiles.length - 1; projIndex >= 0; projIndex--) {
              const proj = window.game.projectiles[projIndex];
              
              for (let spriteIndex = 0; spriteIndex < debugState.sprites.length; spriteIndex++) {
                const sprite = debugState.sprites[spriteIndex];
                if (sprite.destroyed) continue;
                
                // Simple distance-based collision for debug mode
                const dx = proj.x - sprite.x;
                const dy = proj.y - sprite.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const collisionRadius = Math.max(sprite.hitbox.width, sprite.hitbox.height) / 4;
                
                if (distance < collisionRadius) {
                  // Hit detected!
                  console.log(`üéØ Debug sprite hit! Distance: ${distance.toFixed(2)}, Radius: ${collisionRadius.toFixed(2)}`);
                  
                  // Create hit explosion
                  if (!debugState.explosions) debugState.explosions = [];
                  debugState.explosions.push({
                    x: proj.x,
                    y: proj.y,
                    time: 0,
                    duration: 0.3,
                    size: 3,
                    type: 'hit'
                  });
                  
                  // Deal damage
                  sprite.health -= 1;
                  sprite.lastHitTime = performance.now();
                  
                  // Add floating damage number
                  sprite.damageNumbers.push({
                    x: proj.x + (Math.random() - 0.5) * 10,
                    y: proj.y + (Math.random() - 0.5) * 10,
                    damage: 1,
                    time: 0,
                    duration: 1.0,
                    vy: -20 // Float upward
                  });
                  
                  console.log(`üí• ${spriteTypes[sprite.type].name} took 1 damage! Health: ${sprite.health}/${sprite.maxHealth}`);
                  
                  // Remove projectile
                  window.game.projectiles.splice(projIndex, 1);
                  
                  // Check if sprite is destroyed
                  if (sprite.health <= 0) {
                    sprite.destroyed = true;
                    console.log(`üíÄ Debug ${spriteTypes[sprite.type].name} destroyed!`);
                    
                    // Create destruction explosion
                    debugState.explosions.push({
                      x: sprite.x,
                      y: sprite.y,
                      time: 0,
                      duration: 1.0,
                      size: Math.max(sprite.hitbox.width, sprite.hitbox.height) * 0.8,
                      type: 'destruction'
                    });
                  }
                  
                  break; // Only hit one sprite per projectile
                }
              }
            }
          }
          
          // Update damage numbers
          debugState.sprites.forEach(sprite => {
            for (let i = sprite.damageNumbers.length - 1; i >= 0; i--) {
              const dmgNum = sprite.damageNumbers[i];
              dmgNum.time += dt;
              dmgNum.y += dmgNum.vy * dt;
              dmgNum.vy += 30 * dt; // Gravity effect
              
              if (dmgNum.time >= dmgNum.duration) {
                sprite.damageNumbers.splice(i, 1);
              }
            }
          });
          
          // Update explosions
          if (debugState.explosions) {
            for (let i = debugState.explosions.length - 1; i >= 0; i--) {
              const explosion = debugState.explosions[i];
              explosion.time += dt;
              
              if (explosion.time >= explosion.duration) {
                debugState.explosions.splice(i, 1);
              }
            }
          }
        }
        
        function worldToDebugScreen(wx, wy) {
          const sx = (wx - debugCamera.x) * 20 * debugCamera.zoom + canvasWidth / 2;
          const sy = (wy - debugCamera.y) * 20 * debugCamera.zoom + canvasHeight / 2;
          return { x: sx, y: sy };
        }
        
        function renderDebugMode() {
          // Clear canvas
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);
          
          // Draw grid
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          const gridSize = 50;
          const startX = Math.floor((debugCamera.x - canvasWidth / (2 * 20 * debugCamera.zoom)) / gridSize) * gridSize;
          const endX = Math.ceil((debugCamera.x + canvasWidth / (2 * 20 * debugCamera.zoom)) / gridSize) * gridSize;
          const startY = Math.floor((debugCamera.y - canvasHeight / (2 * 20 * debugCamera.zoom)) / gridSize) * gridSize;
          const endY = Math.ceil((debugCamera.y + canvasHeight / (2 * 20 * debugCamera.zoom)) / gridSize) * gridSize;
          
          for (let x = startX; x <= endX; x += gridSize) {
            const screenPos = worldToDebugScreen(x, debugCamera.y);
            ctx.beginPath();
            ctx.moveTo(screenPos.x, 0);
            ctx.lineTo(screenPos.x, canvasHeight);
            ctx.stroke();
          }
          
          for (let y = startY; y <= endY; y += gridSize) {
            const screenPos = worldToDebugScreen(debugCamera.x, y);
            ctx.beginPath();
            ctx.moveTo(0, screenPos.y);
            ctx.lineTo(canvasWidth, screenPos.y);
            ctx.stroke();
          }
          
          // Draw placed sprites
          debugState.sprites.forEach(sprite => {
            if (sprite.destroyed) return; // Skip destroyed sprites (they'll show explosion instead)
            
            const screenPos = worldToDebugScreen(sprite.x, sprite.y);
            
            ctx.save();
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(sprite.angle);
            
            // Calculate sprite size (much bigger than before)
            const spriteScale = 2.0; // Make sprites bigger
            const w = sprite.hitbox.width * debugCamera.zoom * spriteScale;
            const h = sprite.hitbox.height * debugCamera.zoom * spriteScale;
            
            // Flash effect when recently hit
            const timeSinceHit = performance.now() - sprite.lastHitTime;
            const isFlashing = timeSinceHit < 200; // Flash for 200ms after hit
            
            if (isFlashing) {
              ctx.globalAlpha = 0.3 + 0.7 * Math.sin(timeSinceHit * 0.05); // Flashing effect
            } else {
              ctx.globalAlpha = 1.0; // Reset alpha for non-flashing sprites
            }
            
            // Try to use actual sprite images
            let spriteImage = null;
            let fallbackColor = '#888888';
            
            if (sprite.type === 'player') {
              if (window.assets && window.assets.loaded && window.assets.loaded.spitfire && window.assets.spitfire) {
                spriteImage = window.assets.spitfire;
              }
              fallbackColor = '#00ff00';
            } else if (sprite.type === 'enemy_bf109') {
              if (window.assets && window.assets.loaded && window.assets.loaded.bf109Left && window.assets.bf109Left) {
                spriteImage = window.assets.bf109Left;
              }
              fallbackColor = '#ff4444';
            } else if (sprite.type === 'enemy_ju88') {
              if (window.assets && window.assets.loaded && window.assets.loaded.ju88 && window.assets.ju88) {
                spriteImage = window.assets.ju88;
              }
              fallbackColor = '#ff8844';
            }
            
            // Draw sprite image or fallback rectangle
            if (spriteImage) {
              ctx.drawImage(spriteImage, -w/2, -h/2, w, h);
            } else {
              ctx.fillStyle = fallbackColor;
              ctx.fillRect(-w/2, -h/2, w, h);
            }
            
            // Draw hitbox if enabled
            if (debugState.showHitboxes) {
              ctx.strokeStyle = '#ffffff';
              ctx.lineWidth = 2;
              ctx.strokeRect(-w/2, -h/2, w, h);
              
              // Draw collision radius
              ctx.strokeStyle = '#ff0000';
              ctx.lineWidth = 1;
              const collisionRadius = Math.max(sprite.hitbox.width, sprite.hitbox.height) / 4 * debugCamera.zoom * spriteScale;
              ctx.beginPath();
              ctx.arc(0, 0, collisionRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw health bar above sprite
            const healthBarWidth = w;
            const healthBarHeight = 4;
            const healthBarY = screenPos.y - h/2 - 10;
            
            // Health bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(screenPos.x - healthBarWidth/2, healthBarY, healthBarWidth, healthBarHeight);
            
            // Health bar fill
            const healthPercent = sprite.health / sprite.maxHealth;
            let healthColor = '#00ff00'; // Green
            if (healthPercent < 0.7) healthColor = '#ffff00'; // Yellow
            if (healthPercent < 0.3) healthColor = '#ff4444'; // Red
            
            ctx.fillStyle = healthColor;
            ctx.fillRect(screenPos.x - healthBarWidth/2, healthBarY, healthBarWidth * healthPercent, healthBarHeight);
            
            // Health bar border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(screenPos.x - healthBarWidth/2, healthBarY, healthBarWidth, healthBarHeight);
            
            // Health text
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${sprite.health}/${sprite.maxHealth}`, screenPos.x, healthBarY - 2);
          });
          
          // Draw player sprite (shooting sprite)
          const playerScreen = worldToDebugScreen(debugState.player.x, debugState.player.y);
          ctx.save();
          ctx.translate(playerScreen.x, playerScreen.y);
          ctx.rotate(debugState.player.angle);
          
          const spriteScale = 2.0;
          const pw = 20 * debugCamera.zoom * spriteScale;
          const ph = 8 * debugCamera.zoom * spriteScale;
          
          // Try to use actual player sprite
          if (window.assets && window.assets.loaded && window.assets.loaded.spitfire && window.assets.spitfire) {
            ctx.drawImage(window.assets.spitfire, -pw/2, -ph/2, pw, ph);
          } else {
            ctx.fillStyle = '#0088ff';
            ctx.fillRect(-pw/2, -ph/2, pw, ph);
          }
          
          if (debugState.showHitboxes) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-pw/2, -ph/2, pw, ph);
          }
          
          // Draw direction indicator
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(pw/2 + 5, 0);
          ctx.stroke();
          
          ctx.restore();
          
          // Draw projectiles
          if (window.game && window.game.projectiles) {
            window.game.projectiles.forEach(proj => {
              const screenPos = worldToDebugScreen(proj.x, proj.y);
              
              ctx.fillStyle = proj.type === 'tracer' ? '#ffff00' : '#ff8800';
              ctx.fillRect(screenPos.x - 2, screenPos.y - 2, 4, 4);
            });
          }
          
          // Draw casings
          if (window.game && window.game.casings) {
            window.game.casings.forEach(casing => {
              const screenPos = worldToDebugScreen(casing.x, casing.y);
              
              ctx.save();
              ctx.translate(screenPos.x, screenPos.y);
              ctx.rotate(casing.rotation);
              ctx.fillStyle = '#888800';
              ctx.fillRect(-1, -1, 2, 2);
              ctx.restore();
            });
          }
          
          // Draw explosions
          if (debugState.explosions) {
            debugState.explosions.forEach(explosion => {
              const screenPos = worldToDebugScreen(explosion.x, explosion.y);
              const progress = explosion.time / explosion.duration;
              const alpha = 1.0 - progress;
              
              ctx.save();
              ctx.translate(screenPos.x, screenPos.y);
              ctx.globalAlpha = alpha;
              
              if (explosion.type === 'hit') {
                // Small hit explosion - bright flash
                const size = explosion.size * debugCamera.zoom * (1 + progress * 2);
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Outer ring
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
              } else if (explosion.type === 'destruction') {
                // Large destruction explosion - expanding fireball
                const size = explosion.size * debugCamera.zoom * (0.5 + progress * 1.5);
                
                // Inner fire
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Outer explosion
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(0, 0, size * 1.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Smoke ring
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, size * 1.8, 0, Math.PI * 2);
                ctx.stroke();
              }
              
              ctx.restore();
            });
          }
          
          // Draw damage numbers
          debugState.sprites.forEach(sprite => {
            sprite.damageNumbers.forEach(dmgNum => {
              const screenPos = worldToDebugScreen(dmgNum.x, dmgNum.y);
              const progress = dmgNum.time / dmgNum.duration;
              const alpha = 1.0 - progress;
              
              ctx.save();
              ctx.globalAlpha = alpha;
              ctx.fillStyle = '#ff0000';
              ctx.font = 'bold 14px Arial';
              ctx.textAlign = 'center';
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              
              // Text with black outline
              ctx.strokeText(`-${dmgNum.damage}`, screenPos.x, screenPos.y);
              ctx.fillText(`-${dmgNum.damage}`, screenPos.x, screenPos.y);
              
              ctx.restore();
            });
          });
          
          // Calculate sprite statistics
          const aliveSprites = debugState.sprites.filter(s => !s.destroyed);
          const deadSprites = debugState.sprites.filter(s => s.destroyed);
          const totalDamageDealt = debugState.sprites.reduce((total, sprite) => 
            total + (sprite.maxHealth - sprite.health), 0);
          
          // Draw UI
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(5, 5, 320, 200);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px Arial';
          ctx.fillText('üõ†Ô∏è DEBUG MODE - Combat Testing', 10, 20);
          ctx.fillText(`Selected: ${spriteTypes[debugState.selectedSpriteType].name} (${spriteTypes[debugState.selectedSpriteType].maxHealth} HP)`, 10, 35);
          
          // Controls
          ctx.fillText('üéÆ CONTROLS:', 10, 55);
          ctx.font = '10px Arial';
          ctx.fillText('1: Player  2: BF-109  3: Ju-88', 10, 70);
          ctx.fillText('Left Click: Place  Right Click: Remove', 10, 82);
          ctx.fillText('H: Toggle Hitboxes  C: Clear All  R: Restore Health', 10, 94);
          ctx.fillText('WASD: Move Camera  +/-: Zoom  SPACE: Shoot', 10, 106);
          
          // Statistics
          ctx.font = '12px Arial';
          ctx.fillText('üìä STATISTICS:', 10, 125);
          ctx.font = '10px Arial';
          ctx.fillText(`Sprites: ${aliveSprites.length} alive, ${deadSprites.length} destroyed`, 10, 138);
          ctx.fillText(`Total Damage Dealt: ${totalDamageDealt} HP`, 10, 150);
          ctx.fillText(`Hitboxes: ${debugState.showHitboxes ? 'ON' : 'OFF'}  |  Active Explosions: ${debugState.explosions ? debugState.explosions.length : 0}`, 10, 162);
          
          // Technical info
          ctx.fillText(`Camera: (${debugCamera.x.toFixed(1)}, ${debugCamera.y.toFixed(1)}) Zoom: ${debugCamera.zoom.toFixed(2)}`, 10, 174);
          ctx.fillText(`Mouse: (${debugState.worldMousePos.x.toFixed(1)}, ${debugState.worldMousePos.y.toFixed(1)})`, 10, 186);
          
          // Draw status indicator
          ctx.fillStyle = window.assets && window.assets.loaded ? '#00ff00' : '#ffff00';
          ctx.font = '10px Arial';
          ctx.fillText(`Assets: ${window.assets && window.assets.loaded ? 'LOADED' : 'LOADING...'}`, 10, 198);
        }
        
        // =============================================================================
        // DEBUG MODE GAME LOOP
        // =============================================================================
        
        let lastTime = performance.now();
        
        function debugGameLoop(time) {
          const dt = Math.min((time - lastTime) / 1000, 0.05);
          lastTime = time;
          
          updateDebugMode(dt);
          renderDebugMode();
          
          requestAnimationFrame(debugGameLoop);
        }
        
        // Start debug mode loop
        console.log('üõ†Ô∏è Starting debug mode loop...');
        requestAnimationFrame(debugGameLoop);
      }
      
      // Do not auto-start; wait for Start button click (handled above)
      
    })();
  </script>
  <script src="/web/js/projectiles.js"></script>
</body>
</html>