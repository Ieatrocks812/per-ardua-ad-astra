<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle ‚Ä¢ A: Pitch Up ‚Ä¢ D: Pitch Down ‚Ä¢ Q/E: Zoom ‚Ä¢ Arrows: Roll ‚Ä¢ F: Flip ‚Ä¢ G: Gear ‚Ä¢ Space: Fire ‚Ä¢ C: Debug ‚Ä¢ R: Reset
  </div>

  <!-- Start Screen -->
  <div id="startScreen" style="
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #2F4F4F 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    font-family: 'Arial', sans-serif;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  ">
    <h1 style="font-size: 4rem; margin-bottom: 1rem; text-align: center;">
      Per Ardua ad Astra
    </h1>
    <p style="font-size: 1.5rem; margin-bottom: 3rem; text-align: center; opacity: 0.9;">
      "Through Adversity to the Stars"
    </p>
    <button id="startButton" style="
      font-size: 1.5rem;
      padding: 1rem 3rem;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid white;
      color: white;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      text-shadow: none;
      font-weight: bold;
    " onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='scale(1.1)'" 
       onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='scale(1)'">
      START FLIGHT
    </button>
    <div style="margin-top: 2rem; text-align: center; opacity: 0.7; font-size: 0.9rem;">
      <p>üéÆ Use W/S for throttle, A/D for pitch, arrows for roll</p>
      <p>üî´ Press SPACE to fire wing guns with tracers and casings</p>
      <p>‚úàÔ∏è Realistic flight physics with altitude effects above 5000m</p>
    </div>
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';
      
      // Game state
      let gameStarted = false;
      
      // Start screen functionality
      document.getElementById('startButton').addEventListener('click', () => {
        if (gameStarted) return; // prevent double init
        console.log('üöÄ Starting game...');
        document.getElementById('startScreen').style.display = 'none';
        gameStarted = true;
        initializeGame();
      });
      
      // Initialize game function
      function initializeGame() {

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants - Physics world scaling for higher speeds (more reasonable scaling)
      const PHYSICS_SCALE = 0.5; // Physics objects are 2x smaller for higher speeds
      const VISUAL_SCALE = 2.0; // Visual rendering compensates with 2x scaling  
      const SCALE = 20 * VISUAL_SCALE; // Base pixels per meter (40 after scaling)
      const WORLD_WIDTH = 4000 * PHYSICS_SCALE; // Physics: 400 units (visually 4000m)
      const WORLD_HEIGHT = 3000 * PHYSICS_SCALE; // Physics: 300 units (visually 3000m)
      const MAP_BOTTOM_ALTITUDE = 300; // Physics: 300 units above ground (visually 600m)
      
      // Physics world
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Remove Box2D velocity limits for higher speeds
      // Default is 2.0 units per timestep (120 m/s at 60fps)
      console.log('üîß Attempting to override Box2D velocity limits...');
      
      if (world.setMaxLinearVelocity) {
        world.setMaxLinearVelocity(10.0); // Allow up to 600 m/s
        console.log('‚úÖ Set world max linear velocity to 10.0');
      }
      
      // Alternative method for Planck.js
      if (pl.Settings) {
        console.log('üìä Original Settings:', { 
          maxTranslation: pl.Settings.maxTranslation, 
          maxLinearVelocity: pl.Settings.maxLinearVelocity 
        });
        pl.Settings.maxTranslation = 10.0; // Increase from default 2.0
        pl.Settings.maxLinearVelocity = 600.0; // Direct velocity limit
        console.log('‚úÖ Updated Settings:', { 
          maxTranslation: pl.Settings.maxTranslation, 
          maxLinearVelocity: pl.Settings.maxLinearVelocity 
        });
      } else {
        console.log('‚ö†Ô∏è pl.Settings not available');
      }
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        tileableMap: null,
        spitfire: null,
        spitfireInverted: null,
        spitfireGear: null,
        spitfireInvertedGear: null,
        bullet: null,
        tracer: null,
        casing: null,
        ju88: null,
        explosion: null,
        loaded: { map: false, tileableMap: false, spitfire: false, spitfireInverted: false, spitfireGear: false, spitfireInvertedGear: false, bullet: false, tracer: false, casing: false, ju88: false, explosion: false }
      };
      
      async function loadAssets() {
        console.log('üéÆ Starting asset loading...');
        console.log('üìç Current location:', window.location.href);
        console.log('üìÇ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          tileableMap: [
            '../assets/sprites/environment/tileable map.png',
            './assets/sprites/environment/tileable map.png',
            '/assets/sprites/environment/tileable map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            './assets/sprites/aircraft/player/Spitfire facing right with gear.png',
            '/assets/sprites/aircraft/player/Spitfire facing right with gear.png'
          ],
          spitfireInverted: [
            '../assets/sprites/aircraft/player/spitfire upside down.png',
            './assets/sprites/aircraft/player/spitfire upside down.png',
            '/assets/sprites/aircraft/player/spitfire upside down.png'
          ],
          spitfireGear: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ],
          spitfireInvertedGear: [
            '../assets/sprites/aircraft/player/spitfire upside down with gear.png',
            './assets/sprites/aircraft/player/spitfire upside down with gear.png',
            '/assets/sprites/aircraft/player/spitfire upside down with gear.png'
          ],
          bullet: [
            '../assets/sprites/effects/bullet.png',
            './assets/sprites/effects/bullet.png',
            '/assets/sprites/effects/bullet.png'
          ],
          tracer: [
            '../assets/sprites/effects/Tracer round.png',
            './assets/sprites/effects/Tracer round.png',
            '/assets/sprites/effects/Tracer round.png'
          ],
          casing: [
            '../assets/sprites/effects/casing.png',
            './assets/sprites/effects/casing.png',
            '/assets/sprites/effects/casing.png'
          ],
          ju88: [
            '../assets/sprites/aircraft/enemies/ju-88.png',
            './assets/sprites/aircraft/enemies/ju-88.png',
            '/assets/sprites/aircraft/enemies/ju-88.png'
          ],
          explosion: [
            '../assets/sprites/effects/explosion.png',
            './assets/sprites/effects/explosion.png',
            '/assets/sprites/effects/explosion.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`üì∑ Trying ${name} from: ${currentPath}`);
              console.log(`üîó Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`‚úÖ ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`‚ùå ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load all assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('tileableMap', assetPaths.tileableMap),
            loadImage('spitfire', assetPaths.spitfire),
            loadImage('spitfireInverted', assetPaths.spitfireInverted),
            loadImage('spitfireGear', assetPaths.spitfireGear),
            loadImage('spitfireInvertedGear', assetPaths.spitfireInvertedGear),
            loadImage('bullet', assetPaths.bullet),
            loadImage('tracer', assetPaths.tracer),
            loadImage('casing', assetPaths.casing)
          ]);
          console.log('üéâ All assets loaded successfully!');
          console.log('üìä Final asset load status:', assets.loaded);
          
          // Specifically check gear sprites
          console.log('üõ¨ Gear sprite status:', {
            spitfireGear: { loaded: assets.loaded.spitfireGear, hasImage: !!assets.spitfireGear },
            spitfireInvertedGear: { loaded: assets.loaded.spitfireInvertedGear, hasImage: !!assets.spitfireInvertedGear }
          });
          console.log('üî´ Ordnance asset status:', {
            bullet: { loaded: assets.loaded.bullet, hasImage: !!assets.bullet },
            tracer: { loaded: assets.loaded.tracer, hasImage: !!assets.tracer },
            casing: { loaded: assets.loaded.casing, hasImage: !!assets.casing }
          });
        } catch (error) {
          console.warn('‚ö†Ô∏è Some assets failed to load:', error.message);
          console.log('üéÆ Game will continue with fallback graphics');
          console.log('üìä Asset load status after error:', assets.loaded);
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // Debug: Log initial game state
      setTimeout(() => {
        console.log('üöÄ Initial game state at startup:', {
          inverted: game.inverted,
          gearDown: game.gearDown,
          expectedSprite: 'Should be normal Spitfire facing right (no gear)'
        });
      }, 1000);
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.05, maxZoom: 9.0 }, // Much further zoom out (0.05 instead of 0.2)
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        crashed: false,
        inverted: false,
        gearDown: false,
        projectiles: [], // bullets and tracers
        casings: [], // ejected shells
        enemies: [], // enemy aircraft
        explosions: [] // explosion effects
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        game.keys.add(key);
        console.log('üéØ Key pressed:', key); // Debug key presses
        
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c','f','g',' '].includes(key)) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (key === 'c') {
          game.showCollision = !game.showCollision;
          console.log('üîç Collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
        
        // Toggle inverted flight mode
        if (key === 'f') {
          const oldInverted = game.inverted;
          game.inverted = !game.inverted;
          console.log('üîÑ Flight mode changed:', oldInverted ? 'INVERTED' : 'NORMAL', '‚Üí', game.inverted ? 'INVERTED' : 'NORMAL');
          console.log('üîÑ F key - Game state after flip:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        
        // Toggle landing gear
        if (key === 'g') {
          const oldGear = game.gearDown;
          game.gearDown = !game.gearDown;
          console.log('üõ¨ Gear changed:', oldGear ? 'DOWN' : 'UP', '‚Üí', game.gearDown ? 'DOWN' : 'UP');
          console.log('üõ¨ G key - Game state after gear toggle:', { inverted: game.inverted, gearDown: game.gearDown });
        }
        // Fire guns (space) - now handled in physics update for continuous fire
        if (key === ' ' || e.code === 'Space') {
          console.log('üéØ SPACE pressed - continuous fire mode');
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn above ground within main map (scaled physics)
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, -300), // 300 physics units above ground (visually 600m)
        angle: 0,
        linearDamping: 0.02, // Reduced from 0.1 for higher top speeds
        angularDamping: 8.0 // Very high damping for instant stop when controls released (works with force-based controls)
      });
      
      aircraft.createFixture({
        shape: pl.Box(4, 1.25), // 8m x 2.5m aircraft (scaled down 2x)
        density: 20, // kg/m¬≤
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create infinite ground collision at y=0 (physical ground - scaled)
        const groundLevel = 0; // ground at 0 altitude
        const halfThickness = 0.25; // scaled down collision thickness (2x scaling)
        const infiniteWidth = 50000; // Very wide ground - scaled down (2x scaling)
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel) // center at y=0
        });
        
        groundBody.createFixture({
          shape: pl.Box(infiniteWidth / 2, halfThickness),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel,
          width: infiniteWidth,
          height: halfThickness * 2,
          isMainGround: true
        });
        
        console.log(`üü¢ Created infinite ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // Create initial enemy aircraft
      createInitialEnemies();
      
      // =============================================================================
      // GUNS AND PROJECTILES
      // =============================================================================
      
      let lastFireTime = 0;
      let shotCounter = 0; // Dedicated counter for tracer pattern
      const fireRate = 600; // rounds per minute
      const fireInterval = 60000 / fireRate; // ms between shots
      
              // Projectile size settings (world units - stays same relative to plane/map regardless of zoom)
        const BULLET_SIZE = 5; // world units
        const TRACER_LENGTH = 1.0; // world units  
        const TRACER_WIDTH = 0.1; // world units
        const CASING_SIZE = 3; // world units (much smaller casings)
        
        // =============================================================================
        // ENEMY SYSTEM
        // =============================================================================
        
        // Enemy spawning system
        let lastSpawnTime = 0;
        const spawnInterval = 15000; // Spawn new formation every 15 seconds
        let formationCounter = 0;
        
        function createInitialEnemies() {
          console.log('‚úàÔ∏è Creating initial enemy aircraft formations...');
          
          // Create a few initial formations
          for (let i = 0; i < 3; i++) {
            spawnEnemyFormation();
          }
        }
        
        function spawnEnemyFormation() {
          console.log('‚úàÔ∏è Spawning new enemy formation...');
          
          const enemyAltitude = -500; // 1000m above ground in physics units (500 * VISUAL_SCALE = 1000m)
          const vSpacing = 100; // 200m between aircraft in V formation
          const vOffset = 50; // 100m vertical offset for V wings
          
          // Spawn from the right side of the map, far ahead of player
          const spawnX = 2000; // 4000m to the right
          
          // Add some random altitude variation
          const altitudeVariation = (Math.random() - 0.5) * 200; // ¬±200m variation
          const baseAltitude = enemyAltitude + altitudeVariation;
          
          // Create V formation of 3 aircraft
          for (let pos = 0; pos < 3; pos++) {
            let x, y;
            
            if (pos === 0) {
              // Lead aircraft (center of V)
              x = spawnX;
              y = baseAltitude;
            } else if (pos === 1) {
              // Left wing (relative to their flight direction - behind and below)
              x = spawnX + vSpacing;
              y = baseAltitude - vOffset;
            } else {
              // Right wing (relative to their flight direction - behind and above)
              x = spawnX + vSpacing;
              y = baseAltitude + vOffset;
            }
            
            // Create Box2D body for enemy
            const enemyBody = world.createBody({
              type: 'dynamic',
              position: pl.Vec2(x, y),
              angle: Math.PI, // Face left (180 degrees)
              linearDamping: 0.02,
              angularDamping: 2.0
            });
            
            enemyBody.createFixture({
              shape: pl.Box(6, 1.5), // Ju-88 bomber size (12m x 3m)
              density: 25,
              friction: 0.3,
              restitution: 0.1
            });
            
            // Enemy data
            const enemy = {
              body: enemyBody,
              health: 10,
              maxHealth: 10,
              targetSpeed: 80,
              destroyed: false,
              thrustDisabled: false,
              liftDisabled: false,
              type: 'ju88',
              formation: formationCounter,
              position: pos,
              spawnTime: performance.now()
            };
            
            // Store reference for collision detection
            enemyBody.setUserData({ type: 'enemy', enemy: enemy });
            
            game.enemies.push(enemy);
            console.log(`‚úàÔ∏è Spawned Ju-88 bomber at (${x}, ${y}) - Formation ${formationCounter}, Position ${pos}`);
          }
          
          formationCounter++;
        }
        
        function updateEnemySpawning() {
          const now = performance.now();
          if (now - lastSpawnTime > spawnInterval) {
            spawnEnemyFormation();
            lastSpawnTime = now;
          }
          
          // Clean up enemies that have flown too far to the left
          for (let i = game.enemies.length - 1; i >= 0; i--) {
            const enemy = game.enemies[i];
            if (!enemy.destroyed) {
              const pos = enemy.body.getPosition();
              if (pos.x < -3000) { // 6000m to the left of spawn
                console.log('üóëÔ∏è Removing enemy that flew off map');
                world.destroyBody(enemy.body);
                game.enemies.splice(i, 1);
              }
            }
          }
        }
        
        function updateEnemies(dt) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            const pos = enemy.body.getPosition();
            const vel = enemy.body.getLinearVelocity();
            const angle = enemy.body.getAngle();
            const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
            
            // Use same physics as player aircraft but with AI controls
            
            // Thrust (same calculation as player)
            if (!enemy.thrustDisabled) {
              let maxThrust = 100000; // Same base thrust as player
              
              // Apply altitude-based thrust reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                maxThrust *= altitudeReduction;
              }
              
              const thrust = 0.8 * maxThrust; // 80% throttle for cruise
              const thrustForce = pl.Vec2(Math.cos(angle) * thrust, Math.sin(angle) * thrust);
              enemy.body.applyForceToCenter(thrustForce, true);
            }
            
            // Aerodynamics (same as player)
            if (speed > 1) {
              const q = 0.5 * 1.225 * speed * speed; // Dynamic pressure
              const wingArea = 25; // Wing area in m¬≤
              
              // Calculate angle of attack relative to velocity
              const velocityAngle = Math.atan2(vel.y, vel.x);
              const aoa = angle - velocityAngle;
              
              // Lift coefficient (same as player)
              let liftCoeff = Math.sin(aoa * 2) * 1.5;
              
              // Apply altitude-based lift reduction (same as player)
              const visualAltitude = -pos.y * VISUAL_SCALE;
              if (visualAltitude > 5000) {
                const altitudeReduction = Math.max(0, (5250 - visualAltitude) / 250);
                liftCoeff *= altitudeReduction;
              }
              
              // Apply lift perpendicular to velocity
              if (!enemy.liftDisabled) {
                const lift = q * wingArea * liftCoeff;
                const liftAngle = velocityAngle + Math.PI/2;
                const liftForce = pl.Vec2(Math.cos(liftAngle) * lift, Math.sin(liftAngle) * lift);
                enemy.body.applyForceToCenter(liftForce, true);
              }
              
              // Drag (same as player)
              const dragCoeff = 0.01 + Math.abs(liftCoeff) * 0.01;
              const drag = q * wingArea * dragCoeff;
              const dragForce = pl.Vec2(-vel.x / speed * drag, -vel.y / speed * drag);
              enemy.body.applyForceToCenter(dragForce, true);
            }
            
            // Simple AI: Keep wings level and nose pointing left
            const targetAngle = Math.PI; // Fly left (180 degrees)
            const angleDiff = targetAngle - angle;
            
            // Normalize angle difference to [-œÄ, œÄ]
            let normalizedAngleDiff = angleDiff;
            while (normalizedAngleDiff > Math.PI) normalizedAngleDiff -= 2 * Math.PI;
            while (normalizedAngleDiff < -Math.PI) normalizedAngleDiff += 2 * Math.PI;
            
            // Apply gentle correction torque to maintain leftward flight
            if (Math.abs(normalizedAngleDiff) > 0.1) { // 5 degree deadband
              const correctionTorque = normalizedAngleDiff * 15000; // Gentle correction
              enemy.body.applyTorque(correctionTorque, true);
            }
          });
        }
        
        function checkProjectileEnemyCollision(proj, projIndex) {
          game.enemies.forEach(enemy => {
            if (enemy.destroyed) return;
            
            const pos = enemy.body.getPosition();
            const distance = Math.sqrt(
              (proj.x - pos.x) * (proj.x - pos.x) + 
              (proj.y - pos.y) * (proj.y - pos.y)
            );
            
            // Simple collision detection - within 10 physics units (20m)
            if (distance < 10) {
              console.log('üí• Projectile hit enemy!', { distance, enemyHealth: enemy.health });
              
              // Damage enemy
              enemy.health--;
              
              // Remove projectile
              game.projectiles.splice(projIndex, 1);
              
              // Check if enemy is destroyed
              if (enemy.health <= 0 && !enemy.destroyed) {
                destroyEnemy(enemy);
              } else if (enemy.health <= 5 && !enemy.thrustDisabled) {
                // Disable thrust when heavily damaged
                enemy.thrustDisabled = true;
                console.log('‚ö†Ô∏è Enemy thrust disabled');
              } else if (enemy.health <= 3 && !enemy.liftDisabled) {
                // Disable lift when critically damaged
                enemy.liftDisabled = true;
                console.log('‚ö†Ô∏è Enemy lift disabled');
              }
            }
          });
        }
        
        function destroyEnemy(enemy) {
          console.log('üí• Enemy destroyed!');
          enemy.destroyed = true;
          
          const pos = enemy.body.getPosition();
          
          // Create explosion effect
          game.explosions.push({
            x: pos.x,
            y: pos.y,
            time: 0,
            duration: 1.0, // 1 second explosion
            size: 20 // 40m explosion diameter
          });
          
          // Remove body from physics world
          world.destroyBody(enemy.body);
        }
        
        function updateExplosions(dt) {
          for (let i = game.explosions.length - 1; i >= 0; i--) {
            const explosion = game.explosions[i];
            explosion.time += dt;
            
            if (explosion.time >= explosion.duration) {
              game.explosions.splice(i, 1);
            }
          }
        }
      
      function trySpawnGuns() {
        console.log('üî´ trySpawnGuns called');
        const now = performance.now();
        console.log('üïí Fire timing:', { now, lastFireTime, interval: fireInterval, canFire: now - lastFireTime >= fireInterval });
        if (now - lastFireTime < fireInterval) {
          console.log('‚è±Ô∏è Fire rate limited, skipping');
          return;
        }
        lastFireTime = now;
        
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const vel = aircraft.getLinearVelocity();
        
        // Center gun position (middle of plane)
        const gunForward = 2.0; // Forward from center to gun muzzle
        
        // Calculate gun position (center of plane)
        const gunPos = {
          x: pos.x + Math.cos(angle) * gunForward,
          y: pos.y + Math.sin(angle) * gunForward
        };
        
        // Muzzle velocity (relative to aircraft)
        const muzzleVelocity = 400; // m/s in physics units (increased from 150)
        const bulletVel = {
          x: vel.x + Math.cos(angle) * muzzleVelocity,
          y: vel.y + Math.sin(angle) * muzzleVelocity
        };
        
        // Increment shot counter and determine tracer pattern
        shotCounter++;
        // Spawn bullets and tracers (every 4th round is a tracer: bullet, bullet, bullet, tracer)
        const isTracer = shotCounter % 4 === 0;
        console.log(`üéØ Shot #${shotCounter}: ${isTracer ? 'TRACER' : 'BULLET'} (pattern: ${shotCounter % 4})`);
        
        // Center gun
        game.projectiles.push({
          x: gunPos.x,
          y: gunPos.y,
          vx: bulletVel.x,
          vy: bulletVel.y,
          type: isTracer ? 'tracer' : 'bullet',
          life: 5.0, // 5 seconds max flight time
          initialSpeed: Math.sqrt(bulletVel.x * bulletVel.x + bulletVel.y * bulletVel.y)
        });
        
        // Spawn casing from bottom of aircraft
        const casingPos = {
          x: pos.x - Math.cos(angle) * 0.5, // Slightly behind center
          y: pos.y - Math.sin(angle) * 0.5 + 0.8 // Below aircraft
        };
        
        game.casings.push({
          x: casingPos.x,
          y: casingPos.y,
          vx: vel.x + (Math.random() - 0.5) * 10, // Random sideways velocity
          vy: vel.y + 15 + Math.random() * 10, // Downward with randomness
          rotation: Math.random() * Math.PI * 2,
          angularVel: (Math.random() - 0.5) * 20,
          life: 10.0 // Casings last longer
        });
        
        console.log('üî´ Fired guns! Projectiles:', game.projectiles.length, 'Casings:', game.casings.length);
        console.log('üéØ Latest projectile:', game.projectiles[game.projectiles.length - 1]);
        console.log('üéØ Latest casing:', game.casings[game.casings.length - 1]);
      }
      
      function updateProjectiles(dt) {
        // Update bullets and tracers
        for (let i = game.projectiles.length - 1; i >= 0; i--) {
          const proj = game.projectiles[i];
          
          // Check collision with enemies before updating position
          checkProjectileEnemyCollision(proj, i);
          
          // Apply drag
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const dragCoeff = 0.02; // Air resistance
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            proj.vx -= (proj.vx / speed) * drag * dt;
            proj.vy -= (proj.vy / speed) * drag * dt;
          }
          
          // Update position
          proj.x += proj.vx * dt;
          proj.y += proj.vy * dt;
          
          // Decrease life
          proj.life -= dt;
          
          // Remove if expired
          if (proj.life <= 0) {
            game.projectiles.splice(i, 1);
          }
        }
        
        // Update casings
        for (let i = game.casings.length - 1; i >= 0; i--) {
          const casing = game.casings[i];
          
          // Apply gravity and drag
          casing.vy += 9.81 * dt; // Gravity
          
          const speed = Math.sqrt(casing.vx * casing.vx + casing.vy * casing.vy);
          const dragCoeff = 0.8; // Extreme drag for casings (was 0.3)
          const drag = dragCoeff * speed;
          
          if (speed > 0) {
            casing.vx -= (casing.vx / speed) * drag * dt;
            casing.vy -= (casing.vy / speed) * drag * dt;
          }
          
          // Update position and rotation
          casing.x += casing.vx * dt;
          casing.y += casing.vy * dt;
          casing.rotation += casing.angularVel * dt;
          
          // Decrease life
          casing.life -= dt;
          
          // Remove if expired
          if (casing.life <= 0) {
            game.casings.splice(i, 1);
          }
        }
      }
      
      // Add collision detection for landing/crashing system
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft hit ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const verticalSpeed = Math.abs(vel.y); // Vertical component only
          const totalSpeed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          console.log(`üõ¨ Ground contact - Vertical: ${verticalSpeed.toFixed(1)} m/s, Total: ${totalSpeed.toFixed(1)} m/s, Gear: ${game.gearDown ? 'DOWN' : 'UP'}`);
          
          // Define crash threshold for vertical speed
          const crashThreshold = 8.0; // m/s vertical speed threshold
          const hardLandingThreshold = 4.0; // m/s for speed reduction without gear
          
          if (verticalSpeed > crashThreshold) {
            // High vertical speed = crash regardless of gear
            game.crashed = true;
            console.log('üí• CRASHED! Vertical speed too high:', verticalSpeed.toFixed(1), 'm/s');
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else if (!game.gearDown && verticalSpeed > hardLandingThreshold) {
            // Hard landing without gear = lose speed but don't crash
            console.log('‚ö†Ô∏è Hard landing without gear! Losing speed...');
            const speedReduction = 0.3; // Reduce speed by 70%
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * speedReduction,
              vel.y * speedReduction
            ));
            // Add some bounce/instability
            aircraft.setAngularVelocity(aircraft.getAngularVelocity() + (Math.random() - 0.5) * 2);
          } else if (game.gearDown) {
            // Safe landing with gear down
            console.log('‚úÖ Safe landing with gear down!');
            // Gentle speed reduction for realistic landing
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.8,
              Math.min(vel.y, 0) // Stop downward motion
            ));
          } else {
            // Low speed ground contact without gear (gentle bump)
            console.log('üü° Gentle ground contact');
            aircraft.setLinearVelocity(pl.Vec2(
              vel.x * 0.9,
              Math.min(vel.y, 0)
            ));
          }
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, -300), 0); // Reset to safe altitude above ground (scaled)
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Calculate speed once for use in both controls and aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        // Flight controls - Hybrid approach (force + torque for reliability)
        const controlEffectiveness = Math.min(speed * 0.1, 1.0); // Controls more effective at higher speeds
        const controlTorque = 20000 * controlEffectiveness; // Moderate torque for reliable control
        
        // Debug control inputs
        if (Math.random() < 0.02) { // Occasional debug logging
          console.log('üéÆ Controls:', { pitchUp, pitchDown, rollLeft, rollRight, effectiveness: controlEffectiveness.toFixed(2) });
        }
        
        if (pitchUp) {
          aircraft.applyTorque(-controlTorque, true);
        }
        if (pitchDown) {
          aircraft.applyTorque(controlTorque, true);
        }
        if (rollLeft) {
          aircraft.applyTorque(-controlTorque * 0.6, true);
        }
        if (rollRight) {
          aircraft.applyTorque(controlTorque * 0.6, true);
        }
        
        // Continuous firing while holding space
        const firing = game.keys.has(' ');
        if (firing) {
          trySpawnGuns();
        }
        
        // Thrust - Further increased for higher top speeds with altitude reduction
        let maxThrust = 120000; // Quadrupled from original 30000 for much higher speeds
        
        // Altitude-based thrust reduction (same as lift)
        const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
        if (visualAltitude > 5000) {
          if (visualAltitude >= 5250) {
            maxThrust = 0; // No thrust above 5250m (engine failure)
          } else {
            // Linear reduction from 5000m to 5250m
            const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
            maxThrust *= reductionFactor;
          }
        }
        
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // Simple aerodynamics
        if (speed > 1) {
          const airDensity = 1.225;
          const wingArea = 20;
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified) with altitude-based reduction
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          let liftCoeff = Math.sin(aoa * 2) * 1.5;
          
          // Altitude-based lift reduction (physics units, converted to visual for calculation)
          const visualAltitude = -pos.y * VISUAL_SCALE; // Convert to visual altitude
          if (visualAltitude > 5000) {
            if (visualAltitude >= 5250) {
              liftCoeff = 0; // No lift above 5250m
            } else {
              // Linear reduction from 5000m to 5250m
              const reductionFactor = 1 - ((visualAltitude - 5000) / 250);
              liftCoeff *= reductionFactor;
            }
          }
          
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag - Minimized for very high top speeds
          const dragCoeff = 0.01 + Math.abs(liftCoeff) * 0.01; // Much lower drag for speeds well above 120 m/s
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background - main map in center, tileable on sides
        const groundLevel = 0; // physical ground reference
        const mapHeight = WORLD_HEIGHT;
        
        if (assets.loaded.map && assets.map && assets.loaded.tileableMap && assets.tileableMap) {
          // Calculate main map dimensions and position
          const mainMapWidth = WORLD_WIDTH; // 4000m wide
          const mainMapPixelWidth = mainMapWidth * SCALE * game.camera.zoom;
          const mainMapPixelHeight = mapHeight * SCALE * game.camera.zoom;
          // Draw main map in center such that its bottom sits at MAP_BOTTOM_ALTITUDE
          // So the draw origin (top-left) is at y = (MAP_BOTTOM_ALTITUDE - mapHeight)
          const mainMapPos = worldToScreen(-mainMapWidth/2, MAP_BOTTOM_ALTITUDE - mapHeight);
          ctx.drawImage(assets.map, mainMapPos.x, mainMapPos.y, mainMapPixelWidth, mainMapPixelHeight);
          
          // Calculate tileable map dimensions
          const tileableMapNaturalRatio = assets.tileableMap.naturalWidth / assets.tileableMap.naturalHeight;
          const tileableMapPixelHeight = mainMapPixelHeight; // Same height as main map
          const tileableMapPixelWidth = tileableMapPixelHeight * tileableMapNaturalRatio;
          const tileableMapWorldWidth = tileableMapPixelWidth / (SCALE * game.camera.zoom);
          
          // Draw tileable maps on the left side
          const leftStartX = -mainMapWidth/2;
          const visibleLeftStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - leftStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + leftStartX;
          for (let x = visibleLeftStart; x > game.camera.x - canvasWidth/(SCALE*game.camera.zoom); x -= tileableMapWorldWidth) {
            const tilePos = worldToScreen(x - tileableMapWorldWidth, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
          // Draw tileable maps on the right side
          const rightStartX = mainMapWidth/2;
          const visibleRightStart = Math.floor((game.camera.x - canvasWidth/(2*SCALE*game.camera.zoom) - rightStartX) / tileableMapWorldWidth) * tileableMapWorldWidth + rightStartX;
          for (let x = visibleRightStart; x < game.camera.x + canvasWidth/(SCALE*game.camera.zoom); x += tileableMapWorldWidth) {
            const tilePos = worldToScreen(x, MAP_BOTTOM_ALTITUDE - mapHeight);
            ctx.drawImage(assets.tileableMap, tilePos.x, tilePos.y, tileableMapPixelWidth, tileableMapPixelHeight);
          }
          
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map || !assets.loaded.tileableMap) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading maps...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        // Debug: Log aircraft state periodically
        if (Math.random() < 0.02) { // 2% chance per frame for debugging
          console.log('‚úàÔ∏è Aircraft state:', {
            angle: (angle * 180 / Math.PI).toFixed(1) + '¬∞',
            inverted: game.inverted,
            gearDown: game.gearDown,
            position: { x: pos.x.toFixed(1), y: pos.y.toFixed(1) },
            expectedSprite: game.inverted && game.gearDown ? 'inverted+gear' : 
                          game.inverted && !game.gearDown ? 'inverted' :
                          !game.inverted && game.gearDown ? 'normal+gear' : 'normal'
          });
        }
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        // Choose sprite based on inverted mode and gear state
        let currentSprite, spriteLoaded, spriteDescription;
        
        if (game.inverted && game.gearDown) {
          currentSprite = assets.spitfireInvertedGear;
          spriteLoaded = assets.loaded.spitfireInvertedGear;
          spriteDescription = "inverted with gear";
        } else if (game.inverted && !game.gearDown) {
          currentSprite = assets.spitfireInverted;
          spriteLoaded = assets.loaded.spitfireInverted;
          spriteDescription = "inverted no gear";
        } else if (!game.inverted && game.gearDown) {
          currentSprite = assets.spitfireGear;
          spriteLoaded = assets.loaded.spitfireGear;
          spriteDescription = "normal with gear";
        } else {
          currentSprite = assets.spitfire;
          spriteLoaded = assets.loaded.spitfire;
          spriteDescription = "normal no gear";
        }
        
        // Debug: Log sprite selection when gear changes
        if (game.keys.has('g') && Math.random() < 0.1) { // 10% chance when G is held
          console.log('üé® Sprite selection:', {
            description: spriteDescription,
            spriteLoaded: spriteLoaded,
            hasSprite: !!currentSprite,
            allLoadStates: assets.loaded
          });
        }
        
        if (spriteLoaded && currentSprite) {
          const scale = 0.4 * game.camera.zoom;
          const w = currentSprite.naturalWidth * scale;
          const h = currentSprite.naturalHeight * scale;
          ctx.drawImage(currentSprite, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          let fillColor = '#4169E1'; // Default blue
          if (game.inverted && game.gearDown) fillColor = '#800080'; // Purple for inverted with gear
          else if (game.inverted) fillColor = '#E14169'; // Red for inverted
          else if (game.gearDown) fillColor = '#228B22'; // Green for gear down
          
          ctx.fillStyle = fillColor;
          ctx.strokeStyle = game.inverted ? '#801080' : '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
          
          // Draw gear indicator
          if (game.gearDown) {
            ctx.fillStyle = '#FFD700'; // Gold for gear
            ctx.fillRect(-size*0.3, size*0.3, size*0.6, size*0.2);
          }
        }
        
        ctx.restore();
        
        // Render projectiles (bullets and tracers)
        if (game.projectiles.length > 0) {
          console.log('üé® Rendering', game.projectiles.length, 'projectiles');
        }
        game.projectiles.forEach(proj => {
          const screenPos = worldToScreen(proj.x, proj.y);
          const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
          const angle = Math.atan2(proj.vy, proj.vx);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(angle);
          
          if (proj.type === 'tracer') {
            // Tracer gets smaller as it slows down, but maintains world scale
            const speedRatio = speed / proj.initialSpeed;
            const tracerLength = TRACER_LENGTH * speedRatio * SCALE * game.camera.zoom;
            const tracerWidth = TRACER_WIDTH * speedRatio * SCALE * game.camera.zoom;
            
            // Debug scaling
            console.log('üéØ Tracer scaling:', { 
              TRACER_LENGTH, speedRatio, SCALE, zoom: game.camera.zoom, 
              finalLength: tracerLength, finalWidth: tracerWidth,
              assetLoaded: assets.loaded.tracer, hasAsset: !!assets.tracer 
            });
            
            if (assets.loaded.tracer && assets.tracer) {
              console.log('üñºÔ∏è Using tracer sprite:', assets.tracer.src);
              ctx.drawImage(assets.tracer, -tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            } else {
              console.log('üî∏ Using fallback tracer');
              // Fallback tracer - bright orange/yellow, no red
              ctx.fillStyle = `rgba(255, 165, 0, ${Math.max(0.6, 0.9 * speedRatio)})`; // Orange instead of red
              ctx.fillRect(-tracerLength/2, -tracerWidth/2, tracerLength, tracerWidth);
            }
          } else {
            // Regular bullet - world scale
            const bulletSize = BULLET_SIZE * SCALE * game.camera.zoom;
            
            // Debug scaling (only log occasionally to avoid spam)
            if (Math.random() < 0.01) {
              console.log('üî´ Bullet scaling:', { 
                BULLET_SIZE, SCALE, zoom: game.camera.zoom, 
                finalSize: bulletSize,
                assetLoaded: assets.loaded.bullet, hasAsset: !!assets.bullet 
              });
            }
            
            if (assets.loaded.bullet && assets.bullet) {
              const scale = bulletSize / Math.max(assets.bullet.naturalWidth, assets.bullet.naturalHeight);
              const w = assets.bullet.naturalWidth * scale;
              const h = assets.bullet.naturalHeight * scale;
              ctx.drawImage(assets.bullet, -w/2, -h/2, w, h);
            } else {
              // Fallback bullet - bright gold/yellow
              ctx.fillStyle = '#FFD700';
              ctx.fillRect(-bulletSize/2, -bulletSize/2, bulletSize, bulletSize);
            }
          }
          
          ctx.restore();
        });
        
        // Render casings
        game.casings.forEach(casing => {
          const screenPos = worldToScreen(casing.x, casing.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(casing.rotation);
          
          const casingSize = CASING_SIZE * SCALE * game.camera.zoom;
          
          // Debug scaling (only log occasionally to avoid spam)
          if (Math.random() < 0.01) {
            console.log('üî´ Casing scaling:', { 
              CASING_SIZE, SCALE, zoom: game.camera.zoom, 
              finalSize: casingSize,
              assetLoaded: assets.loaded.casing, hasAsset: !!assets.casing 
            });
          }
          
          if (assets.loaded.casing && assets.casing) {
            const scale = casingSize / Math.max(assets.casing.naturalWidth, assets.casing.naturalHeight);
            const w = assets.casing.naturalWidth * scale;
            const h = assets.casing.naturalHeight * scale;
            ctx.drawImage(assets.casing, -w/2, -h/2, w, h);
          } else {
            // Fallback casing - brass colored
            ctx.fillStyle = '#DAA520'; // Dark golden rod (brass color)
            ctx.fillRect(-casingSize/2, -casingSize/3, casingSize, casingSize*2/3);
          }
          
          ctx.restore();
        });
        
        // Render enemies
        game.enemies.forEach(enemy => {
          if (enemy.destroyed) return;
          
          const pos = enemy.body.getPosition();
          const angle = enemy.body.getAngle();
          const screenPos = worldToScreen(pos.x, pos.y);
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          ctx.rotate(angle);
          
          // Enemy aircraft size (Ju-88 bomber)
          const enemyWidth = 12 * SCALE * game.camera.zoom; // 24m wingspan
          const enemyHeight = 3 * SCALE * game.camera.zoom; // 6m length
          
          if (assets.loaded.ju88 && assets.ju88) {
            // Use Ju-88 sprite
            ctx.drawImage(assets.ju88, -enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
          } else {
            // Debug: Log sprite loading status occasionally
            if (Math.random() < 0.01) {
              console.log('üñºÔ∏è Ju-88 sprite status:', { loaded: assets.loaded.ju88, hasSprite: !!assets.ju88 });
            }
            // Fallback enemy - dark grey bomber
            ctx.fillStyle = enemy.health <= 5 ? '#8B0000' : '#444444'; // Red if heavily damaged
            ctx.fillRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
            
            // Wing outline
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 2;
            ctx.strokeRect(-enemyWidth/2, -enemyHeight/2, enemyWidth, enemyHeight);
          }
          
          // Health bar above enemy
          const barWidth = enemyWidth;
          const barHeight = 4;
          const barY = -enemyHeight/2 - 10;
          
          // Background
          ctx.fillStyle = '#FF0000';
          ctx.fillRect(-barWidth/2, barY, barWidth, barHeight);
          
          // Health
          const healthRatio = enemy.health / enemy.maxHealth;
          ctx.fillStyle = healthRatio > 0.5 ? '#00FF00' : (healthRatio > 0.25 ? '#FFFF00' : '#FF0000');
          ctx.fillRect(-barWidth/2, barY, barWidth * healthRatio, barHeight);
          
          ctx.restore();
        });
        
        // Render explosions
        game.explosions.forEach(explosion => {
          const screenPos = worldToScreen(explosion.x, explosion.y);
          const progress = explosion.time / explosion.duration;
          const size = explosion.size * SCALE * game.camera.zoom * (1 + progress * 2); // Expand over time
          const alpha = 1 - progress; // Fade out
          
          ctx.save();
          ctx.translate(screenPos.x, screenPos.y);
          
          if (assets.loaded.explosion && assets.explosion) {
            // Use explosion sprite
            ctx.globalAlpha = alpha;
            ctx.drawImage(assets.explosion, -size/2, -size/2, size, size);
          } else {
            // Fallback explosion - animated fire ball
            ctx.globalAlpha = alpha;
            
            // Outer fire
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size/2);
            gradient.addColorStop(0, `rgba(255, 255, 0, ${alpha})`); // Yellow center
            gradient.addColorStop(0.3, `rgba(255, 100, 0, ${alpha})`); // Orange
            gradient.addColorStop(0.7, `rgba(255, 0, 0, ${alpha})`); // Red
            gradient.addColorStop(1, `rgba(50, 0, 0, 0)`); // Transparent edge
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.restore();
        });
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed * VISUAL_SCALE); // Convert to visual speed
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        // Altitude: distance above ground (converted to visual altitude)
        document.getElementById('altitude').textContent = Math.max(0, Math.round(-pos.y * VISUAL_SCALE));
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'üí• CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          updateProjectiles(timeStep);
          updateEnemies(timeStep);
          updateEnemySpawning(); // Handle continuous spawning and cleanup
          updateExplosions(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start the game loop at the end of initializeGame
      console.log('Starting flight simulator...');
      requestAnimationFrame(gameLoop);
      }
      
      // Do not auto-start; wait for Start button click (handled above)
      
    })();
  </script>
</body>
</html>