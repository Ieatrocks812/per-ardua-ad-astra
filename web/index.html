<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Per Ardua ad Astra</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: #1a1a1a; 
      font-family: 'Courier New', monospace; 
      overflow: hidden; 
    }
    #gameCanvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
      background: #000;
    }
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #fff;
      font-size: 16px;
      line-height: 1.4;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      color: #fff;
      font-size: 14px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  
  <div class="hud">
    <div>Speed: <span id="speed">0</span> m/s</div>
    <div>Throttle: <span id="throttle">0</span>%</div>
    <div>Altitude: <span id="altitude">0</span> m</div>
    <div>Zoom: <span id="zoom">1.0</span>x</div>
  </div>
  
  <div class="controls">
    W/S: Throttle â€¢ A: Pitch Up â€¢ D: Pitch Down â€¢ Q/E: Zoom â€¢ Arrows: Roll â€¢ C: Debug â€¢ R: Reset
  </div>

  <script src="https://unpkg.com/planck-js@0.3.0/dist/planck.min.js"></script>
  <script>
    (() => {
      'use strict';

      // =============================================================================
      // SETUP
      // =============================================================================
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const pl = window.planck;
      
      // Constants
      const SCALE = 20; // pixels per meter
      const WORLD_WIDTH = 4000; // meters
      const WORLD_HEIGHT = 3000; // meters
      
      // Physics world
      const world = new pl.World(pl.Vec2(0, 9.81));
      
      // Canvas setup
      let canvasWidth = 0;
      let canvasHeight = 0;
      
      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        canvasWidth = window.innerWidth;
        canvasHeight = window.innerHeight;
      }
      
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // =============================================================================
      // ASSET LOADING
      // =============================================================================
      
      const assets = {
        map: null,
        spitfire: null,
        loaded: { map: false, spitfire: false }
      };
      
      async function loadAssets() {
        console.log('ðŸŽ® Starting asset loading...');
        console.log('ðŸ“ Current location:', window.location.href);
        console.log('ðŸ“‚ Base directory:', window.location.origin + window.location.pathname.replace('/web/index.html', ''));
        
        // Define asset paths to try (in order of preference)
        const assetPaths = {
          map: [
            '../assets/sprites/environment/map.png',
            './assets/sprites/environment/map.png',
            '/assets/sprites/environment/map.png'
          ],
          spitfire: [
            '../assets/sprites/aircraft/player/Spitfire facing right.png',
            './assets/sprites/aircraft/player/Spitfire facing right.png',
            '/assets/sprites/aircraft/player/Spitfire facing right.png'
          ]
        };
        
        // Function to load a single image with multiple path attempts
        function loadImage(name, paths) {
          return new Promise((resolve, reject) => {
            let attemptIndex = 0;
            
            function tryNextPath() {
              if (attemptIndex >= paths.length) {
                reject(new Error(`Failed to load ${name} from any path`));
                return;
              }
              
              const img = new Image();
              const currentPath = paths[attemptIndex];
              
              console.log(`ðŸ“· Trying ${name} from: ${currentPath}`);
              console.log(`ðŸ”— Full URL will be: ${new URL(currentPath, window.location.href).href}`);
              
              img.onload = () => {
                console.log(`âœ… ${name} loaded successfully from: ${currentPath}`);
                console.log(`   Size: ${img.naturalWidth}x${img.naturalHeight}px`);
                assets[name] = img;
                assets.loaded[name] = true;
                resolve(img);
              };
              
              img.onerror = () => {
                console.log(`âŒ ${name} failed from: ${currentPath}`);
                attemptIndex++;
                tryNextPath();
              };
              
              img.src = currentPath;
            }
            
            tryNextPath();
          });
        }
        
        // Load both assets
        try {
          await Promise.all([
            loadImage('map', assetPaths.map),
            loadImage('spitfire', assetPaths.spitfire)
          ]);
          console.log('ðŸŽ‰ All assets loaded successfully!');
        } catch (error) {
          console.warn('âš ï¸ Some assets failed to load:', error.message);
          console.log('ðŸŽ® Game will continue with fallback graphics');
        }
      }
      
      // Start loading assets
      loadAssets();
      
      // =============================================================================
      // GAME STATE
      // =============================================================================
      
      const game = {
        camera: { x: 0, y: 0, zoom: 0.8, minZoom: 0.2, maxZoom: 3.0 },
        throttle: 0.4,
        keys: new Set(),
        showCollision: false,
        crashed: false
      };
      
      // =============================================================================
      // INPUT
      // =============================================================================
      
      window.addEventListener('keydown', (e) => {
        game.keys.add(e.key.toLowerCase());
        if (['w','s','a','d','q','e','arrowleft','arrowright','r','c'].includes(e.key.toLowerCase())) {
          e.preventDefault();
        }
        
        // Toggle collision debug view
        if (e.key.toLowerCase() === 'c') {
          game.showCollision = !game.showCollision;
          console.log('ðŸ” Collision debug:', game.showCollision ? 'ON' : 'OFF');
        }
      });
      
      window.addEventListener('keyup', (e) => {
        game.keys.delete(e.key.toLowerCase());
      });
      
      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        game.camera.zoom = Math.max(game.camera.minZoom, 
          Math.min(game.camera.maxZoom, game.camera.zoom + delta));
      });
      
      // =============================================================================
      // PHYSICS
      // =============================================================================
      
      // Create aircraft - spawn in center of map
      const aircraft = world.createBody({
        type: 'dynamic',
        position: pl.Vec2(0, 200), // Center of map, above ground
        angle: 0,
        linearDamping: 0.1,
        angularDamping: 0.9
      });
      
      aircraft.createFixture({
        shape: pl.Box(8, 2.5), // 16m x 5m aircraft
        density: 20, // kg/mÂ²
        friction: 0.3,
        restitution: 0.1
      });
      
      // Create ground collision bodies that match the visible terrain
      const groundBodies = [];
      
      function createGroundCollision() {
        // Create a simple ground collision area that covers the bottom half of the map
        const groundLevel = 1200; // Y position where ground starts
        const groundThickness = 600; // How thick the ground collision is
        
        const groundBody = world.createBody({
          type: 'static',
          position: pl.Vec2(0, groundLevel + groundThickness / 2)
        });
        
        groundBody.createFixture({
          shape: pl.Box(WORLD_WIDTH / 2, groundThickness / 2),
          friction: 1.0,
          restitution: 0.0 // No bounce - aircraft stops when hitting ground
        });
        
        groundBodies.push({
          body: groundBody,
          x: 0,
          y: groundLevel + groundThickness / 2,
          width: WORLD_WIDTH,
          height: groundThickness,
          isMainGround: true
        });
        
        console.log(`ðŸŸ¢ Created ground collision at y=${groundLevel}`);
      }
      
      createGroundCollision();
      
      // Add collision detection for crashing
      world.on('begin-contact', (contact) => {
        const bodyA = contact.getFixtureA().getBody();
        const bodyB = contact.getFixtureB().getBody();
        
        // Check if aircraft hit ground
        if ((bodyA === aircraft || bodyB === aircraft)) {
          const vel = aircraft.getLinearVelocity();
          const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
          
          // Crash if hitting ground too fast
          if (speed > 15) {
            game.crashed = true;
            console.log('ðŸ’¥ CRASHED! Speed was:', speed.toFixed(1), 'm/s');
            
            // Stop the aircraft
            aircraft.setLinearVelocity(pl.Vec2(0, 0));
            aircraft.setAngularVelocity(0);
          } else {
            console.log('ðŸ›¬ Safe landing at speed:', speed.toFixed(1), 'm/s');
          }
        }
      });
      
      // =============================================================================
      // PHYSICS UPDATE
      // =============================================================================
      
      function updatePhysics(dt) {
        const pos = aircraft.getPosition();
        const vel = aircraft.getLinearVelocity();
        const angle = aircraft.getAngle();
        
        // Controls
        const pitchUp = game.keys.has('a');
        const pitchDown = game.keys.has('d');
        const rollLeft = game.keys.has('arrowleft');
        const rollRight = game.keys.has('arrowright');
        const throttleUp = game.keys.has('w');
        const throttleDown = game.keys.has('s');
        const zoomIn = game.keys.has('e');
        const zoomOut = game.keys.has('q');
        const reset = game.keys.has('r');
        
        // Reset
        if (reset) {
          aircraft.setTransform(pl.Vec2(0, 200), 0); // Reset to center of map
          aircraft.setLinearVelocity(pl.Vec2(0, 0));
          aircraft.setAngularVelocity(0);
          game.throttle = 0.4;
          game.camera.zoom = 0.8;
          game.crashed = false; // Reset crash state
          return;
        }
        
        // Don't allow control if crashed
        if (game.crashed) {
          return;
        }
        
        // Throttle
        if (throttleUp) game.throttle = Math.min(1.0, game.throttle + dt * 0.6);
        if (throttleDown) game.throttle = Math.max(0.0, game.throttle - dt * 0.8);
        
        // Zoom
        if (zoomIn) game.camera.zoom = Math.min(game.camera.maxZoom, game.camera.zoom + dt * 1.2);
        if (zoomOut) game.camera.zoom = Math.max(game.camera.minZoom, game.camera.zoom - dt * 1.2);
        
        // Flight controls
        const torque = 12000;
        if (pitchUp) aircraft.applyTorque(-torque, true);
        if (pitchDown) aircraft.applyTorque(torque, true);
        if (rollLeft) aircraft.applyTorque(-torque * 0.5, true);
        if (rollRight) aircraft.applyTorque(torque * 0.5, true);
        
        // Thrust
        const maxThrust = 30000;
        const thrust = game.throttle * maxThrust;
        const thrustX = Math.cos(angle) * thrust;
        const thrustY = Math.sin(angle) * thrust;
        aircraft.applyForceToCenter(pl.Vec2(thrustX, thrustY), true);
        
        // Simple aerodynamics
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        if (speed > 1) {
          const airDensity = 1.225;
          const wingArea = 20;
          const q = 0.5 * airDensity * speed * speed;
          
          // Lift (simplified)
          const velAngle = Math.atan2(vel.y, vel.x);
          const aoa = angle - velAngle;
          const liftCoeff = Math.sin(aoa * 2) * 1.5;
          const liftMag = q * wingArea * liftCoeff;
          const liftAngle = velAngle + Math.PI / 2;
          aircraft.applyForceToCenter(pl.Vec2(
            Math.cos(liftAngle) * liftMag,
            Math.sin(liftAngle) * liftMag
          ), true);
          
          // Drag
          const dragCoeff = 0.08 + Math.abs(liftCoeff) * 0.1;
          const dragMag = q * wingArea * dragCoeff;
          aircraft.applyForceToCenter(pl.Vec2(
            -vel.x * dragMag / speed,
            -vel.y * dragMag / speed
          ), true);
        }
      }
      
      // =============================================================================
      // RENDERING
      // =============================================================================
      
      function worldToScreen(wx, wy) {
        const sx = (wx - game.camera.x) * SCALE * game.camera.zoom + canvasWidth / 2;
        const sy = (wy - game.camera.y) * SCALE * game.camera.zoom + canvasHeight / 2;
        return { x: sx, y: sy };
      }
      
      function render() {
        // Clear
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        
        // Background
        if (assets.loaded.map && assets.map) {
          const mapW = WORLD_WIDTH * SCALE * game.camera.zoom;
          const mapH = WORLD_HEIGHT * SCALE * game.camera.zoom;
          const mapPos = worldToScreen(-WORLD_WIDTH/2, -WORLD_HEIGHT/2);
          ctx.drawImage(assets.map, mapPos.x, mapPos.y, mapW, mapH);
        } else {
          // Fallback sky
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#98FB98');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // Loading indicator
          if (!assets.loaded.map) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '20px sans-serif';
            ctx.fillText('Loading map.png...', 50, 50);
          }
        }
        
        // Draw green ground area
        groundBodies.forEach(ground => {
          if (ground.isMainGround) {
            const groundPos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const groundWidth = ground.width * SCALE * game.camera.zoom;
            const groundHeight = ground.height * SCALE * game.camera.zoom;
            
            ctx.fillStyle = '#228B22'; // Forest green
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, groundHeight);
            
            // Add a grass texture effect
            ctx.fillStyle = '#32CD32'; // Lime green for grass top
            ctx.fillRect(groundPos.x, groundPos.y, groundWidth, Math.min(20 * game.camera.zoom, groundHeight * 0.1));
          }
        });
        
        // Aircraft
        const pos = aircraft.getPosition();
        const angle = aircraft.getAngle();
        const screenPos = worldToScreen(pos.x, pos.y);
        
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(angle);
        
        if (assets.loaded.spitfire && assets.spitfire) {
          const scale = 0.4 * game.camera.zoom;
          const w = assets.spitfire.naturalWidth * scale;
          const h = assets.spitfire.naturalHeight * scale;
          ctx.drawImage(assets.spitfire, -w/2, -h/2, w, h);
        } else {
          // Fallback plane
          ctx.fillStyle = '#4169E1';
          ctx.strokeStyle = '#000080';
          ctx.lineWidth = 2;
          const size = 20 * game.camera.zoom;
          ctx.fillRect(-size, -size/3, size*2, size*2/3);
          ctx.strokeRect(-size, -size/3, size*2, size*2/3);
        }
        
        ctx.restore();
        
        // Debug: Draw collision boundaries (press 'C' to toggle)
        if (game.showCollision) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.lineWidth = 2;
          
          groundBodies.forEach(ground => {
            const pos = worldToScreen(ground.x - ground.width/2, ground.y - ground.height/2);
            const width = ground.width * SCALE * game.camera.zoom;
            const height = ground.height * SCALE * game.camera.zoom;
            ctx.strokeRect(pos.x, pos.y, width, height);
          });
          
          ctx.restore();
        }
      }
      
      function updateHUD() {
        const vel = aircraft.getLinearVelocity();
        const pos = aircraft.getPosition();
        const speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
        
        document.getElementById('speed').textContent = Math.round(speed);
        document.getElementById('throttle').textContent = Math.round(game.throttle * 100);
        document.getElementById('altitude').textContent = Math.round(Math.max(0, 1200 - pos.y)); // Updated for new ground level
        document.getElementById('zoom').textContent = game.camera.zoom.toFixed(1);
        
        // Show crash status
        if (game.crashed) {
          const crashDiv = document.querySelector('.crash-indicator') || (() => {
            const div = document.createElement('div');
            div.className = 'crash-indicator';
            div.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:red;font-size:24px;font-weight:bold;text-shadow:2px 2px 4px black;';
            document.body.appendChild(div);
            return div;
          })();
          crashDiv.textContent = 'ðŸ’¥ CRASHED! Press R to restart';
        } else {
          const crashDiv = document.querySelector('.crash-indicator');
          if (crashDiv) crashDiv.remove();
        }
      }
      
      function updateCamera() {
        const pos = aircraft.getPosition();
        game.camera.x = pos.x;
        game.camera.y = pos.y;
      }
      
      // =============================================================================
      // GAME LOOP
      // =============================================================================
      
      let lastTime = performance.now();
      const timeStep = 1/60;
      let accumulator = 0;
      
      function gameLoop(time) {
        const dt = Math.min((time - lastTime) / 1000, 0.05);
        lastTime = time;
        accumulator += dt;
        
        while (accumulator >= timeStep) {
          updatePhysics(timeStep);
          world.step(timeStep);
          accumulator -= timeStep;
        }
        
        updateCamera();
        render();
        updateHUD();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Start
      console.log('Starting flight simulator...');
      gameLoop(performance.now());
      
    })();
  </script>
</body>
</html>